{"Id": "57670132", "PostTypeId": "1", "AcceptedAnswerId": "57670285", "CreationDate": "2019-08-27T07:59:30.377", "Score": "3", "ViewCount": "10372", "Body": "<p>I'm trying to create a file that includes the ID's of multiple server hosts that were generated with the <code>count</code> attribute:</p>\n\n<pre><code>resource \"aws_instance\" \"workers\" {\n  count                  = \"${var.worker_count}\"\n  ...\n}\n</code></pre>\n\n<pre><code>resource \"local_file\" \"stop_instances\" {\n  filename = \"${path.module}/generated/stop_instances.py\"\n  content =&lt;&lt;EOF\nimport boto3\n\n# Boto Connection\nec2 = boto3.resource('ec2', '${var.region}')\n\ndef lambda_handler(event, context):\n  # Retrieve instance IDs\n  instance_ids = [\"${aws_instance.controller.id}\", \"${aws_instance.gateway.id}\", \"${aws_instance.workers.*.id}\"]\n\n  # stopping instances\n  stopping_instances = ec2.instances.filter(InstanceIds=instance_ids).stop()\nEOF\n}\n</code></pre>\n\n<p>However, I'm getting the following error:</p>\n\n<pre><code> 447:   instance_ids = [\"${aws_instance.controller.id}\", \n              \"${aws_instance.gateway.id}\", \"${aws_instance.workers.*.id}\"]\n 449: \n 450: \n 451: \n    |----------------\n    | aws_instance.workers is tuple with 3 elements\n\nCannot include the given value in a string template: string required.\n</code></pre>\n\n<p>Is there a way that I can flatten the tuple to a string?</p>\n\n<p>I've tried the <a href=\"https://www.terraform.io/docs/configuration/functions/tostring.html\" rel=\"nofollow noreferrer\">tostring()</a> method, but that only accepts primitive types.</p>\n", "OwnerUserId": "1033422", "LastActivityDate": "2019-08-28T18:30:29.603", "Title": "How to flatten a tuple of server ids to a string?", "Tags": "<terraform>", "AnswerCount": "2", "CommentCount": "0", "ContentLicense": "CC BY-SA 4.0", "history": [{"Id": "204232033", "PostHistoryTypeId": "2", "PostId": "57670132", "RevisionGUID": "779fc15f-becb-4a86-be7b-7e5c99d4291e", "CreationDate": "2019-08-27T07:59:30.377", "UserId": "1033422", "Text": "I'm trying to create a file that includes the ID's of multiple server hosts that were generated with the `count` attribute:\r\n\r\n    resource \"aws_instance\" \"workers\" {\r\n      count                  = \"${var.worker_count}\"\r\n      ...\r\n    }\r\n\r\n<!-- language: hcl -->\r\n\r\n    resource \"local_file\" \"stop_instances\" {\r\n      filename = \"${path.module}/generated/stop_instances.py\"\r\n      content =<<EOF\r\n    import boto3\r\n    \r\n    # Boto Connection\r\n    ec2 = boto3.resource('ec2', '${var.region}')\r\n    \r\n    def lambda_handler(event, context):\r\n      # Retrieve instance IDs\r\n      instance_ids = [\"${aws_instance.controller.id}\", \"${aws_instance.gateway.id}\", \"${aws_instance.workers.*.id}\"]\r\n    \r\n      # stopping instances\r\n      stopping_instances = ec2.instances.filter(InstanceIds=instance_ids).stop()\r\n    EOF\r\n    }\r\n\r\nHowever, I'm getting the following error:\r\n\r\n     447:   instance_ids = [\"${aws_instance.controller.id}\", \r\n                  \"${aws_instance.gateway.id}\", \"${aws_instance.workers.*.id}\"]\r\n     449: \r\n     450: \r\n     451: \r\n        |----------------\r\n        | aws_instance.workers is tuple with 3 elements\r\n    \r\n    Cannot include the given value in a string template: string required.\r\n\r\nIs there a way that I can flatten the tuple to a string?\r\n\r\nI've tried the [tostring()][1] method, but that only accepts primitive types.\r\n\r\n\r\n  [1]: https://www.terraform.io/docs/configuration/functions/tostring.html\r\n\r\n", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "I'm trying to create a file that includes the ID's of multiple server hosts that were generated with the `count` attribute: resource \"aws_instance\" \"workers\" { count = \"${var.worker_count}\" ... } resource \"local_file\" \"stop_instances\" { filename = \"${path.module}/generated/stop_instances.py\" content =<<EOF import boto3 # Boto Connection ec2 = boto3.resource('ec2', '${var.region}') def lambda_handler(event, context): # Retrieve instance IDs instance_ids = [\"${aws_instance.controller.id}\", \"${aws_instance.gateway.id}\", \"${aws_instance.workers.*.id}\"] # stopping instances stopping_instances = ec2.instances.filter(InstanceIds=instance_ids).stop() EOF } However, I'm getting the following error: 447: instance_ids = [\"${aws_instance.controller.id}\", \"${aws_instance.gateway.id}\", \"${aws_instance.workers.*.id}\"] ", "keywords": ["instance"]}]}, {"Id": "204232034", "PostHistoryTypeId": "1", "PostId": "57670132", "RevisionGUID": "779fc15f-becb-4a86-be7b-7e5c99d4291e", "CreationDate": "2019-08-27T07:59:30.377", "UserId": "1033422", "Text": "How to flatten a tuple of server ids to a string?", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "204232035", "PostHistoryTypeId": "3", "PostId": "57670132", "RevisionGUID": "779fc15f-becb-4a86-be7b-7e5c99d4291e", "CreationDate": "2019-08-27T07:59:30.377", "UserId": "1033422", "Text": "<terraform>", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "answers": [{"Id": "57670285", "PostTypeId": "2", "ParentId": "57670132", "CreationDate": "2019-08-27T08:08:27.247", "Score": "3", "Body": "<p><a href=\"https://www.terraform.io/docs/configuration/functions/join.html\" rel=\"nofollow noreferrer\">join</a> was the solution for me:</p>\n\n<pre><code>instance_ids = [\"${aws_instance.controller.id}\",\"${aws_instance.gateway.id}\",\"${join(\"\\\",\\\"\", aws_instance.workers.*.id)}\"]\n</code></pre>\n", "OwnerUserId": "1033422", "LastActivityDate": "2019-08-27T08:08:27.247", "CommentCount": "0", "ContentLicense": "CC BY-SA 4.0", "history": [{"Id": "204232664", "PostHistoryTypeId": "2", "PostId": "57670285", "RevisionGUID": "e98ccccb-85b7-4211-9d04-2aa6092fc80c", "CreationDate": "2019-08-27T08:08:27.247", "UserId": "1033422", "Text": "[join][1] was the solution for me:\r\n\r\n    instance_ids = [\"${aws_instance.controller.id}\",\"${aws_instance.gateway.id}\",\"${join(\"\\\",\\\"\", aws_instance.workers.*.id)}\"]\r\n\r\n\r\n  [1]: https://www.terraform.io/docs/configuration/functions/join.html", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "filtered-sentences": []}, {"Id": "57698238", "PostTypeId": "2", "ParentId": "57670132", "CreationDate": "2019-08-28T18:30:29.603", "Score": "1", "Body": "<p>The best way to produce a string from a list will depend on the specific situation, because there are lots of different ways to represent a list in a string.</p>\n\n<p>For this particular situation, it seems likely that JSON array/string syntax is compatible enough with Python syntax that you could get away with using <code>jsonencode</code> to produce a Python list expression:</p>\n\n<pre class=\"lang-py prettyprint-override\"><code>import boto3\n\n# Boto Connection\nec2 = boto3.resource('ec2', ${jsonencode(var.region)})\n\ndef lambda_handler(event, context):\n  # Retrieve instance IDs \n  instance_ids = ${jsonencode(\n    concat(\n      [\n        aws_instance.controller.id,\n        aws_instance.gateway.id,\n      ],\n      aws_instance.workers.*.id\n    )\n  )}\n\n  # stopping instances\n  stopping_instances = ec2.instances.filter(InstanceIds=instance_ids).stop()\n</code></pre>\n\n<p>For situations where a <em>lot</em> of data needs to be passed into a program written in another language, and where the JSON syntax might not 100% align with the target language, a more general solution would be to pass the data structure in <em>as</em> JSON and then parse it using the language's own JSON parser.</p>\n\n<p>If you know that all of your values are strings as in this case, you could also simplify things and join all of your string values together with some delimiter using the <code>join</code> function and then split it using Python's <code>split</code> method, at the expense of the resulting source code looking even less like a human might hand-write it.</p>\n", "OwnerUserId": "281848", "LastActivityDate": "2019-08-28T18:30:29.603", "CommentCount": "0", "ContentLicense": "CC BY-SA 4.0", "history": [{"Id": "204346746", "PostHistoryTypeId": "2", "PostId": "57698238", "RevisionGUID": "0a5d0644-f22c-48be-a5cc-f5bab6927f0e", "CreationDate": "2019-08-28T18:30:29.603", "UserId": "281848", "Text": "The best way to produce a string from a list will depend on the specific situation, because there are lots of different ways to represent a list in a string.\r\n\r\nFor this particular situation, it seems likely that JSON array/string syntax is compatible enough with Python syntax that you could get away with using `jsonencode` to produce a Python list expression:\r\n\r\n```python\r\nimport boto3\r\n\r\n# Boto Connection\r\nec2 = boto3.resource('ec2', ${jsonencode(var.region)})\r\n\r\ndef lambda_handler(event, context):\r\n  # Retrieve instance IDs \r\n  instance_ids = ${jsonencode(\r\n    concat(\r\n      [\r\n        aws_instance.controller.id,\r\n        aws_instance.gateway.id,\r\n      ],\r\n      aws_instance.workers.*.id\r\n    )\r\n  )}\r\n\r\n  # stopping instances\r\n  stopping_instances = ec2.instances.filter(InstanceIds=instance_ids).stop()\r\n```\r\n\r\nFor situations where a _lot_ of data needs to be passed into a program written in another language, and where the JSON syntax might not 100% align with the target language, a more general solution would be to pass the data structure in _as_ JSON and then parse it using the language's own JSON parser.\r\n\r\nIf you know that all of your values are strings as in this case, you could also simplify things and join all of your string values together with some delimiter using the `join` function and then split it using Python's `split` method, at the expense of the resulting source code looking even less like a human might hand-write it.\r\n", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "For this particular situation, it seems likely that JSON array/string syntax is compatible enough with Python syntax that you could get away with using `jsonencode` to produce a Python list expression: ```python import boto3 # Boto Connection ec2 = boto3.resource('ec2', ${jsonencode(var.region)}) def lambda_handler(event, context): # Retrieve instance IDs instance_ids = ${jsonencode( concat( [ aws_instance.controller.id, aws_instance.gateway.id, ], aws_instance.workers.*.id ) )} # stopping instances stopping_instances = ec2.instances.filter(InstanceIds=instance_ids).stop() ``` ", "keywords": ["instance"]}, {"source": "Text", "text": "If you know that all of your values are strings as in this case, you could also simplify things and join all of your string values together with some delimiter using the `join` function and then split it using Python's `split` method, at the expense of the resulting source code looking even less like a human might hand-write it.", "keywords": ["expense"]}]}], "filtered-sentences": [{"source": "Body", "text": "If you know that all of your values are strings as in this case, you could also simplify things and join all of your string values together with some delimiter using the join function and then split it using Python's split method, at the expense of the resulting source code looking even less like a human might hand-write it.", "keywords": ["expense"]}]}], "contains-topic": true, "filtered-sentences": []}