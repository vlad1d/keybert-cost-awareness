{"Id": "71889783", "PostTypeId": "1", "AcceptedAnswerId": "71892786", "CreationDate": "2022-04-15T23:19:08.043", "Score": "2", "ViewCount": "285", "Body": "<p>I got the following setup to create the networking requirements for a Fargate setup:</p>\n<pre><code>resource &quot;aws_vpc&quot; &quot;main&quot; {\n  cidr_block = var.cidr\n  tags = {\n    Environment = var.environment\n    DO_NOT_DELETE = true\n    CreatedBy = &quot;terraform&quot;\n  }\n}\n \nresource &quot;aws_internet_gateway&quot; &quot;main&quot; {\n  vpc_id = aws_vpc.main.id\n  tags = {\n    Environment = var.environment\n    CreatedBy = &quot;terraform&quot;\n    Vpc = aws_vpc.main.id\n  }\n}\n\ndata &quot;aws_availability_zones&quot; &quot;region_azs&quot; {\n  state = &quot;available&quot;\n}\n\nlocals {\n  az_count = length(data.aws_availability_zones.region_azs.names)\n}\n\nresource &quot;aws_subnet&quot; &quot;private&quot; {\n  vpc_id            = aws_vpc.main.id\n  cidr_block        = cidrsubnet(aws_vpc.main.cidr_block, 4, count.index)\n  availability_zone = data.aws_availability_zones.region_azs.names[count.index]\n  count             = local.az_count\n\n  tags = {\n    Name = &quot;public-subnet-${data.aws_availability_zones.region_azs.names[count.index]}&quot;\n    AvailabilityZone = data.aws_availability_zones.region_azs.names[count.index]\n    Environment = var.environment\n    CreatedBy = &quot;terraform&quot;\n    Vpc = aws_vpc.main.id\n    Type = &quot;private&quot;\n    DO_NOT_DELETE = true\n  }\n}\n \nresource &quot;aws_subnet&quot; &quot;public&quot; {\n  vpc_id                  = aws_vpc.main.id\n  cidr_block              = cidrsubnet(aws_vpc.main.cidr_block, 4, count.index + local.az_count )\n  availability_zone = data.aws_availability_zones.region_azs.names[count.index]\n  count             = local.az_count\n  map_public_ip_on_launch = true\n\n  tags = {\n    Environment = var.environment\n    CreatedBy = &quot;terraform&quot;\n    Vpc = aws_vpc.main.id\n    DO_NOT_DELETE = true\n    Type = &quot;public&quot;\n  }\n}\n\nresource &quot;aws_route_table&quot; &quot;public&quot; {\n  vpc_id = aws_vpc.main.id\n  tags = {\n    Environment = var.environment\n    CreatedBy = &quot;terraform&quot;\n    Vpc = aws_vpc.main.id\n    Type = &quot;public&quot;\n  }\n}\n \nresource &quot;aws_route&quot; &quot;public&quot; {\n  route_table_id         = aws_route_table.public.id\n  destination_cidr_block = &quot;0.0.0.0/0&quot;\n  gateway_id             = aws_internet_gateway.main.id\n}\n \nresource &quot;aws_route_table_association&quot; &quot;public&quot; {\n  count          = local.az_count\n  subnet_id      = element(aws_subnet.public.*.id, count.index)\n  route_table_id = aws_route_table.public.id\n}\n\nresource &quot;aws_nat_gateway&quot; &quot;main&quot; {\n  count         = local.az_count\n  allocation_id = element(aws_eip.nat.*.id, count.index)\n  subnet_id     = element(aws_subnet.public.*.id, count.index)\n  depends_on    = [aws_internet_gateway.main]\n\n  tags = {\n    Environment = var.environment\n    CreatedBy = &quot;terraform&quot; \n    Vpc = aws_vpc.main.id\n  }\n}\n \nresource &quot;aws_eip&quot; &quot;nat&quot; {\n  count = local.az_count\n  vpc = true\n\n  tags = {\n    CreatedBy = &quot;terraform&quot;\n    Vpc = aws_vpc.main.id\n  }\n}\n\nresource &quot;aws_route_table&quot; &quot;private&quot; {\n  count  = local.az_count\n  vpc_id = aws_vpc.main.id\n\n  tags = {\n    Environment = var.environment\n    CreatedBy = &quot;terraform&quot;\n    Type = &quot;private&quot;\n    Vpc = aws_vpc.main.id\n  }\n}\n \nresource &quot;aws_route&quot; &quot;private&quot; {\n  count                  = local.az_count\n  route_table_id         = element(aws_route_table.private.*.id, count.index)\n  destination_cidr_block = &quot;0.0.0.0/0&quot;\n  nat_gateway_id         = element(aws_nat_gateway.main.*.id, count.index)\n}\n \nresource &quot;aws_route_table_association&quot; &quot;private&quot; {\n  count          = local.az_count\n  subnet_id      = element(aws_subnet.private.*.id, count.index)\n  route_table_id = element(aws_route_table.private.*.id, count.index)\n}\n\nresource &quot;aws_security_group&quot; &quot;alb&quot; {\n  name   = &quot;${var.resources_name_prefix}-alb-sg&quot;\n  vpc_id = aws_vpc.main.id\n \n  ingress {\n   protocol         = &quot;tcp&quot;\n   from_port        = 80\n   to_port          = 80\n   cidr_blocks      = [&quot;0.0.0.0/0&quot;]\n   ipv6_cidr_blocks = [&quot;::/0&quot;]\n  }\n \n  ingress {\n   protocol         = &quot;tcp&quot;\n   from_port        = 443\n   to_port          = 443\n   cidr_blocks      = [&quot;0.0.0.0/0&quot;]\n   ipv6_cidr_blocks = [&quot;::/0&quot;]\n  }\n \n  egress {\n   protocol         = &quot;-1&quot;\n   from_port        = 0\n   to_port          = 0\n   cidr_blocks      = [&quot;0.0.0.0/0&quot;]\n   ipv6_cidr_blocks = [&quot;::/0&quot;]\n  }\n\n  tags = {\n    Environment = var.environment\n    CreatedBy = &quot;terraform&quot;\n    Vpc = aws_vpc.main.id\n  }\n}\n\nresource &quot;aws_security_group&quot; &quot;ecs_tasks&quot; {\n  name   = &quot;${var.resources_name_prefix}-ecs-sg&quot;\n  vpc_id = aws_vpc.main.id\n \n  ingress {\n   protocol         = &quot;tcp&quot;\n   from_port        = 3000\n   to_port          = 3000\n   cidr_blocks      = [&quot;0.0.0.0/0&quot;]\n   ipv6_cidr_blocks = [&quot;::/0&quot;]\n  }\n\n  egress {\n   protocol         = &quot;-1&quot;\n   from_port        = 0\n   to_port          = 0\n   cidr_blocks      = [&quot;0.0.0.0/0&quot;]\n   ipv6_cidr_blocks = [&quot;::/0&quot;]\n  }\n\n  tags = {\n    Environment = var.environment\n    CreatedBy = &quot;terraform&quot;\n    Vpc = aws_vpc.main.id\n  }\n}\n\n</code></pre>\n<p>This is been working great for a couple availability zones, but now that I'm dynamically creating subnets for running tasks in every AZ per region, I'm reaching the limit of Elastic IP's per region.</p>\n<p>So I'm getting this erorr while trying to create the stack:</p>\n<pre><code>Error creating EIP: AddressLimitExceeded: The maximum number of addresses has been reached.\n       status code: 400\n</code></pre>\n<p>I'm wodering if the following part:</p>\n<pre><code>resource &quot;aws_nat_gateway&quot; &quot;main&quot; {\n  count         = local.az_count\n  allocation_id = element(aws_eip.nat.*.id, count.index)\n  subnet_id     = element(aws_subnet.public.*.id, count.index)\n  depends_on    = [aws_internet_gateway.main]\n\n  tags = {\n    Environment = var.environment\n    CreatedBy = &quot;terraform&quot; \n    Vpc = aws_vpc.main.id\n  }\n}\n \nresource &quot;aws_eip&quot; &quot;nat&quot; {\n  count = local.az_count\n  vpc = true\n\n  tags = {\n    CreatedBy = &quot;terraform&quot;\n    Vpc = aws_vpc.main.id\n  }\n}\n</code></pre>\n<p>Could be structured to use a single EIP and routing internally, if this makes sense.</p>\n", "OwnerUserId": "742560", "LastEditorUserId": "742560", "LastEditDate": "2022-04-15T23:47:58.887", "LastActivityDate": "2022-12-05T18:46:32.520", "Title": "How to reuse Elastic IPs for a set of private and public subnets dedicated to Fargate tasks", "Tags": "<amazon-web-services><networking><terraform><amazon-vpc><elastic-ip>", "AnswerCount": "1", "CommentCount": "2", "ContentLicense": "CC BY-SA 4.0", "comments": [{"Id": "127037328", "PostId": "71889783", "Score": "0", "Text": "You don't need NAT in each AZ, unless you are really worrying about redundancy and high availability. I would just create 2 NATs, regardless of how many AZs is there.", "CreationDate": "2022-04-16T03:11:56.687", "UserId": "248823", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "You don't need NAT in each AZ, unless you are really worrying about redundancy and high availability. ", "keywords": ["nat"]}]}, {"Id": "127040012", "PostId": "71889783", "Score": "0", "Text": "@Marcin could you share an example on how you\u00b4d create those two NATS and randomly/arbitrarily assign them to AZ subsnets?", "CreationDate": "2022-04-16T09:03:38.570", "UserId": "742560", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "history": [{"Id": "268254493", "PostHistoryTypeId": "2", "PostId": "71889783", "RevisionGUID": "0c297d75-2595-4881-839a-b2c87aadc7a3", "CreationDate": "2022-04-15T23:19:08.043", "UserId": "742560", "Text": "I got the following setup to create the networking requirements for a Fargate setup:\r\n\r\n```hcl\r\nresource \"aws_vpc\" \"main\" {\r\n  cidr_block = var.cidr\r\n  tags = {\r\n    Environment = var.environment\r\n    DO_NOT_DELETE = true\r\n    CreatedBy = \"terraform\"\r\n  }\r\n}\r\n \r\nresource \"aws_internet_gateway\" \"main\" {\r\n  vpc_id = aws_vpc.main.id\r\n  tags = {\r\n    Environment = var.environment\r\n    CreatedBy = \"terraform\"\r\n    Vpc = aws_vpc.main.id\r\n  }\r\n}\r\n\r\ndata \"aws_availability_zones\" \"region_azs\" {\r\n  state = \"available\"\r\n}\r\n\r\nlocals {\r\n  az_count = length(data.aws_availability_zones.region_azs.names)\r\n}\r\n\r\nresource \"aws_subnet\" \"private\" {\r\n  vpc_id            = aws_vpc.main.id\r\n  cidr_block        = cidrsubnet(aws_vpc.main.cidr_block, 4, count.index)\r\n  availability_zone = data.aws_availability_zones.region_azs.names[count.index]\r\n  count             = local.az_count\r\n\r\n  tags = {\r\n    Name = \"public-subnet-${data.aws_availability_zones.region_azs.names[count.index]}\"\r\n    AvailabilityZone = data.aws_availability_zones.region_azs.names[count.index]\r\n    Environment = var.environment\r\n    CreatedBy = \"terraform\"\r\n    Vpc = aws_vpc.main.id\r\n    Type = \"private\"\r\n    DO_NOT_DELETE = true\r\n  }\r\n}\r\n \r\nresource \"aws_subnet\" \"public\" {\r\n  vpc_id                  = aws_vpc.main.id\r\n  cidr_block              = cidrsubnet(aws_vpc.main.cidr_block, 4, count.index + local.az_count )\r\n  availability_zone = data.aws_availability_zones.region_azs.names[count.index]\r\n  count             = local.az_count\r\n  map_public_ip_on_launch = true\r\n\r\n  tags = {\r\n    Environment = var.environment\r\n    CreatedBy = \"terraform\"\r\n    Vpc = aws_vpc.main.id\r\n    DO_NOT_DELETE = true\r\n    Type = \"public\"\r\n  }\r\n}\r\n\r\nresource \"aws_route_table\" \"public\" {\r\n  vpc_id = aws_vpc.main.id\r\n  tags = {\r\n    Environment = var.environment\r\n    CreatedBy = \"terraform\"\r\n    Vpc = aws_vpc.main.id\r\n    Type = \"public\"\r\n  }\r\n}\r\n \r\nresource \"aws_route\" \"public\" {\r\n  route_table_id         = aws_route_table.public.id\r\n  destination_cidr_block = \"0.0.0.0/0\"\r\n  gateway_id             = aws_internet_gateway.main.id\r\n}\r\n \r\nresource \"aws_route_table_association\" \"public\" {\r\n  count          = local.az_count\r\n  subnet_id      = element(aws_subnet.public.*.id, count.index)\r\n  route_table_id = aws_route_table.public.id\r\n}\r\n\r\nresource \"aws_nat_gateway\" \"main\" {\r\n  count         = local.az_count\r\n  allocation_id = element(aws_eip.nat.*.id, count.index)\r\n  subnet_id     = element(aws_subnet.public.*.id, count.index)\r\n  depends_on    = [aws_internet_gateway.main]\r\n\r\n  tags = {\r\n    Environment = var.environment\r\n    CreatedBy = \"terraform\" \r\n    Vpc = aws_vpc.main.id\r\n  }\r\n}\r\n \r\nresource \"aws_eip\" \"nat\" {\r\n  count = local.az_count\r\n  vpc = true\r\n\r\n  tags = {\r\n    CreatedBy = \"terraform\"\r\n    Vpc = aws_vpc.main.id\r\n  }\r\n}\r\n\r\nresource \"aws_route_table\" \"private\" {\r\n  count  = local.az_count\r\n  vpc_id = aws_vpc.main.id\r\n\r\n  tags = {\r\n    Environment = var.environment\r\n    CreatedBy = \"terraform\"\r\n    Type = \"private\"\r\n    Vpc = aws_vpc.main.id\r\n  }\r\n}\r\n \r\nresource \"aws_route\" \"private\" {\r\n  count                  = local.az_count\r\n  route_table_id         = element(aws_route_table.private.*.id, count.index)\r\n  destination_cidr_block = \"0.0.0.0/0\"\r\n  nat_gateway_id         = element(aws_nat_gateway.main.*.id, count.index)\r\n}\r\n \r\nresource \"aws_route_table_association\" \"private\" {\r\n  count          = local.az_count\r\n  subnet_id      = element(aws_subnet.private.*.id, count.index)\r\n  route_table_id = element(aws_route_table.private.*.id, count.index)\r\n}\r\n\r\nresource \"aws_security_group\" \"alb\" {\r\n  name   = \"${var.resources_name_prefix}-alb-sg\"\r\n  vpc_id = aws_vpc.main.id\r\n \r\n  ingress {\r\n   protocol         = \"tcp\"\r\n   from_port        = 80\r\n   to_port          = 80\r\n   cidr_blocks      = [\"0.0.0.0/0\"]\r\n   ipv6_cidr_blocks = [\"::/0\"]\r\n  }\r\n \r\n  ingress {\r\n   protocol         = \"tcp\"\r\n   from_port        = 443\r\n   to_port          = 443\r\n   cidr_blocks      = [\"0.0.0.0/0\"]\r\n   ipv6_cidr_blocks = [\"::/0\"]\r\n  }\r\n \r\n  egress {\r\n   protocol         = \"-1\"\r\n   from_port        = 0\r\n   to_port          = 0\r\n   cidr_blocks      = [\"0.0.0.0/0\"]\r\n   ipv6_cidr_blocks = [\"::/0\"]\r\n  }\r\n\r\n  tags = {\r\n    Environment = var.environment\r\n    CreatedBy = \"terraform\"\r\n    Vpc = aws_vpc.main.id\r\n  }\r\n}\r\n\r\nresource \"aws_security_group\" \"ecs_tasks\" {\r\n  name   = \"${var.resources_name_prefix}-ecs-sg\"\r\n  vpc_id = aws_vpc.main.id\r\n \r\n  ingress {\r\n   protocol         = \"tcp\"\r\n   from_port        = 3000\r\n   to_port          = 3000\r\n   cidr_blocks      = [\"0.0.0.0/0\"]\r\n   ipv6_cidr_blocks = [\"::/0\"]\r\n  }\r\n\r\n  egress {\r\n   protocol         = \"-1\"\r\n   from_port        = 0\r\n   to_port          = 0\r\n   cidr_blocks      = [\"0.0.0.0/0\"]\r\n   ipv6_cidr_blocks = [\"::/0\"]\r\n  }\r\n\r\n  tags = {\r\n    Environment = var.environment\r\n    CreatedBy = \"terraform\"\r\n    Vpc = aws_vpc.main.id\r\n  }\r\n}\r\n\r\n```\r\n\r\nThis is been working great for a couple availability zones, but now that I'm dynamically creating subnets for running tasks in every AZ per region, I'm reaching the limit of Elastic IP's per region.\r\n\r\nI'm wodering if the following part:\r\n\r\n```\r\nresource \"aws_nat_gateway\" \"main\" {\r\n  count         = local.az_count\r\n  allocation_id = element(aws_eip.nat.*.id, count.index)\r\n  subnet_id     = element(aws_subnet.public.*.id, count.index)\r\n  depends_on    = [aws_internet_gateway.main]\r\n\r\n  tags = {\r\n    Environment = var.environment\r\n    CreatedBy = \"terraform\" \r\n    Vpc = aws_vpc.main.id\r\n  }\r\n}\r\n \r\nresource \"aws_eip\" \"nat\" {\r\n  count = local.az_count\r\n  vpc = true\r\n\r\n  tags = {\r\n    CreatedBy = \"terraform\"\r\n    Vpc = aws_vpc.main.id\r\n  }\r\n}\r\n```\r\n\r\nCould be structured to use a single EIP and routing internally, if this makes sense.", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "I got the following setup to create the networking requirements for a Fargate setup: ```hcl resource \"aws_vpc\" \"main\" { cidr_block = var.cidr tags = { Environment = var.environment DO_NOT_DELETE = true CreatedBy = \"terraform\" } } resource \"aws_internet_gateway\" \"main\" { vpc_id = aws_vpc.main.id tags = { Environment = var.environment CreatedBy = \"terraform\" Vpc = aws_vpc.main.id } } data \"aws_availability_zones\" \"region_azs\" { state = \"available\" } locals { az_count = length(data.aws_availability_zones.region_azs.names) } resource \"aws_subnet\" \"private\" { vpc_id = aws_vpc.main.id cidr_block = cidrsubnet(aws_vpc.main.cidr_block, 4, count.index) availability_zone = data.aws_availability_zones.region_azs.names[count.index] count = local.az_count tags = { Name = \"public-subnet-${data.aws_availability_zones.region_azs.names[count.index]}\" AvailabilityZone = data.aws_availability_zones.region_azs.names[count.index] Environment = var.environment CreatedBy = \"terraform\" Vpc = aws_vpc.main.id Type = \"private\" DO_NOT_DELETE = true } } resource \"aws_subnet\" \"public\" { vpc_id = aws_vpc.main.id cidr_block = cidrsubnet(aws_vpc.main.cidr_block, 4, count.index + local.az_count ) availability_zone = data.aws_availability_zones.region_azs.names[count.index] count = local.az_count map_public_ip_on_launch = true tags = { Environment = var.environment CreatedBy = \"terraform\" Vpc = aws_vpc.main.id DO_NOT_DELETE = true Type = \"public\" } } resource \"aws_route_table\" \"public\" { vpc_id = aws_vpc.main.id tags = { Environment = var.environment CreatedBy = \"terraform\" Vpc = aws_vpc.main.id Type = \"public\" } } resource \"aws_route\" \"public\" { route_table_id = aws_route_table.public.id destination_cidr_block = \"0.0.0.0/0\" gateway_id = aws_internet_gateway.main.id } resource \"aws_route_table_association\" \"public\" { count = local.az_count subnet_id = element(aws_subnet.public.*.id, count.index) route_table_id = aws_route_table.public.id } resource \"aws_nat_gateway\" \"main\" { count = local.az_count allocation_id = element(aws_eip.nat.*.id, count.index) subnet_id = element(aws_subnet.public.*.id, count.index) depends_on = [aws_internet_gateway.main] tags = { Environment = var.environment CreatedBy = \"terraform\" Vpc = aws_vpc.main.id } } resource \"aws_eip\" \"nat\" { count = local.az_count vpc = true tags = { CreatedBy = \"terraform\" Vpc = aws_vpc.main.id } } resource \"aws_route_table\" \"private\" { count = local.az_count vpc_id = aws_vpc.main.id tags = { Environment = var.environment CreatedBy = \"terraform\" Type = \"private\" Vpc = aws_vpc.main.id } } resource \"aws_route\" \"private\" { count = local.az_count route_table_id = element(aws_route_table.private.*.id, count.index) destination_cidr_block = \"0.0.0.0/0\" nat_gateway_id = element(aws_nat_gateway.main.*.id, count.index) } resource \"aws_route_table_association\" \"private\" { count = local.az_count subnet_id = element(aws_subnet.private.*.id, count.index) route_table_id = element(aws_route_table.private.*.id, count.index) } resource \"aws_security_group\" \"alb\" { name = \"${var.resources_name_prefix}-alb-sg\" vpc_id = aws_vpc.main.id ingress { protocol = \"tcp\" from_port = 80 to_port = 80 cidr_blocks = [\"0.0.0.0/0\"] ipv6_cidr_blocks = [\"::/0\"] } ingress { protocol = \"tcp\" from_port = 443 to_port = 443 cidr_blocks = [\"0.0.0.0/0\"] ipv6_cidr_blocks = [\"::/0\"] } egress { protocol = \"-1\" from_port = 0 to_port = 0 cidr_blocks = [\"0.0.0.0/0\"] ipv6_cidr_blocks = [\"::/0\"] } tags = { Environment = var.environment CreatedBy = \"terraform\" Vpc = aws_vpc.main.id } } resource \"aws_security_group\" \"ecs_tasks\" { name = \"${var.resources_name_prefix}-ecs-sg\" vpc_id = aws_vpc.main.id ingress { protocol = \"tcp\" from_port = 3000 to_port = 3000 cidr_blocks = [\"0.0.0.0/0\"] ipv6_cidr_blocks = [\"::/0\"] } egress { protocol = \"-1\" from_port = 0 to_port = 0 cidr_blocks = [\"0.0.0.0/0\"] ipv6_cidr_blocks = [\"::/0\"] } tags = { Environment = var.environment CreatedBy = \"terraform\" Vpc = aws_vpc.main.id } } ``` ", "keywords": ["networking", "nat"]}, {"source": "Text", "text": "I'm wodering if the following part: ``` resource \"aws_nat_gateway\" \"main\" { count = local.az_count allocation_id = element(aws_eip.nat.*.id, count.index) subnet_id = element(aws_subnet.public.*.id, count.index) depends_on = [aws_internet_gateway.main] tags = { Environment = var.environment CreatedBy = \"terraform\" Vpc = aws_vpc.main.id } } resource \"aws_eip\" \"nat\" { count = local.az_count vpc = true tags = { CreatedBy = \"terraform\" Vpc = aws_vpc.main.id } ", "keywords": ["nat"]}]}, {"Id": "268254495", "PostHistoryTypeId": "1", "PostId": "71889783", "RevisionGUID": "0c297d75-2595-4881-839a-b2c87aadc7a3", "CreationDate": "2022-04-15T23:19:08.043", "UserId": "742560", "Text": "How to reuse Elastic IPs for a set of private and public subnets dedicated to Fargate tasks", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "268254496", "PostHistoryTypeId": "3", "PostId": "71889783", "RevisionGUID": "0c297d75-2595-4881-839a-b2c87aadc7a3", "CreationDate": "2022-04-15T23:19:08.043", "UserId": "742560", "Text": "<amazon-web-services><networking><terraform><amazon-vpc><elastic-ip>", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "268255278", "PostHistoryTypeId": "5", "PostId": "71889783", "RevisionGUID": "ed96a90a-6281-4adf-b425-9a121fb02e13", "CreationDate": "2022-04-15T23:47:58.887", "UserId": "742560", "Comment": "added 192 characters in body", "Text": "I got the following setup to create the networking requirements for a Fargate setup:\r\n\r\n```hcl\r\nresource \"aws_vpc\" \"main\" {\r\n  cidr_block = var.cidr\r\n  tags = {\r\n    Environment = var.environment\r\n    DO_NOT_DELETE = true\r\n    CreatedBy = \"terraform\"\r\n  }\r\n}\r\n \r\nresource \"aws_internet_gateway\" \"main\" {\r\n  vpc_id = aws_vpc.main.id\r\n  tags = {\r\n    Environment = var.environment\r\n    CreatedBy = \"terraform\"\r\n    Vpc = aws_vpc.main.id\r\n  }\r\n}\r\n\r\ndata \"aws_availability_zones\" \"region_azs\" {\r\n  state = \"available\"\r\n}\r\n\r\nlocals {\r\n  az_count = length(data.aws_availability_zones.region_azs.names)\r\n}\r\n\r\nresource \"aws_subnet\" \"private\" {\r\n  vpc_id            = aws_vpc.main.id\r\n  cidr_block        = cidrsubnet(aws_vpc.main.cidr_block, 4, count.index)\r\n  availability_zone = data.aws_availability_zones.region_azs.names[count.index]\r\n  count             = local.az_count\r\n\r\n  tags = {\r\n    Name = \"public-subnet-${data.aws_availability_zones.region_azs.names[count.index]}\"\r\n    AvailabilityZone = data.aws_availability_zones.region_azs.names[count.index]\r\n    Environment = var.environment\r\n    CreatedBy = \"terraform\"\r\n    Vpc = aws_vpc.main.id\r\n    Type = \"private\"\r\n    DO_NOT_DELETE = true\r\n  }\r\n}\r\n \r\nresource \"aws_subnet\" \"public\" {\r\n  vpc_id                  = aws_vpc.main.id\r\n  cidr_block              = cidrsubnet(aws_vpc.main.cidr_block, 4, count.index + local.az_count )\r\n  availability_zone = data.aws_availability_zones.region_azs.names[count.index]\r\n  count             = local.az_count\r\n  map_public_ip_on_launch = true\r\n\r\n  tags = {\r\n    Environment = var.environment\r\n    CreatedBy = \"terraform\"\r\n    Vpc = aws_vpc.main.id\r\n    DO_NOT_DELETE = true\r\n    Type = \"public\"\r\n  }\r\n}\r\n\r\nresource \"aws_route_table\" \"public\" {\r\n  vpc_id = aws_vpc.main.id\r\n  tags = {\r\n    Environment = var.environment\r\n    CreatedBy = \"terraform\"\r\n    Vpc = aws_vpc.main.id\r\n    Type = \"public\"\r\n  }\r\n}\r\n \r\nresource \"aws_route\" \"public\" {\r\n  route_table_id         = aws_route_table.public.id\r\n  destination_cidr_block = \"0.0.0.0/0\"\r\n  gateway_id             = aws_internet_gateway.main.id\r\n}\r\n \r\nresource \"aws_route_table_association\" \"public\" {\r\n  count          = local.az_count\r\n  subnet_id      = element(aws_subnet.public.*.id, count.index)\r\n  route_table_id = aws_route_table.public.id\r\n}\r\n\r\nresource \"aws_nat_gateway\" \"main\" {\r\n  count         = local.az_count\r\n  allocation_id = element(aws_eip.nat.*.id, count.index)\r\n  subnet_id     = element(aws_subnet.public.*.id, count.index)\r\n  depends_on    = [aws_internet_gateway.main]\r\n\r\n  tags = {\r\n    Environment = var.environment\r\n    CreatedBy = \"terraform\" \r\n    Vpc = aws_vpc.main.id\r\n  }\r\n}\r\n \r\nresource \"aws_eip\" \"nat\" {\r\n  count = local.az_count\r\n  vpc = true\r\n\r\n  tags = {\r\n    CreatedBy = \"terraform\"\r\n    Vpc = aws_vpc.main.id\r\n  }\r\n}\r\n\r\nresource \"aws_route_table\" \"private\" {\r\n  count  = local.az_count\r\n  vpc_id = aws_vpc.main.id\r\n\r\n  tags = {\r\n    Environment = var.environment\r\n    CreatedBy = \"terraform\"\r\n    Type = \"private\"\r\n    Vpc = aws_vpc.main.id\r\n  }\r\n}\r\n \r\nresource \"aws_route\" \"private\" {\r\n  count                  = local.az_count\r\n  route_table_id         = element(aws_route_table.private.*.id, count.index)\r\n  destination_cidr_block = \"0.0.0.0/0\"\r\n  nat_gateway_id         = element(aws_nat_gateway.main.*.id, count.index)\r\n}\r\n \r\nresource \"aws_route_table_association\" \"private\" {\r\n  count          = local.az_count\r\n  subnet_id      = element(aws_subnet.private.*.id, count.index)\r\n  route_table_id = element(aws_route_table.private.*.id, count.index)\r\n}\r\n\r\nresource \"aws_security_group\" \"alb\" {\r\n  name   = \"${var.resources_name_prefix}-alb-sg\"\r\n  vpc_id = aws_vpc.main.id\r\n \r\n  ingress {\r\n   protocol         = \"tcp\"\r\n   from_port        = 80\r\n   to_port          = 80\r\n   cidr_blocks      = [\"0.0.0.0/0\"]\r\n   ipv6_cidr_blocks = [\"::/0\"]\r\n  }\r\n \r\n  ingress {\r\n   protocol         = \"tcp\"\r\n   from_port        = 443\r\n   to_port          = 443\r\n   cidr_blocks      = [\"0.0.0.0/0\"]\r\n   ipv6_cidr_blocks = [\"::/0\"]\r\n  }\r\n \r\n  egress {\r\n   protocol         = \"-1\"\r\n   from_port        = 0\r\n   to_port          = 0\r\n   cidr_blocks      = [\"0.0.0.0/0\"]\r\n   ipv6_cidr_blocks = [\"::/0\"]\r\n  }\r\n\r\n  tags = {\r\n    Environment = var.environment\r\n    CreatedBy = \"terraform\"\r\n    Vpc = aws_vpc.main.id\r\n  }\r\n}\r\n\r\nresource \"aws_security_group\" \"ecs_tasks\" {\r\n  name   = \"${var.resources_name_prefix}-ecs-sg\"\r\n  vpc_id = aws_vpc.main.id\r\n \r\n  ingress {\r\n   protocol         = \"tcp\"\r\n   from_port        = 3000\r\n   to_port          = 3000\r\n   cidr_blocks      = [\"0.0.0.0/0\"]\r\n   ipv6_cidr_blocks = [\"::/0\"]\r\n  }\r\n\r\n  egress {\r\n   protocol         = \"-1\"\r\n   from_port        = 0\r\n   to_port          = 0\r\n   cidr_blocks      = [\"0.0.0.0/0\"]\r\n   ipv6_cidr_blocks = [\"::/0\"]\r\n  }\r\n\r\n  tags = {\r\n    Environment = var.environment\r\n    CreatedBy = \"terraform\"\r\n    Vpc = aws_vpc.main.id\r\n  }\r\n}\r\n\r\n```\r\n\r\nThis is been working great for a couple availability zones, but now that I'm dynamically creating subnets for running tasks in every AZ per region, I'm reaching the limit of Elastic IP's per region.\r\n\r\nSo I'm getting this erorr while trying to create the stack:\r\n\r\n```\r\nError creating EIP: AddressLimitExceeded: The maximum number of addresses has been reached.\r\n       status code: 400\r\n```\r\n\r\nI'm wodering if the following part:\r\n\r\n```\r\nresource \"aws_nat_gateway\" \"main\" {\r\n  count         = local.az_count\r\n  allocation_id = element(aws_eip.nat.*.id, count.index)\r\n  subnet_id     = element(aws_subnet.public.*.id, count.index)\r\n  depends_on    = [aws_internet_gateway.main]\r\n\r\n  tags = {\r\n    Environment = var.environment\r\n    CreatedBy = \"terraform\" \r\n    Vpc = aws_vpc.main.id\r\n  }\r\n}\r\n \r\nresource \"aws_eip\" \"nat\" {\r\n  count = local.az_count\r\n  vpc = true\r\n\r\n  tags = {\r\n    CreatedBy = \"terraform\"\r\n    Vpc = aws_vpc.main.id\r\n  }\r\n}\r\n```\r\n\r\nCould be structured to use a single EIP and routing internally, if this makes sense.", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "I got the following setup to create the networking requirements for a Fargate setup: ```hcl resource \"aws_vpc\" \"main\" { cidr_block = var.cidr tags = { Environment = var.environment DO_NOT_DELETE = true CreatedBy = \"terraform\" } } resource \"aws_internet_gateway\" \"main\" { vpc_id = aws_vpc.main.id tags = { Environment = var.environment CreatedBy = \"terraform\" Vpc = aws_vpc.main.id } } data \"aws_availability_zones\" \"region_azs\" { state = \"available\" } locals { az_count = length(data.aws_availability_zones.region_azs.names) } resource \"aws_subnet\" \"private\" { vpc_id = aws_vpc.main.id cidr_block = cidrsubnet(aws_vpc.main.cidr_block, 4, count.index) availability_zone = data.aws_availability_zones.region_azs.names[count.index] count = local.az_count tags = { Name = \"public-subnet-${data.aws_availability_zones.region_azs.names[count.index]}\" AvailabilityZone = data.aws_availability_zones.region_azs.names[count.index] Environment = var.environment CreatedBy = \"terraform\" Vpc = aws_vpc.main.id Type = \"private\" DO_NOT_DELETE = true } } resource \"aws_subnet\" \"public\" { vpc_id = aws_vpc.main.id cidr_block = cidrsubnet(aws_vpc.main.cidr_block, 4, count.index + local.az_count ) availability_zone = data.aws_availability_zones.region_azs.names[count.index] count = local.az_count map_public_ip_on_launch = true tags = { Environment = var.environment CreatedBy = \"terraform\" Vpc = aws_vpc.main.id DO_NOT_DELETE = true Type = \"public\" } } resource \"aws_route_table\" \"public\" { vpc_id = aws_vpc.main.id tags = { Environment = var.environment CreatedBy = \"terraform\" Vpc = aws_vpc.main.id Type = \"public\" } } resource \"aws_route\" \"public\" { route_table_id = aws_route_table.public.id destination_cidr_block = \"0.0.0.0/0\" gateway_id = aws_internet_gateway.main.id } resource \"aws_route_table_association\" \"public\" { count = local.az_count subnet_id = element(aws_subnet.public.*.id, count.index) route_table_id = aws_route_table.public.id } resource \"aws_nat_gateway\" \"main\" { count = local.az_count allocation_id = element(aws_eip.nat.*.id, count.index) subnet_id = element(aws_subnet.public.*.id, count.index) depends_on = [aws_internet_gateway.main] tags = { Environment = var.environment CreatedBy = \"terraform\" Vpc = aws_vpc.main.id } } resource \"aws_eip\" \"nat\" { count = local.az_count vpc = true tags = { CreatedBy = \"terraform\" Vpc = aws_vpc.main.id } } resource \"aws_route_table\" \"private\" { count = local.az_count vpc_id = aws_vpc.main.id tags = { Environment = var.environment CreatedBy = \"terraform\" Type = \"private\" Vpc = aws_vpc.main.id } } resource \"aws_route\" \"private\" { count = local.az_count route_table_id = element(aws_route_table.private.*.id, count.index) destination_cidr_block = \"0.0.0.0/0\" nat_gateway_id = element(aws_nat_gateway.main.*.id, count.index) } resource \"aws_route_table_association\" \"private\" { count = local.az_count subnet_id = element(aws_subnet.private.*.id, count.index) route_table_id = element(aws_route_table.private.*.id, count.index) } resource \"aws_security_group\" \"alb\" { name = \"${var.resources_name_prefix}-alb-sg\" vpc_id = aws_vpc.main.id ingress { protocol = \"tcp\" from_port = 80 to_port = 80 cidr_blocks = [\"0.0.0.0/0\"] ipv6_cidr_blocks = [\"::/0\"] } ingress { protocol = \"tcp\" from_port = 443 to_port = 443 cidr_blocks = [\"0.0.0.0/0\"] ipv6_cidr_blocks = [\"::/0\"] } egress { protocol = \"-1\" from_port = 0 to_port = 0 cidr_blocks = [\"0.0.0.0/0\"] ipv6_cidr_blocks = [\"::/0\"] } tags = { Environment = var.environment CreatedBy = \"terraform\" Vpc = aws_vpc.main.id } } resource \"aws_security_group\" \"ecs_tasks\" { name = \"${var.resources_name_prefix}-ecs-sg\" vpc_id = aws_vpc.main.id ingress { protocol = \"tcp\" from_port = 3000 to_port = 3000 cidr_blocks = [\"0.0.0.0/0\"] ipv6_cidr_blocks = [\"::/0\"] } egress { protocol = \"-1\" from_port = 0 to_port = 0 cidr_blocks = [\"0.0.0.0/0\"] ipv6_cidr_blocks = [\"::/0\"] } tags = { Environment = var.environment CreatedBy = \"terraform\" Vpc = aws_vpc.main.id } } ``` ", "keywords": ["networking", "nat"]}, {"source": "Text", "text": "Error creating EIP: AddressLimitExceeded: The maximum number of addresses has been reached. status code: 400 ``` I'm wodering if the following part: ``` resource \"aws_nat_gateway\" \"main\" { count = local.az_count allocation_id = element(aws_eip.nat.*.id, count.index) subnet_id = element(aws_subnet.public.*.id, count.index) depends_on = [aws_internet_gateway.main] tags = { Environment = var.environment CreatedBy = \"terraform\" Vpc = aws_vpc.main.id } } resource \"aws_eip\" \"nat\" { count = local.az_count vpc = true tags = { CreatedBy = \"terraform\" Vpc = aws_vpc.main.id } ", "keywords": ["nat"]}]}], "answers": [{"Id": "71892786", "PostTypeId": "2", "ParentId": "71889783", "CreationDate": "2022-04-16T09:44:26.783", "Score": "2", "Body": "<p>I modified your code a bit, but it's a mess. For example all private subnets are called &quot;public&quot;. It creates two NATs now. Obviously if you have subnets in, lets say, 6 AZs, there will be some cross-AZ traffic to get to those NATs.</p>\n<p>Alternatively, simply don't create VPCs spanning so many AZs. Typically only two-three AZs are used for a VPC. Having more than that is not really needed.</p>\n<p>Finally, you can request AWS support to give your more EIPs, if you want to preserve your original setup.</p>\n<pre><code>resource &quot;aws_vpc&quot; &quot;main&quot; {\n  cidr_block = var.cidr\n  tags = {\n    Environment = var.environment\n    DO_NOT_DELETE = true\n    CreatedBy = &quot;terraform&quot;\n  }\n}\n \nresource &quot;aws_internet_gateway&quot; &quot;main&quot; {\n  vpc_id = aws_vpc.main.id\n  tags = {\n    Environment = var.environment\n    CreatedBy = &quot;terraform&quot;\n    Vpc = aws_vpc.main.id\n  }\n}\n\ndata &quot;aws_availability_zones&quot; &quot;region_azs&quot; {\n  state = &quot;available&quot;\n}\n\nlocals {\n  az_count = length(data.aws_availability_zones.region_azs.names)\n}\n\nresource &quot;aws_subnet&quot; &quot;private&quot; {\n  vpc_id            = aws_vpc.main.id\n  cidr_block        = cidrsubnet(aws_vpc.main.cidr_block, 4, count.index)\n  availability_zone = data.aws_availability_zones.region_azs.names[count.index]\n  count             = local.az_count\n\n  tags = {\n    Name = &quot;private-subnet-${data.aws_availability_zones.region_azs.names[count.index]}&quot;\n    AvailabilityZone = data.aws_availability_zones.region_azs.names[count.index]\n    Environment = var.environment\n    CreatedBy = &quot;terraform&quot;\n    Vpc = aws_vpc.main.id\n    Type = &quot;private&quot;\n    DO_NOT_DELETE = true\n  }\n}\n \nresource &quot;aws_subnet&quot; &quot;public&quot; {\n  vpc_id                  = aws_vpc.main.id\n  cidr_block              = cidrsubnet(aws_vpc.main.cidr_block, 4, count.index + local.az_count )\n  availability_zone = data.aws_availability_zones.region_azs.names[count.index]\n  count             = local.az_count\n  map_public_ip_on_launch = true\n\n  tags = {\n    Name = &quot;public-subnet-${data.aws_availability_zones.region_azs.names[count.index]}&quot;  \n    Environment = var.environment\n    CreatedBy = &quot;terraform&quot;\n    Vpc = aws_vpc.main.id\n    DO_NOT_DELETE = true\n    Type = &quot;public&quot;\n  }\n}\n\nresource &quot;aws_route_table&quot; &quot;public&quot; {\n  vpc_id = aws_vpc.main.id\n  tags = {\n    Environment = var.environment\n    CreatedBy = &quot;terraform&quot;\n    Vpc = aws_vpc.main.id\n    Type = &quot;public&quot;\n  }\n}\n \nresource &quot;aws_route&quot; &quot;public&quot; {\n  route_table_id         = aws_route_table.public.id\n  destination_cidr_block = &quot;0.0.0.0/0&quot;\n  gateway_id             = aws_internet_gateway.main.id\n}\n \nresource &quot;aws_route_table_association&quot; &quot;public&quot; {\n  count          = local.az_count\n  subnet_id      = element(aws_subnet.public.*.id, count.index)\n  route_table_id = aws_route_table.public.id\n}\n\nresource &quot;aws_nat_gateway&quot; &quot;main&quot; {\n  count         = 2\n  allocation_id = element(aws_eip.nat.*.id, count.index)\n  subnet_id     = element(aws_subnet.public.*.id, count.index)\n  depends_on    = [aws_internet_gateway.main]\n\n  tags = {\n    Environment = var.environment\n    CreatedBy = &quot;terraform&quot; \n    Vpc = aws_vpc.main.id\n  }\n}\n \nresource &quot;aws_eip&quot; &quot;nat&quot; {\n  count = 2\n  vpc = true\n\n  tags = {\n    CreatedBy = &quot;terraform&quot;\n    Vpc = aws_vpc.main.id\n  }\n}\n\nresource &quot;aws_route_table&quot; &quot;private&quot; {\n  count  = local.az_count\n  vpc_id = aws_vpc.main.id\n\n  tags = {\n    Environment = var.environment\n    CreatedBy = &quot;terraform&quot;\n    Type = &quot;private&quot;\n    Vpc = aws_vpc.main.id\n  }\n}\n \nresource &quot;aws_route&quot; &quot;private&quot; {\n  count                  = local.az_count\n  route_table_id         = element(aws_route_table.private.*.id, count.index)\n  destination_cidr_block = &quot;0.0.0.0/0&quot;\n  nat_gateway_id         = element(aws_nat_gateway.main.*.id, count.index)\n}\n \nresource &quot;aws_route_table_association&quot; &quot;private&quot; {\n  count          = local.az_count\n  subnet_id      = element(aws_subnet.private.*.id, count.index)\n  route_table_id = element(aws_route_table.private.*.id, count.index)\n}\n\nresource &quot;aws_security_group&quot; &quot;alb&quot; {\n  name   = &quot;${var.resources_name_prefix}-alb-sg&quot;\n  vpc_id = aws_vpc.main.id\n \n  ingress {\n   protocol         = &quot;tcp&quot;\n   from_port        = 80\n   to_port          = 80\n   cidr_blocks      = [&quot;0.0.0.0/0&quot;]\n   ipv6_cidr_blocks = [&quot;::/0&quot;]\n  }\n \n  ingress {\n   protocol         = &quot;tcp&quot;\n   from_port        = 443\n   to_port          = 443\n   cidr_blocks      = [&quot;0.0.0.0/0&quot;]\n   ipv6_cidr_blocks = [&quot;::/0&quot;]\n  }\n \n  egress {\n   protocol         = &quot;-1&quot;\n   from_port        = 0\n   to_port          = 0\n   cidr_blocks      = [&quot;0.0.0.0/0&quot;]\n   ipv6_cidr_blocks = [&quot;::/0&quot;]\n  }\n\n  tags = {\n    Environment = var.environment\n    CreatedBy = &quot;terraform&quot;\n    Vpc = aws_vpc.main.id\n  }\n}\n\nresource &quot;aws_security_group&quot; &quot;ecs_tasks&quot; {\n  name   = &quot;${var.resources_name_prefix}-ecs-sg&quot;\n  vpc_id = aws_vpc.main.id\n \n  ingress {\n   protocol         = &quot;tcp&quot;\n   from_port        = 3000\n   to_port          = 3000\n   cidr_blocks      = [&quot;0.0.0.0/0&quot;]\n   ipv6_cidr_blocks = [&quot;::/0&quot;]\n  }\n\n  egress {\n   protocol         = &quot;-1&quot;\n   from_port        = 0\n   to_port          = 0\n   cidr_blocks      = [&quot;0.0.0.0/0&quot;]\n   ipv6_cidr_blocks = [&quot;::/0&quot;]\n  }\n\n  tags = {\n    Environment = var.environment\n    CreatedBy = &quot;terraform&quot;\n    Vpc = aws_vpc.main.id\n  }\n}\n</code></pre>\n", "OwnerUserId": "248823", "LastEditorUserId": "7487335", "LastEditDate": "2022-12-05T18:46:32.520", "LastActivityDate": "2022-12-05T18:46:32.520", "CommentCount": "7", "ContentLicense": "CC BY-SA 4.0", "comments": [{"Id": "127040509", "PostId": "71892786", "Score": "1", "Text": "Thanks! What do you mean by \"For example all private subnets are called \"public\"", "CreationDate": "2022-04-16T09:48:46.530", "UserId": "742560", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "127040521", "PostId": "71892786", "Score": "0", "Text": "@diegoaguilar Check the `Name` of your `resource \"aws_subnet\" \"private`. Public subnets are not named at all. I fixed that in my version as well.", "CreationDate": "2022-04-16T09:49:37.647", "UserId": "248823", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "127040537", "PostId": "71892786", "Score": "0", "Text": "Oh right. Bad tagging", "CreationDate": "2022-04-16T09:50:48.200", "UserId": "742560", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "127040563", "PostId": "71892786", "Score": "0", "Text": "Could you also ELI5 the \"Obviously if you have subnets in, lets say, 6 AZs, there will be some cross-AZ traffic to get to those NATs.\" part?", "CreationDate": "2022-04-16T09:53:26.387", "UserId": "742560", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "127040616", "PostId": "71892786", "Score": "0", "Text": "@diegoaguilar I think you can read up up on what [availability zones](https://aws.amazon.com/about-aws/global-infrastructure/regions_az/) are. So traffic from subnets have to go across AZs to reach NATs, which may add sight delay and possibily cross-zone traffic cost.", "CreationDate": "2022-04-16T09:57:22.643", "UserId": "248823", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "So traffic from subnets have to go across AZs to reach NATs, which may add sight delay and possibily cross-zone traffic cost.", "keywords": ["cost"]}]}, {"Id": "127040636", "PostId": "71892786", "Score": "0", "Text": "So even before reading ... more than 3 might be too much in every aspects....", "CreationDate": "2022-04-16T09:59:28.900", "UserId": "742560", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "127041536", "PostId": "71892786", "Score": "0", "Text": "just one question, if I tried the approach using a couple NATS only,\n\nWould \u00b4subnet_id     = element(aws_subnet.public.*.id, count.index)\u00b4 be ok?\n\nWouldn't that mean that some subnets would be getting a NAT?", "CreationDate": "2022-04-16T11:29:12.027", "UserId": "742560", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "Wouldn't that mean that some subnets would be getting a NAT?", "keywords": ["nat"]}]}], "history": [{"Id": "268280401", "PostHistoryTypeId": "2", "PostId": "71892786", "RevisionGUID": "1e6c5835-cc49-42a6-8d00-05126da82a1b", "CreationDate": "2022-04-16T09:44:26.783", "UserId": "248823", "Text": "I modified your code a bit, but its a mess. For example all private subnets are called \"public\". It creates two NATs now. Obviously if you have subnets in, lets say, 6 AZs, there will be some cross-AZ traffic to get to those NATs. \r\n\r\nAlternatively, simply don't create VPCs spanning so many AZs. Typically only two-three AZs are used for a VPC. Having more than then, is not really needed. \r\n\r\nFinally, you can request AWS support to give your more EIPs, if you want to preserve your original setup.\r\n\r\n```\r\nresource \"aws_vpc\" \"main\" {\r\n  cidr_block = var.cidr\r\n  tags = {\r\n    Environment = var.environment\r\n    DO_NOT_DELETE = true\r\n    CreatedBy = \"terraform\"\r\n  }\r\n}\r\n \r\nresource \"aws_internet_gateway\" \"main\" {\r\n  vpc_id = aws_vpc.main.id\r\n  tags = {\r\n    Environment = var.environment\r\n    CreatedBy = \"terraform\"\r\n    Vpc = aws_vpc.main.id\r\n  }\r\n}\r\n\r\ndata \"aws_availability_zones\" \"region_azs\" {\r\n  state = \"available\"\r\n}\r\n\r\nlocals {\r\n  az_count = length(data.aws_availability_zones.region_azs.names)\r\n}\r\n\r\nresource \"aws_subnet\" \"private\" {\r\n  vpc_id            = aws_vpc.main.id\r\n  cidr_block        = cidrsubnet(aws_vpc.main.cidr_block, 4, count.index)\r\n  availability_zone = data.aws_availability_zones.region_azs.names[count.index]\r\n  count             = local.az_count\r\n\r\n  tags = {\r\n    Name = \"private-subnet-${data.aws_availability_zones.region_azs.names[count.index]}\"\r\n    AvailabilityZone = data.aws_availability_zones.region_azs.names[count.index]\r\n    Environment = var.environment\r\n    CreatedBy = \"terraform\"\r\n    Vpc = aws_vpc.main.id\r\n    Type = \"private\"\r\n    DO_NOT_DELETE = true\r\n  }\r\n}\r\n \r\nresource \"aws_subnet\" \"public\" {\r\n  vpc_id                  = aws_vpc.main.id\r\n  cidr_block              = cidrsubnet(aws_vpc.main.cidr_block, 4, count.index + local.az_count )\r\n  availability_zone = data.aws_availability_zones.region_azs.names[count.index]\r\n  count             = local.az_count\r\n  map_public_ip_on_launch = true\r\n\r\n  tags = {\r\n    Name = \"public-subnet-${data.aws_availability_zones.region_azs.names[count.index]}\"  \r\n    Environment = var.environment\r\n    CreatedBy = \"terraform\"\r\n    Vpc = aws_vpc.main.id\r\n    DO_NOT_DELETE = true\r\n    Type = \"public\"\r\n  }\r\n}\r\n\r\nresource \"aws_route_table\" \"public\" {\r\n  vpc_id = aws_vpc.main.id\r\n  tags = {\r\n    Environment = var.environment\r\n    CreatedBy = \"terraform\"\r\n    Vpc = aws_vpc.main.id\r\n    Type = \"public\"\r\n  }\r\n}\r\n \r\nresource \"aws_route\" \"public\" {\r\n  route_table_id         = aws_route_table.public.id\r\n  destination_cidr_block = \"0.0.0.0/0\"\r\n  gateway_id             = aws_internet_gateway.main.id\r\n}\r\n \r\nresource \"aws_route_table_association\" \"public\" {\r\n  count          = local.az_count\r\n  subnet_id      = element(aws_subnet.public.*.id, count.index)\r\n  route_table_id = aws_route_table.public.id\r\n}\r\n\r\nresource \"aws_nat_gateway\" \"main\" {\r\n  count         = 2\r\n  allocation_id = element(aws_eip.nat.*.id, count.index)\r\n  subnet_id     = element(aws_subnet.public.*.id, count.index)\r\n  depends_on    = [aws_internet_gateway.main]\r\n\r\n  tags = {\r\n    Environment = var.environment\r\n    CreatedBy = \"terraform\" \r\n    Vpc = aws_vpc.main.id\r\n  }\r\n}\r\n \r\nresource \"aws_eip\" \"nat\" {\r\n  count = 2\r\n  vpc = true\r\n\r\n  tags = {\r\n    CreatedBy = \"terraform\"\r\n    Vpc = aws_vpc.main.id\r\n  }\r\n}\r\n\r\nresource \"aws_route_table\" \"private\" {\r\n  count  = local.az_count\r\n  vpc_id = aws_vpc.main.id\r\n\r\n  tags = {\r\n    Environment = var.environment\r\n    CreatedBy = \"terraform\"\r\n    Type = \"private\"\r\n    Vpc = aws_vpc.main.id\r\n  }\r\n}\r\n \r\nresource \"aws_route\" \"private\" {\r\n  count                  = local.az_count\r\n  route_table_id         = element(aws_route_table.private.*.id, count.index)\r\n  destination_cidr_block = \"0.0.0.0/0\"\r\n  nat_gateway_id         = element(aws_nat_gateway.main.*.id, count.index)\r\n}\r\n \r\nresource \"aws_route_table_association\" \"private\" {\r\n  count          = local.az_count\r\n  subnet_id      = element(aws_subnet.private.*.id, count.index)\r\n  route_table_id = element(aws_route_table.private.*.id, count.index)\r\n}\r\n\r\nresource \"aws_security_group\" \"alb\" {\r\n  name   = \"${var.resources_name_prefix}-alb-sg\"\r\n  vpc_id = aws_vpc.main.id\r\n \r\n  ingress {\r\n   protocol         = \"tcp\"\r\n   from_port        = 80\r\n   to_port          = 80\r\n   cidr_blocks      = [\"0.0.0.0/0\"]\r\n   ipv6_cidr_blocks = [\"::/0\"]\r\n  }\r\n \r\n  ingress {\r\n   protocol         = \"tcp\"\r\n   from_port        = 443\r\n   to_port          = 443\r\n   cidr_blocks      = [\"0.0.0.0/0\"]\r\n   ipv6_cidr_blocks = [\"::/0\"]\r\n  }\r\n \r\n  egress {\r\n   protocol         = \"-1\"\r\n   from_port        = 0\r\n   to_port          = 0\r\n   cidr_blocks      = [\"0.0.0.0/0\"]\r\n   ipv6_cidr_blocks = [\"::/0\"]\r\n  }\r\n\r\n  tags = {\r\n    Environment = var.environment\r\n    CreatedBy = \"terraform\"\r\n    Vpc = aws_vpc.main.id\r\n  }\r\n}\r\n\r\nresource \"aws_security_group\" \"ecs_tasks\" {\r\n  name   = \"${var.resources_name_prefix}-ecs-sg\"\r\n  vpc_id = aws_vpc.main.id\r\n \r\n  ingress {\r\n   protocol         = \"tcp\"\r\n   from_port        = 3000\r\n   to_port          = 3000\r\n   cidr_blocks      = [\"0.0.0.0/0\"]\r\n   ipv6_cidr_blocks = [\"::/0\"]\r\n  }\r\n\r\n  egress {\r\n   protocol         = \"-1\"\r\n   from_port        = 0\r\n   to_port          = 0\r\n   cidr_blocks      = [\"0.0.0.0/0\"]\r\n   ipv6_cidr_blocks = [\"::/0\"]\r\n  }\r\n\r\n  tags = {\r\n    Environment = var.environment\r\n    CreatedBy = \"terraform\"\r\n    Vpc = aws_vpc.main.id\r\n  }\r\n}\r\n```", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "``` resource \"aws_vpc\" \"main\" { cidr_block = var.cidr tags = { Environment = var.environment DO_NOT_DELETE = true CreatedBy = \"terraform\" } } resource \"aws_internet_gateway\" \"main\" { vpc_id = aws_vpc.main.id tags = { Environment = var.environment CreatedBy = \"terraform\" Vpc = aws_vpc.main.id } } data \"aws_availability_zones\" \"region_azs\" { state = \"available\" } locals { az_count = length(data.aws_availability_zones.region_azs.names) } resource \"aws_subnet\" \"private\" { vpc_id = aws_vpc.main.id cidr_block = cidrsubnet(aws_vpc.main.cidr_block, 4, count.index) availability_zone = data.aws_availability_zones.region_azs.names[count.index] count = local.az_count tags = { Name = \"private-subnet-${data.aws_availability_zones.region_azs.names[count.index]}\" AvailabilityZone = data.aws_availability_zones.region_azs.names[count.index] Environment = var.environment CreatedBy = \"terraform\" Vpc = aws_vpc.main.id Type = \"private\" DO_NOT_DELETE = true } } resource \"aws_subnet\" \"public\" { vpc_id = aws_vpc.main.id cidr_block = cidrsubnet(aws_vpc.main.cidr_block, 4, count.index + local.az_count ) availability_zone = data.aws_availability_zones.region_azs.names[count.index] count = local.az_count map_public_ip_on_launch = true tags = { Name = \"public-subnet-${data.aws_availability_zones.region_azs.names[count.index]}\" Environment = var.environment CreatedBy = \"terraform\" Vpc = aws_vpc.main.id DO_NOT_DELETE = true Type = \"public\" } } resource \"aws_route_table\" \"public\" { vpc_id = aws_vpc.main.id tags = { Environment = var.environment CreatedBy = \"terraform\" Vpc = aws_vpc.main.id Type = \"public\" } } resource \"aws_route\" \"public\" { route_table_id = aws_route_table.public.id destination_cidr_block = \"0.0.0.0/0\" gateway_id = aws_internet_gateway.main.id } resource \"aws_route_table_association\" \"public\" { count = local.az_count subnet_id = element(aws_subnet.public.*.id, count.index) route_table_id = aws_route_table.public.id } resource \"aws_nat_gateway\" \"main\" { count = 2 allocation_id = element(aws_eip.nat.*.id, count.index) subnet_id = element(aws_subnet.public.*.id, count.index) depends_on = [aws_internet_gateway.main] tags = { Environment = var.environment CreatedBy = \"terraform\" Vpc = aws_vpc.main.id } } resource \"aws_eip\" \"nat\" { count = 2 vpc = true tags = { CreatedBy = \"terraform\" Vpc = aws_vpc.main.id } } resource \"aws_route_table\" \"private\" { count = local.az_count vpc_id = aws_vpc.main.id tags = { Environment = var.environment CreatedBy = \"terraform\" Type = \"private\" Vpc = aws_vpc.main.id } } resource \"aws_route\" \"private\" { count = local.az_count route_table_id = element(aws_route_table.private.*.id, count.index) destination_cidr_block = \"0.0.0.0/0\" nat_gateway_id = element(aws_nat_gateway.main.*.id, count.index) } resource \"aws_route_table_association\" \"private\" { count = local.az_count subnet_id = element(aws_subnet.private.*.id, count.index) route_table_id = element(aws_route_table.private.*.id, count.index) } resource \"aws_security_group\" \"alb\" { name = \"${var.resources_name_prefix}-alb-sg\" vpc_id = aws_vpc.main.id ingress { protocol = \"tcp\" from_port = 80 to_port = 80 cidr_blocks = [\"0.0.0.0/0\"] ipv6_cidr_blocks = [\"::/0\"] } ingress { protocol = \"tcp\" from_port = 443 to_port = 443 cidr_blocks = [\"0.0.0.0/0\"] ipv6_cidr_blocks = [\"::/0\"] } egress { protocol = \"-1\" from_port = 0 to_port = 0 cidr_blocks = [\"0.0.0.0/0\"] ipv6_cidr_blocks = [\"::/0\"] } tags = { Environment = var.environment CreatedBy = \"terraform\" Vpc = aws_vpc.main.id } } resource \"aws_security_group\" \"ecs_tasks\" { name = \"${var.resources_name_prefix}-ecs-sg\" vpc_id = aws_vpc.main.id ingress { protocol = \"tcp\" from_port = 3000 to_port = 3000 cidr_blocks = [\"0.0.0.0/0\"] ipv6_cidr_blocks = [\"::/0\"] ", "keywords": ["nat"]}]}, {"Id": "283668578", "PostHistoryTypeId": "5", "PostId": "71892786", "RevisionGUID": "8a0003ff-75bc-4e67-98f4-93698a0b0b4d", "CreationDate": "2022-12-05T18:46:32.520", "UserId": "7487335", "Comment": "Fix typos", "Text": "I modified your code a bit, but it's a mess. For example all private subnets are called \"public\". It creates two NATs now. Obviously if you have subnets in, lets say, 6 AZs, there will be some cross-AZ traffic to get to those NATs. \r\n\r\nAlternatively, simply don't create VPCs spanning so many AZs. Typically only two-three AZs are used for a VPC. Having more than that is not really needed. \r\n\r\nFinally, you can request AWS support to give your more EIPs, if you want to preserve your original setup.\r\n\r\n```\r\nresource \"aws_vpc\" \"main\" {\r\n  cidr_block = var.cidr\r\n  tags = {\r\n    Environment = var.environment\r\n    DO_NOT_DELETE = true\r\n    CreatedBy = \"terraform\"\r\n  }\r\n}\r\n \r\nresource \"aws_internet_gateway\" \"main\" {\r\n  vpc_id = aws_vpc.main.id\r\n  tags = {\r\n    Environment = var.environment\r\n    CreatedBy = \"terraform\"\r\n    Vpc = aws_vpc.main.id\r\n  }\r\n}\r\n\r\ndata \"aws_availability_zones\" \"region_azs\" {\r\n  state = \"available\"\r\n}\r\n\r\nlocals {\r\n  az_count = length(data.aws_availability_zones.region_azs.names)\r\n}\r\n\r\nresource \"aws_subnet\" \"private\" {\r\n  vpc_id            = aws_vpc.main.id\r\n  cidr_block        = cidrsubnet(aws_vpc.main.cidr_block, 4, count.index)\r\n  availability_zone = data.aws_availability_zones.region_azs.names[count.index]\r\n  count             = local.az_count\r\n\r\n  tags = {\r\n    Name = \"private-subnet-${data.aws_availability_zones.region_azs.names[count.index]}\"\r\n    AvailabilityZone = data.aws_availability_zones.region_azs.names[count.index]\r\n    Environment = var.environment\r\n    CreatedBy = \"terraform\"\r\n    Vpc = aws_vpc.main.id\r\n    Type = \"private\"\r\n    DO_NOT_DELETE = true\r\n  }\r\n}\r\n \r\nresource \"aws_subnet\" \"public\" {\r\n  vpc_id                  = aws_vpc.main.id\r\n  cidr_block              = cidrsubnet(aws_vpc.main.cidr_block, 4, count.index + local.az_count )\r\n  availability_zone = data.aws_availability_zones.region_azs.names[count.index]\r\n  count             = local.az_count\r\n  map_public_ip_on_launch = true\r\n\r\n  tags = {\r\n    Name = \"public-subnet-${data.aws_availability_zones.region_azs.names[count.index]}\"  \r\n    Environment = var.environment\r\n    CreatedBy = \"terraform\"\r\n    Vpc = aws_vpc.main.id\r\n    DO_NOT_DELETE = true\r\n    Type = \"public\"\r\n  }\r\n}\r\n\r\nresource \"aws_route_table\" \"public\" {\r\n  vpc_id = aws_vpc.main.id\r\n  tags = {\r\n    Environment = var.environment\r\n    CreatedBy = \"terraform\"\r\n    Vpc = aws_vpc.main.id\r\n    Type = \"public\"\r\n  }\r\n}\r\n \r\nresource \"aws_route\" \"public\" {\r\n  route_table_id         = aws_route_table.public.id\r\n  destination_cidr_block = \"0.0.0.0/0\"\r\n  gateway_id             = aws_internet_gateway.main.id\r\n}\r\n \r\nresource \"aws_route_table_association\" \"public\" {\r\n  count          = local.az_count\r\n  subnet_id      = element(aws_subnet.public.*.id, count.index)\r\n  route_table_id = aws_route_table.public.id\r\n}\r\n\r\nresource \"aws_nat_gateway\" \"main\" {\r\n  count         = 2\r\n  allocation_id = element(aws_eip.nat.*.id, count.index)\r\n  subnet_id     = element(aws_subnet.public.*.id, count.index)\r\n  depends_on    = [aws_internet_gateway.main]\r\n\r\n  tags = {\r\n    Environment = var.environment\r\n    CreatedBy = \"terraform\" \r\n    Vpc = aws_vpc.main.id\r\n  }\r\n}\r\n \r\nresource \"aws_eip\" \"nat\" {\r\n  count = 2\r\n  vpc = true\r\n\r\n  tags = {\r\n    CreatedBy = \"terraform\"\r\n    Vpc = aws_vpc.main.id\r\n  }\r\n}\r\n\r\nresource \"aws_route_table\" \"private\" {\r\n  count  = local.az_count\r\n  vpc_id = aws_vpc.main.id\r\n\r\n  tags = {\r\n    Environment = var.environment\r\n    CreatedBy = \"terraform\"\r\n    Type = \"private\"\r\n    Vpc = aws_vpc.main.id\r\n  }\r\n}\r\n \r\nresource \"aws_route\" \"private\" {\r\n  count                  = local.az_count\r\n  route_table_id         = element(aws_route_table.private.*.id, count.index)\r\n  destination_cidr_block = \"0.0.0.0/0\"\r\n  nat_gateway_id         = element(aws_nat_gateway.main.*.id, count.index)\r\n}\r\n \r\nresource \"aws_route_table_association\" \"private\" {\r\n  count          = local.az_count\r\n  subnet_id      = element(aws_subnet.private.*.id, count.index)\r\n  route_table_id = element(aws_route_table.private.*.id, count.index)\r\n}\r\n\r\nresource \"aws_security_group\" \"alb\" {\r\n  name   = \"${var.resources_name_prefix}-alb-sg\"\r\n  vpc_id = aws_vpc.main.id\r\n \r\n  ingress {\r\n   protocol         = \"tcp\"\r\n   from_port        = 80\r\n   to_port          = 80\r\n   cidr_blocks      = [\"0.0.0.0/0\"]\r\n   ipv6_cidr_blocks = [\"::/0\"]\r\n  }\r\n \r\n  ingress {\r\n   protocol         = \"tcp\"\r\n   from_port        = 443\r\n   to_port          = 443\r\n   cidr_blocks      = [\"0.0.0.0/0\"]\r\n   ipv6_cidr_blocks = [\"::/0\"]\r\n  }\r\n \r\n  egress {\r\n   protocol         = \"-1\"\r\n   from_port        = 0\r\n   to_port          = 0\r\n   cidr_blocks      = [\"0.0.0.0/0\"]\r\n   ipv6_cidr_blocks = [\"::/0\"]\r\n  }\r\n\r\n  tags = {\r\n    Environment = var.environment\r\n    CreatedBy = \"terraform\"\r\n    Vpc = aws_vpc.main.id\r\n  }\r\n}\r\n\r\nresource \"aws_security_group\" \"ecs_tasks\" {\r\n  name   = \"${var.resources_name_prefix}-ecs-sg\"\r\n  vpc_id = aws_vpc.main.id\r\n \r\n  ingress {\r\n   protocol         = \"tcp\"\r\n   from_port        = 3000\r\n   to_port          = 3000\r\n   cidr_blocks      = [\"0.0.0.0/0\"]\r\n   ipv6_cidr_blocks = [\"::/0\"]\r\n  }\r\n\r\n  egress {\r\n   protocol         = \"-1\"\r\n   from_port        = 0\r\n   to_port          = 0\r\n   cidr_blocks      = [\"0.0.0.0/0\"]\r\n   ipv6_cidr_blocks = [\"::/0\"]\r\n  }\r\n\r\n  tags = {\r\n    Environment = var.environment\r\n    CreatedBy = \"terraform\"\r\n    Vpc = aws_vpc.main.id\r\n  }\r\n}\r\n```", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "``` resource \"aws_vpc\" \"main\" { cidr_block = var.cidr tags = { Environment = var.environment DO_NOT_DELETE = true CreatedBy = \"terraform\" } } resource \"aws_internet_gateway\" \"main\" { vpc_id = aws_vpc.main.id tags = { Environment = var.environment CreatedBy = \"terraform\" Vpc = aws_vpc.main.id } } data \"aws_availability_zones\" \"region_azs\" { state = \"available\" } locals { az_count = length(data.aws_availability_zones.region_azs.names) } resource \"aws_subnet\" \"private\" { vpc_id = aws_vpc.main.id cidr_block = cidrsubnet(aws_vpc.main.cidr_block, 4, count.index) availability_zone = data.aws_availability_zones.region_azs.names[count.index] count = local.az_count tags = { Name = \"private-subnet-${data.aws_availability_zones.region_azs.names[count.index]}\" AvailabilityZone = data.aws_availability_zones.region_azs.names[count.index] Environment = var.environment CreatedBy = \"terraform\" Vpc = aws_vpc.main.id Type = \"private\" DO_NOT_DELETE = true } } resource \"aws_subnet\" \"public\" { vpc_id = aws_vpc.main.id cidr_block = cidrsubnet(aws_vpc.main.cidr_block, 4, count.index + local.az_count ) availability_zone = data.aws_availability_zones.region_azs.names[count.index] count = local.az_count map_public_ip_on_launch = true tags = { Name = \"public-subnet-${data.aws_availability_zones.region_azs.names[count.index]}\" Environment = var.environment CreatedBy = \"terraform\" Vpc = aws_vpc.main.id DO_NOT_DELETE = true Type = \"public\" } } resource \"aws_route_table\" \"public\" { vpc_id = aws_vpc.main.id tags = { Environment = var.environment CreatedBy = \"terraform\" Vpc = aws_vpc.main.id Type = \"public\" } } resource \"aws_route\" \"public\" { route_table_id = aws_route_table.public.id destination_cidr_block = \"0.0.0.0/0\" gateway_id = aws_internet_gateway.main.id } resource \"aws_route_table_association\" \"public\" { count = local.az_count subnet_id = element(aws_subnet.public.*.id, count.index) route_table_id = aws_route_table.public.id } resource \"aws_nat_gateway\" \"main\" { count = 2 allocation_id = element(aws_eip.nat.*.id, count.index) subnet_id = element(aws_subnet.public.*.id, count.index) depends_on = [aws_internet_gateway.main] tags = { Environment = var.environment CreatedBy = \"terraform\" Vpc = aws_vpc.main.id } } resource \"aws_eip\" \"nat\" { count = 2 vpc = true tags = { CreatedBy = \"terraform\" Vpc = aws_vpc.main.id } } resource \"aws_route_table\" \"private\" { count = local.az_count vpc_id = aws_vpc.main.id tags = { Environment = var.environment CreatedBy = \"terraform\" Type = \"private\" Vpc = aws_vpc.main.id } } resource \"aws_route\" \"private\" { count = local.az_count route_table_id = element(aws_route_table.private.*.id, count.index) destination_cidr_block = \"0.0.0.0/0\" nat_gateway_id = element(aws_nat_gateway.main.*.id, count.index) } resource \"aws_route_table_association\" \"private\" { count = local.az_count subnet_id = element(aws_subnet.private.*.id, count.index) route_table_id = element(aws_route_table.private.*.id, count.index) } resource \"aws_security_group\" \"alb\" { name = \"${var.resources_name_prefix}-alb-sg\" vpc_id = aws_vpc.main.id ingress { protocol = \"tcp\" from_port = 80 to_port = 80 cidr_blocks = [\"0.0.0.0/0\"] ipv6_cidr_blocks = [\"::/0\"] } ingress { protocol = \"tcp\" from_port = 443 to_port = 443 cidr_blocks = [\"0.0.0.0/0\"] ipv6_cidr_blocks = [\"::/0\"] } egress { protocol = \"-1\" from_port = 0 to_port = 0 cidr_blocks = [\"0.0.0.0/0\"] ipv6_cidr_blocks = [\"::/0\"] } tags = { Environment = var.environment CreatedBy = \"terraform\" Vpc = aws_vpc.main.id } } resource \"aws_security_group\" \"ecs_tasks\" { name = \"${var.resources_name_prefix}-ecs-sg\" vpc_id = aws_vpc.main.id ingress { protocol = \"tcp\" from_port = 3000 to_port = 3000 cidr_blocks = [\"0.0.0.0/0\"] ipv6_cidr_blocks = [\"::/0\"] ", "keywords": ["nat"]}]}], "filtered-sentences": []}], "contains-topic": true, "filtered-sentences": [{"source": "Body", "text": "I got the following setup to create the networking requirements for a Fargate setup: ", "keywords": ["networking"]}]}