{"Id": "58275233", "PostTypeId": "1", "AcceptedAnswerId": "58277124", "CreationDate": "2019-10-07T18:30:00.857", "Score": "38", "ViewCount": "97942", "Body": "<p>I'm new at terraform and I created a custom azure policies on module structure.\neach policy represents a custom module. \nOne of the modules that I have created is enabling diagnostics logs for any new azure resource created. \nbut, I need a storage account for that. (before enabling the diagnostics settings how can I implement <strong>\"depends_on\"? or any other methods?</strong>\nI want to create first the storage account and then the module of diagnostics settings.\non the <code>main.tf</code> (where calling all the other modules) or inside the resource (module)? </p>\n\n<p>Thanks for the help!! :) </p>\n\n<p><strong>this below code represents the main.tf file:</strong></p>\n\n<pre><code>//calling the create storage account name\n\nmodule \"createstorageaccount\" {\n\nsource = \"./modules/module_create_storage_account\"\n    depends_on = [\n    \"module_enable_diagnostics_logs\"\n  ]\n\n}\n</code></pre>\n\n<p><strong>this one represents the create storage account module</strong> </p>\n\n<pre><code>resource \"azurerm_resource_group\" \"management\" {\n\n\n  name     = \"management-rg\"\n  location = \"West Europe\"\n}\n\nresource \"azurerm_storage_account\" \"test\" {\n  name                     = \"diagnostics${azurerm_resource_group.management.name}\"\n  resource_group_name      = \"${azurerm_resource_group.management.name}\"\n  location                 = \"${azurerm_resource_group.management.location}\"\n  account_tier             = \"Standard\"\n  account_replication_type = \"LRS\"\n\n  tags = {\n    environment = \"diagnostics\"\n  }\n}\n\n    depends_on = [\n    \"module_enable_diagnostics_logs\"\n  ]\n\n</code></pre>\n", "OwnerUserId": "9734720", "LastEditorUserId": "5372462", "LastEditDate": "2020-08-05T08:23:06.730", "LastActivityDate": "2022-09-07T21:16:55.920", "Title": "Terraform depends_on with modules", "Tags": "<azure><terraform><terraform-provider-azure>", "AnswerCount": "3", "CommentCount": "3", "FavoriteCount": "0", "ContentLicense": "CC BY-SA 4.0", "comments": [{"Id": "102917071", "PostId": "58275233", "Score": "0", "Text": "As far as I know, the depends_on works with resources, not modules", "CreationDate": "2019-10-07T18:33:25.463", "UserId": "1600654", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "108540555", "PostId": "58275233", "Score": "0", "Text": "see https://medium.com/mineiros/the-ultimate-guide-on-how-to-write-terraform-modules-part-1-81f86d31f024 on how to implement a more generic module_depends_on ..", "CreationDate": "2020-04-22T00:11:28.677", "UserId": "2157547", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "112993208", "PostId": "58275233", "Score": "1", "Text": "Since [0.13](https://github.com/hashicorp/terraform/blob/v0.13/CHANGELOG.md) it's now possible to have [`depend_on` on modules](https://www.terraform.io/docs/configuration/modules.html#other-meta-arguments)", "CreationDate": "2020-09-15T09:03:13.107", "UserId": "672780", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "Since [0.13](https://github.com/hashicorp/terraform/blob/v0.13/CHANGELOG.md) it's now possible to have [`depend_on` on modules](https://www.terraform.io/docs/configuration/modules.html#other-meta-arguments)", "keywords": ["change"]}]}], "history": [{"Id": "206768147", "PostHistoryTypeId": "2", "PostId": "58275233", "RevisionGUID": "64e6e327-83f9-4f60-9bce-4b9d01c0610d", "CreationDate": "2019-10-07T18:30:00.857", "UserId": "9734720", "Text": "I'm new at terraform and I created a custom azure policies on module structure.\r\neach policy represents a custom module. \r\nOne of the modules that I have created is enabling diagnostics logs for any new azure resource created. \r\nbut, I need a storage account for that. (before enabling the diagnostics settings how can I implement **\"depends_on\"? or any other methods?**\r\nI want to create first the storage account and then the module of diagnostics settings.\r\non the ```main.tf``` (where calling all the other modules) or inside the resource (module)? \r\n\r\nThanks for the help!! :) \r\n\r\n\r\n**this below code represents the main.tf file:**\r\n```\r\n//calling the create storage account name\r\n\r\nmodule \"createstorageaccount\" {\r\n\r\nsource = \"./modules/module_create_storage_account\"\r\n    depends_on = [\r\n    \"module_enable_diagnostics_logs\"\r\n  ]\r\n\r\n}\r\n```\r\n\r\n**this one represents the create storage account module** \r\n\r\n```\r\nresource \"azurerm_resource_group\" \"management\" {\r\n\r\n\r\n  name     = \"management-rg\"\r\n  location = \"West Europe\"\r\n}\r\n\r\nresource \"azurerm_storage_account\" \"test\" {\r\n  name                     = \"diagnostics${azurerm_resource_group.management.name}\"\r\n  resource_group_name      = \"${azurerm_resource_group.management.name}\"\r\n  location                 = \"${azurerm_resource_group.management.location}\"\r\n  account_tier             = \"Standard\"\r\n  account_replication_type = \"LRS\"\r\n\r\n  tags = {\r\n    environment = \"diagnostics\"\r\n  }\r\n}\r\n\r\n    depends_on = [\r\n    \"module_enable_diagnostics_logs\"\r\n  ]\r\n\r\n```", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "each policy represents a custom module. ", "keywords": ["policy"]}, {"source": "Text", "text": "but, I need a storage account for that. ", "keywords": ["storage"]}, {"source": "Text", "text": "I want to create first the storage account and then the module of diagnostics settings. ", "keywords": ["storage"]}, {"source": "Text", "text": "Thanks for the help!! :) **this below code represents the main.tf file:** ``` //calling the create storage account name module \"createstorageaccount\" { source = \"./modules/module_create_storage_account\" depends_on = [ \"module_enable_diagnostics_logs\" ] } ``` **this one represents the create storage account module** ``` resource \"azurerm_resource_group\" \"management\" { name = \"management-rg\" location = \"West Europe\" } resource \"azurerm_storage_account\" \"test\" { name = \"diagnostics${azurerm_resource_group.management.name}\" resource_group_name = \"${azurerm_resource_group.management.name}\" location = \"${azurerm_resource_group.management.location}\" account_tier = \"Standard\" account_replication_type = \"LRS\" tags = { environment = \"diagnostics\" } } depends_on = [ \"module_enable_diagnostics_logs\" ] ```", "keywords": ["storage", "test"]}]}, {"Id": "206768148", "PostHistoryTypeId": "1", "PostId": "58275233", "RevisionGUID": "64e6e327-83f9-4f60-9bce-4b9d01c0610d", "CreationDate": "2019-10-07T18:30:00.857", "UserId": "9734720", "Text": "Terraform depends_on with modules", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "206768149", "PostHistoryTypeId": "3", "PostId": "58275233", "RevisionGUID": "64e6e327-83f9-4f60-9bce-4b9d01c0610d", "CreationDate": "2019-10-07T18:30:00.857", "UserId": "9734720", "Text": "<azure><terraform>", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "228137277", "PostHistoryTypeId": "6", "PostId": "58275233", "RevisionGUID": "21b5342f-61da-44a2-9ef0-f73547424011", "CreationDate": "2020-08-05T08:23:06.730", "UserId": "5372462", "Comment": "added terraform-provider-azure to tags", "Text": "<azure><terraform><terraform-provider-azure>", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Comment", "text": "added terraform-provider-azure to tags", "keywords": ["provider"]}]}, {"Id": "228137278", "PostHistoryTypeId": "24", "PostId": "58275233", "RevisionGUID": "21b5342f-61da-44a2-9ef0-f73547424011", "CreationDate": "2020-08-05T08:23:06.730", "Comment": "Proposed by 5372462 approved by 1161484, 1266190 edit id of 4911402", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "answers": [{"Id": "63205802", "PostTypeId": "2", "ParentId": "58275233", "CreationDate": "2020-08-01T13:36:46.837", "Score": "26", "Body": "<p>module dependencies are now supported in Terraform 13, this is currently at the release candidate stage.</p>\n<pre><code>resource &quot;aws_iam_policy_attachment&quot; &quot;example&quot; {\n  name       = &quot;example&quot;\n  roles      = [aws_iam_role.example.name]\n  policy_arn = aws_iam_policy.example.arn\n}\n\nmodule &quot;uses-role&quot; {\n  # ...\n\n  depends_on = [aws_iam_policy_attachment.example]\n}\n</code></pre>\n", "OwnerUserId": "8622323", "LastActivityDate": "2020-08-01T13:36:46.837", "CommentCount": "1", "ContentLicense": "CC BY-SA 4.0", "comments": [{"Id": "112993350", "PostId": "63205802", "Score": "2", "Text": "Just note that using per resource dependancy is still prefered to have fine grained parallel resource handling instead of blocking entire module processing while not all your module resources depend on some external resources", "CreationDate": "2020-09-15T09:07:25.180", "UserId": "672780", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "history": [{"Id": "227907353", "PostHistoryTypeId": "2", "PostId": "63205802", "RevisionGUID": "1626ac95-b53a-4297-9df8-079d8413b494", "CreationDate": "2020-08-01T13:36:46.837", "UserId": "8622323", "Text": "module dependencies are now supported in Terraform 13, this is currently at the release candidate stage.\r\n\r\n    resource \"aws_iam_policy_attachment\" \"example\" {\r\n      name       = \"example\"\r\n      roles      = [aws_iam_role.example.name]\r\n      policy_arn = aws_iam_policy.example.arn\r\n    }\r\n    \r\n    module \"uses-role\" {\r\n      # ...\r\n    \r\n      depends_on = [aws_iam_policy_attachment.example]\r\n    }", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "filtered-sentences": []}, {"Id": "58277124", "PostTypeId": "2", "ParentId": "58275233", "CreationDate": "2019-10-07T21:04:17.587", "Score": "51", "Body": "<p>In most cases, the necessary dependencies just occur automatically as a result of your references. If the configuration for one resource refers directly or indirectly to another, Terraform automatically infers the dependency between them without the need for explicit <code>depends_on</code>.</p>\n\n<p>This works because module variables and outputs are also nodes in the dependency graph: if a child module resource refers to <code>var.foo</code> then it indirectly depends on anything that the value of that variable depends on.</p>\n\n<p>For the rare situation where automatic dependency detection is insufficient, you can still exploit the fact that module variables and outputs are nodes in the dependency graph to create indirect <em>explicit</em> dependencies, like this:</p>\n\n<pre><code>variable \"storage_account_depends_on\" {\n  # the value doesn't matter; we're just using this variable\n  # to propagate dependencies.\n  type    = any\n  default = []\n}\n\nresource \"azurerm_storage_account\" \"test\" {\n  name                     = \"diagnostics${azurerm_resource_group.management.name}\"\n  resource_group_name      = \"${azurerm_resource_group.management.name}\"\n  location                 = \"${azurerm_resource_group.management.location}\"\n  account_tier             = \"Standard\"\n  account_replication_type = \"LRS\"\n\n  tags = {\n    environment = \"diagnostics\"\n  }\n\n  # This resource depends on whatever the variable\n  # depends on, indirectly. This is the same\n  # as using var.storage_account_depends_on in\n  # an expression above, but for situations where\n  # we don't actually need the value.\n  depends_on = [var.storage_account_depends_on]\n}\n</code></pre>\n\n<p>When you call this module, you can set <code>storage_account_depends_on</code> to any expression that includes the objects you want to ensure are created before the storage account:</p>\n\n<pre><code>module \"diagnostic_logs\" {\n  source = \"./modules/diagnostic_logs\"\n}\n\nmodule \"storage_account\" {\n  source = \"./modules/storage_account\"\n\n  storage_account_depends_on = [module.diagnostic_logs.logging]\n}\n</code></pre>\n\n<p>Then in your <code>diagnostic_logs</code> module you can configure indirect dependencies for the <code>logging</code> output to complete the dependency links between the modules:</p>\n\n<pre><code>output \"logging\" {\n  # Again, the value is not important because we're just\n  # using this for its dependencies.\n  value = {}\n\n  # Anything that refers to this output must wait until\n  # the actions for azurerm_monitor_diagnostic_setting.example\n  # to have completed first.\n  depends_on = [azurerm_monitor_diagnostic_setting.example]\n}\n</code></pre>\n\n<p>If your relationships can be expressed by passing actual <em>values</em> around, such as by having an output that includes the id, I'd recommend preferring that approach because it leads to a configuration that is easier to follow. But in rare situations where there are relationships between resources that cannot be modeled as data flow, you can use outputs and variables to propagate explicit dependencies between modules too.</p>\n", "OwnerUserId": "281848", "LastActivityDate": "2019-10-07T21:04:17.587", "CommentCount": "2", "ContentLicense": "CC BY-SA 4.0", "comments": [{"Id": "102927959", "PostId": "58277124", "Score": "1", "Text": "Thank you very much for the detailed answer!!", "CreationDate": "2019-10-08T06:33:02.783", "UserId": "9734720", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "111258907", "PostId": "58277124", "Score": "2", "Text": "The above code will create the diagnostic_logs before storage_account. Please pay attention!", "CreationDate": "2020-07-15T12:50:13.547", "UserId": "8236311", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "Please pay attention!", "keywords": ["pay"]}]}], "history": [{"Id": "206775901", "PostHistoryTypeId": "2", "PostId": "58277124", "RevisionGUID": "1579dd1f-302c-40be-8156-fc5739d943f2", "CreationDate": "2019-10-07T21:04:17.587", "UserId": "281848", "Text": "In most cases, the necessary dependencies just occur automatically as a result of your references. If the configuration for one resource refers directly or indirectly to another, Terraform automatically infers the dependency between them without the need for explicit `depends_on`.\r\n\r\nThis works because module variables and outputs are also nodes in the dependency graph: if a child module resource refers to `var.foo` then it indirectly depends on anything that the value of that variable depends on.\r\n\r\nFor the rare situation where automatic dependency detection is insufficient, you can still exploit the fact that module variables and outputs are nodes in the dependency graph to create indirect _explicit_ dependencies, like this:\r\n\r\n```\r\nvariable \"storage_account_depends_on\" {\r\n  # the value doesn't matter; we're just using this variable\r\n  # to propagate dependencies.\r\n  type    = any\r\n  default = []\r\n}\r\n\r\nresource \"azurerm_storage_account\" \"test\" {\r\n  name                     = \"diagnostics${azurerm_resource_group.management.name}\"\r\n  resource_group_name      = \"${azurerm_resource_group.management.name}\"\r\n  location                 = \"${azurerm_resource_group.management.location}\"\r\n  account_tier             = \"Standard\"\r\n  account_replication_type = \"LRS\"\r\n\r\n  tags = {\r\n    environment = \"diagnostics\"\r\n  }\r\n\r\n  # This resource depends on whatever the variable\r\n  # depends on, indirectly. This is the same\r\n  # as using var.storage_account_depends_on in\r\n  # an expression above, but for situations where\r\n  # we don't actually need the value.\r\n  depends_on = [var.storage_account_depends_on]\r\n}\r\n```\r\n\r\nWhen you call this module, you can set `storage_account_depends_on` to any expression that includes the objects you want to ensure are created before the storage account:\r\n\r\n```\r\nmodule \"diagnostic_logs\" {\r\n  source = \"./modules/diagnostic_logs\"\r\n}\r\n\r\nmodule \"storage_account\" {\r\n  source = \"./modules/storage_account\"\r\n\r\n  storage_account_depends_on = [module.diagnostic_logs.logging]\r\n}\r\n```\r\n\r\nThen in your `diagnostic_logs` module you can configure indirect dependencies for the `logging` output to complete the dependency links between the modules:\r\n\r\n```\r\noutput \"logging\" {\r\n  # Again, the value is not important because we're just\r\n  # using this for its dependencies.\r\n  value = {}\r\n\r\n  # Anything that refers to this output must wait until\r\n  # the actions for azurerm_monitor_diagnostic_setting.example\r\n  # to have completed first.\r\n  depends_on = [azurerm_monitor_diagnostic_setting.example]\r\n}\r\n```\r\n\r\nIf your relationships can be expressed by passing actual _values_ around, such as by having an output that includes the id, I'd recommend preferring that approach because it leads to a configuration that is easier to follow. But in rare situations where there are relationships between resources that cannot be modeled as data flow, you can use outputs and variables to propagate explicit dependencies between modules too.\r\n", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "For the rare situation where automatic dependency detection is insufficient, you can still exploit the fact that module variables and outputs are nodes in the dependency graph to create indirect _explicit_ dependencies, like this: ``` variable \"storage_account_depends_on\" { # the value doesn't matter; we're just using this variable # to propagate dependencies. type = any default = [] } resource \"azurerm_storage_account\" \"test\" { name = \"diagnostics${azurerm_resource_group.management.name}\" resource_group_name = \"${azurerm_resource_group.management.name}\" location = \"${azurerm_resource_group.management.location}\" account_tier = \"Standard\" account_replication_type = \"LRS\" tags = { environment = \"diagnostics\" } # This resource depends on whatever the variable # depends on, indirectly. ", "keywords": ["test"]}, {"source": "Text", "text": "When you call this module, you can set `storage_account_depends_on` to any expression that includes the objects you want to ensure are created before the storage account: ``` module \"diagnostic_logs\" { source = \"./modules/diagnostic_logs\" } module \"storage_account\" { source = \"./modules/storage_account\" storage_account_depends_on = [module.diagnostic_logs.logging] } ``` Then in your `diagnostic_logs` module you can configure indirect dependencies for the `logging` output to complete the dependency links between the modules: ``` output \"logging\" { # Again, the value is not important because we're just # using this for its dependencies. ", "keywords": ["storage"]}]}], "filtered-sentences": [{"source": "Body", "text": "For the rare situation where automatic dependency detection is insufficient, you can still exploit the fact that module variables and outputs are nodes in the dependency graph to create indirect explicit dependencies, like this: When you call this module, you can set storage_account_depends_on to any expression that includes the objects you want to ensure are created before the storage account: ", "keywords": ["storage"]}]}, {"Id": "73641550", "PostTypeId": "2", "ParentId": "58275233", "CreationDate": "2022-09-07T21:16:55.920", "Score": "2", "Body": "<p>Using depends_on at resource level is different from using depends_on at inter-module level i found very simple way to do to it at module level</p>\n<pre><code>module &quot;eks&quot; {\nsource = &quot;../modules/eks&quot;\nvpc_id = module.vpc.vpc_id\nvpc_cidr = [module.vpc.vpc_cidr_block]\npublic_subnets = flatten([module.vpc.public_subnets])\nprivate_subnets_id = flatten([module.vpc.private_subnets])\ndepends_on = [module.vpc] \n}\n</code></pre>\n<p>i created dependencies directly with module simple as simplest no complex relation reequired</p>\n", "OwnerUserId": "4572396", "LastActivityDate": "2022-09-07T21:16:55.920", "CommentCount": "2", "ContentLicense": "CC BY-SA 4.0", "comments": [{"Id": "130583819", "PostId": "73641550", "Score": "0", "Text": "Hi @mansur, is it possible to call depends_on = [module.mymodule] wherein the module \"mymodule\" is on another directory?\nI tried calling it but it says the error: \nNo module call named \"mymodule\" is declared in the root module", "CreationDate": "2022-10-05T06:57:08.943", "UserId": "2829590", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "130634969", "PostId": "73641550", "Score": "0", "Text": "in that case you need to use submodules concept in terraform", "CreationDate": "2022-10-07T10:44:46.603", "UserId": "4572396", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "history": [{"Id": "277793136", "PostHistoryTypeId": "2", "PostId": "73641550", "RevisionGUID": "a9721eb4-7edd-4209-85c8-1c91d39f1071", "CreationDate": "2022-09-07T21:16:55.920", "UserId": "4572396", "Text": "Using depends_on at resource level is different from using depends_on at inter-module level i found very simple way to do to it at module level \r\n\r\n    module \"eks\" {\r\n    source = \"../modules/eks\"\r\n    vpc_id = module.vpc.vpc_id\r\n    vpc_cidr = [module.vpc.vpc_cidr_block]\r\n    public_subnets = flatten([module.vpc.public_subnets])\r\n    private_subnets_id = flatten([module.vpc.private_subnets])\r\n    depends_on = [module.vpc] \r\n    }\r\ni created dependencies directly with module simple as simplest no complex relation reequired  \r\n\r\n", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "filtered-sentences": []}], "contains-topic": true, "filtered-sentences": [{"source": "Body", "text": "each policy represents a custom module. ", "keywords": ["policy"]}, {"source": "Body", "text": "but, I need a storage account for that. ", "keywords": ["storage"]}, {"source": "Body", "text": "I want to create first the storage account and then the module of diagnostics settings. ", "keywords": ["storage"]}, {"source": "Body", "text": "this below code represents the main.tf file: this one represents the create storage account module", "keywords": ["storage"]}]}