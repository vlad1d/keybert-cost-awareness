{"Id": "73056501", "PostTypeId": "1", "CreationDate": "2022-07-20T18:23:54.727", "Score": "1", "ViewCount": "758", "Body": "<p>I am trying to get all combinations of a single terraform list (order doesn't matter). Whenever I google this I get results like setproduct, which can only return all combinations of 2 lists. However, I do not want to do this for 2 lists, I only want to do it for one single list. Sorry if this is a silly question, very new to Terraform and I can't find anything about this type of thing in the docs.</p>\n<p>Example:</p>\n<pre><code>fruits = tolist([&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;])\n</code></pre>\n<p>Lets say I want every possible combination of 2 elements from this list (I'd also like this number to be able to be modified, so I can get all combinations of 1 element, or 3, etc.).\nSo, I want every possible combination of 2 elements, like the following output:</p>\n<pre><code>[\n    [\n      &quot;Apple&quot;,\n      &quot;Banana&quot;\n    ],\n    [\n      &quot;Apple&quot;,\n      &quot;Orange&quot;\n    ],\n    [\n      &quot;Orange&quot;,\n      &quot;Banana&quot;\n    ]\n]\n</code></pre>\n<p>Is this sort of thing possible in Terraform language?</p>\n", "OwnerUserId": "18435238", "LastActivityDate": "2022-07-22T01:22:08.687", "Title": "Terraform: How to get all combinations of elements from a single list", "Tags": "<list><terraform><combinations><infrastructure-as-code>", "AnswerCount": "2", "CommentCount": "3", "ContentLicense": "CC BY-SA 4.0", "comments": [{"Id": "129031995", "PostId": "73056501", "Score": "1", "Text": "I do not believe there is a mathematical function that can compute this. The closest algorithm I believe would be `setproduct(chunklist([\"Apple\", \"Banana\", \"Orange\"], 1)...)`, but the cartesian product would still enforce a 1x3 instead of a 3x2. You could also hack it to get the permutations with `[for fruits in setproduct([\"Apple\", \"Banana\", \"Orange\"], [\"Apple\", \"Banana\", \"Orange\"]) : fruits if fruits[0] != fruits[1]]`, but you want the combinations instead.", "CreationDate": "2022-07-20T19:48:03.477", "UserId": "5343387", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "129032025", "PostId": "73056501", "Score": "0", "Text": "That was still a fun exercise though, so thanks for asking an interesting HCL2 algorithm question. You probably need to approach this from a lower level, and custom Go function support does not yet exist in HCL2.", "CreationDate": "2022-07-20T19:49:41.807", "UserId": "5343387", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "129032228", "PostId": "73056501", "Score": "0", "Text": "Ah, so it sounds like it's not really possible in pure Terraform as of right now the way I want it. Well thanks for trying to help anyways! I'm going to look into the AWS CDK and Terraform CDK to just get the combinations using Python, since I'm using this concept for certain values in AWS resources. You mention custom Go function support, is that something that is planned for Terraform in the future?", "CreationDate": "2022-07-20T20:02:29.980", "UserId": "18435238", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "history": [{"Id": "274616187", "PostHistoryTypeId": "2", "PostId": "73056501", "RevisionGUID": "948ffa39-db8f-4df9-895c-6ca654716bd9", "CreationDate": "2022-07-20T18:23:54.727", "UserId": "18435238", "Text": "I am trying to get all combinations of a single terraform list (order doesn't matter). Whenever I google this I get results like setproduct, which can only return all combinations of 2 lists. However, I do not want to do this for 2 lists, I only want to do it for one single list. Sorry if this is a silly question, very new to Terraform and I can't find anything about this type of thing in the docs. \r\n\r\nExample: \r\n\r\n    fruits = tolist([\"Apple\", \"Banana\", \"Orange\"])\r\n\r\nLets say I want every possible combination of 2 elements from this list (I'd also like this number to be able to be modified, so I can get all combinations of 1 element, or 3, etc.).\r\nSo, I want every possible combination of 2 elements, like the following output:\r\n\r\n    [\r\n        [\r\n          \"Apple\",\r\n          \"Banana\"\r\n        ],\r\n        [\r\n          \"Apple\",\r\n          \"Orange\"\r\n        ],\r\n        [\r\n          \"Orange\",\r\n          \"Banana\"\r\n        ]\r\n    ]\r\n\r\nIs this sort of thing possible in Terraform language?", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "274616189", "PostHistoryTypeId": "1", "PostId": "73056501", "RevisionGUID": "948ffa39-db8f-4df9-895c-6ca654716bd9", "CreationDate": "2022-07-20T18:23:54.727", "UserId": "18435238", "Text": "Terraform: How to get all combinations of elements from a single list", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "274616190", "PostHistoryTypeId": "3", "PostId": "73056501", "RevisionGUID": "948ffa39-db8f-4df9-895c-6ca654716bd9", "CreationDate": "2022-07-20T18:23:54.727", "UserId": "18435238", "Text": "<list><terraform><combinations><infrastructure-as-code>", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "answers": [{"Id": "73058704", "PostTypeId": "2", "ParentId": "73056501", "CreationDate": "2022-07-20T22:20:50.450", "Score": "0", "Body": "<p>How about this:</p>\n<pre><code>locals {\n  fruits = [&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;]\n  subset = 2\n  permutations = flatten([for i in range(0, local.subset - 1):\n      setproduct(tolist(element(local.fruits, i)), slice(local.fruits, i + 1))\n    ]\n  )\n}\n</code></pre>\n<p>Iterate over i, take the i element in the 'fruits' list and turn it into a list. Then remove all elements in the 'fruits' list up to (and including) the i'th element using the <code>slice()</code> command. Then create a set product using <code>setproduct()</code> function. Now increase i by 1, move to the next element in the 'fruits' list and repeat. Note that in each iteration the second list being passed to <code>setproduct()</code> is shorter than the previous one and so no duplicates occur.</p>\n<p>Hope this helps!</p>\n", "OwnerUserId": "19515176", "LastEditorUserId": "19515176", "LastEditDate": "2022-07-20T22:25:52.677", "LastActivityDate": "2022-07-20T22:25:52.677", "CommentCount": "1", "ContentLicense": "CC BY-SA 4.0", "comments": [{"Id": "129050073", "PostId": "73058704", "Score": "0", "Text": "Unfortunately this gives a few errors, I'm trying to figure out how to get it working. First, slice needs 3 arguments, and second, I'm getting an error: \"Invalid value for 'v' parameter: cannot convert object to list of any single type\". I have no idea what it means by that so let me know if you know why it has an issue with this. I do think that the overall logic of this solution makes sense though.", "CreationDate": "2022-07-21T14:26:10.200", "UserId": "18435238", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "history": [{"Id": "274627854", "PostHistoryTypeId": "2", "PostId": "73058704", "RevisionGUID": "04834c99-0e66-4dcd-9daa-b4855720e4ba", "CreationDate": "2022-07-20T22:20:50.450", "UserId": "19515176", "Text": "How about this:\r\n\r\n    locals {\r\n      fruits = [\"Apple\", \"Banana\", \"Orange\"]\r\n      subset = 2\r\n      permutations = flatten([for i in range(0, local.subset - 1):\r\n          setproduct(tolist(element(local.fruits, i)), slice(local.fruits, i + 1))\r\n        ]\r\n      )\r\n    }\r\n\r\n", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "274628026", "PostHistoryTypeId": "5", "PostId": "73058704", "RevisionGUID": "349012a3-4db8-41b1-8db3-f0aea8eb72e7", "CreationDate": "2022-07-20T22:25:52.677", "UserId": "19515176", "Comment": "added 492 characters in body", "Text": "How about this:\r\n\r\n    locals {\r\n      fruits = [\"Apple\", \"Banana\", \"Orange\"]\r\n      subset = 2\r\n      permutations = flatten([for i in range(0, local.subset - 1):\r\n          setproduct(tolist(element(local.fruits, i)), slice(local.fruits, i + 1))\r\n        ]\r\n      )\r\n    }\r\n\r\nIterate over i, take the i element in the 'fruits' list and turn it into a list. Then remove all elements in the 'fruits' list up to (and including) the i'th element using the `slice()` command. Then create a set product using `setproduct()` function. Now increase i by 1, move to the next element in the 'fruits' list and repeat. Note that in each iteration the second list being passed to `setproduct()` is shorter than the previous one and so no duplicates occur.\r\n\r\nHope this helps!\r\n", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "filtered-sentences": []}, {"Id": "73074144", "PostTypeId": "2", "ParentId": "73056501", "CreationDate": "2022-07-22T01:22:08.687", "Score": "4", "Body": "<p>I think there are a few different ways to wrangle this using the primitives in Terraform. When I'm working with set-ish things I prefer to use the set primitives as much as possible, so here's one way to do that which uses sets as much as possible:</p>\n<pre><code>locals {\n  fruits = toset([&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;])\n\n  pairs = setproduct(local.fruits, local.fruits)\n\n  permutations = toset([\n    for p in local.pairs : toset(p)\n    if p[0] != p[1]\n  ])\n}\n</code></pre>\n<p>The results for each of these local values are as follows:</p>\n<pre><code>fruits = toset([\n  &quot;Apple&quot;,\n  &quot;Banana&quot;,\n  &quot;Orange&quot;,\n])\n\npairs = toset([\n  [\n    &quot;Apple&quot;,\n    &quot;Apple&quot;,\n  ],\n  [\n    &quot;Apple&quot;,\n    &quot;Banana&quot;,\n  ],\n  [\n    &quot;Apple&quot;,\n    &quot;Orange&quot;,\n  ],\n  [\n    &quot;Banana&quot;,\n    &quot;Apple&quot;,\n  ],\n  [\n    &quot;Banana&quot;,\n    &quot;Banana&quot;,\n  ],\n  [\n    &quot;Banana&quot;,\n    &quot;Orange&quot;,\n  ],\n  [\n    &quot;Orange&quot;,\n    &quot;Apple&quot;,\n  ],\n  [\n    &quot;Orange&quot;,\n    &quot;Banana&quot;,\n  ],\n  [\n    &quot;Orange&quot;,\n    &quot;Orange&quot;,\n  ],\n])\n\npermutations = toset([\n  toset([\n    &quot;Apple&quot;,\n    &quot;Banana&quot;,\n  ]),\n  toset([\n    &quot;Apple&quot;,\n    &quot;Orange&quot;,\n  ]),\n  toset([\n    &quot;Banana&quot;,\n    &quot;Orange&quot;,\n  ]),\n])\n</code></pre>\n<p>The &quot;trick&quot; here is to turn the final pairs into sets and also make a set of those pairs, which conveniently discards all of the pairings that differ only in the order of the items, such as <code>[&quot;Apple&quot;, &quot;Orange&quot;]</code> vs <code>[&quot;Orange&quot;, &quot;Apple&quot;]</code>.</p>\n<p>This is technically not exactly what you asked for since the result is a set of sets rather than a list of lists. I can't think of any meaningful fixed order for the overall set of pairs to be in, but you could potentially sort the pairs themselves into alphabetical order if that's important to your outcome, with one additional step:</p>\n<pre><code>locals {\n  sorted_permitations = toset([\n    for p in local.permutations : sort(p)\n  ])\n}\n</code></pre>\n<pre><code>sorted_permutations = toset([\n  tolist([\n    &quot;Apple&quot;,\n    &quot;Banana&quot;,\n  ]),\n  tolist([\n    &quot;Apple&quot;,\n    &quot;Orange&quot;,\n  ]),\n  tolist([\n    &quot;Banana&quot;,\n    &quot;Orange&quot;,\n  ]),\n])\n</code></pre>\n", "OwnerUserId": "281848", "LastActivityDate": "2022-07-22T01:22:08.687", "CommentCount": "4", "ContentLicense": "CC BY-SA 4.0", "comments": [{"Id": "129078855", "PostId": "73074144", "Score": "0", "Text": "The only problem with this is that we can't assume that we only want pairs. I want to be able to modify the number of elements in each list. So say we have a list of 5 elements, and I want every possible combination of 3 elements, or 4 elements, etc.", "CreationDate": "2022-07-22T18:21:11.383", "UserId": "18435238", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "129079928", "PostId": "73074144", "Score": "0", "Text": "I _think_ this answer can scale by providing more copies of the same set to the `setproduct` function and writing increasingly-complicated `if` conditions to catch the cases where there are duplicates, but indeed this solution doesn't scale _dynamically_ to an arbitrary number of items per set, only to fixed numbers and at the expense of an increasingly-complicated condition.", "CreationDate": "2022-07-22T19:21:44.247", "UserId": "281848", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "I _think_ this answer can scale by providing more copies of the same set to the `setproduct` function and writing increasingly-complicated `if` conditions to catch the cases where there are duplicates, but indeed this solution doesn't scale _dynamically_ to an arbitrary number of items per set, only to fixed numbers and at the expense of an increasingly-complicated condition.", "keywords": ["expense"]}]}, {"Id": "129079972", "PostId": "73074144", "Score": "0", "Text": "I suppose it might be possible to generalize that condition by writing something like `if length(toset(p)) == length(p)`, which will return false if conversion to a set removes any elements. Elements would be removed in that conversion only if there are multiple elements with the same value.", "CreationDate": "2022-07-22T19:24:39.780", "UserId": "281848", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "129079985", "PostId": "73074144", "Score": "0", "Text": "I don't have time today to revise this in the way I described above, but if you try it and succeed I'd love to see your answer! ", "CreationDate": "2022-07-22T19:25:46.193", "UserId": "281848", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "history": [{"Id": "274708841", "PostHistoryTypeId": "2", "PostId": "73074144", "RevisionGUID": "c83d2f03-6862-49a0-9e3e-e07a6ed56edb", "CreationDate": "2022-07-22T01:22:08.687", "UserId": "281848", "Text": "I think there are a few different ways to wrangle this using the primitives in Terraform. When I'm working with set-ish things I prefer to use the set primitives as much as possible, so here's one way to do that which uses sets as much as possible:\r\n\r\n```\r\nlocals {\r\n  fruits = toset([\"Apple\", \"Banana\", \"Orange\"])\r\n\r\n  pairs = setproduct(local.fruits, local.fruits)\r\n\r\n  permutations = toset([\r\n    for p in local.pairs : toset(p)\r\n    if p[0] != p[1]\r\n  ])\r\n}\r\n```\r\n\r\nThe results for each of these local values are as follows:\r\n\r\n```\r\nfruits = toset([\r\n  \"Apple\",\r\n  \"Banana\",\r\n  \"Orange\",\r\n])\r\n\r\npairs = toset([\r\n  [\r\n    \"Apple\",\r\n    \"Apple\",\r\n  ],\r\n  [\r\n    \"Apple\",\r\n    \"Banana\",\r\n  ],\r\n  [\r\n    \"Apple\",\r\n    \"Orange\",\r\n  ],\r\n  [\r\n    \"Banana\",\r\n    \"Apple\",\r\n  ],\r\n  [\r\n    \"Banana\",\r\n    \"Banana\",\r\n  ],\r\n  [\r\n    \"Banana\",\r\n    \"Orange\",\r\n  ],\r\n  [\r\n    \"Orange\",\r\n    \"Apple\",\r\n  ],\r\n  [\r\n    \"Orange\",\r\n    \"Banana\",\r\n  ],\r\n  [\r\n    \"Orange\",\r\n    \"Orange\",\r\n  ],\r\n])\r\n\r\npermutations = toset([\r\n  toset([\r\n    \"Apple\",\r\n    \"Banana\",\r\n  ]),\r\n  toset([\r\n    \"Apple\",\r\n    \"Orange\",\r\n  ]),\r\n  toset([\r\n    \"Banana\",\r\n    \"Orange\",\r\n  ]),\r\n])\r\n```\r\n\r\nThe \"trick\" here is to turn the final pairs into sets and also make a set of those pairs, which conveniently discards all of the pairings that differ only in the order of the items, such as `[\"Apple\", \"Orange\"]` vs `[\"Orange\", \"Apple\"]`.\r\n\r\nThis is technically not exactly what you asked for since the result is a set of sets rather than a list of lists. I can't think of any meaningful fixed order for the overall set of pairs to be in, but you could potentially sort the pairs themselves into alphabetical order if that's important to your outcome, with one additional step:\r\n\r\n```\r\nlocals {\r\n  sorted_permitations = toset([\r\n    for p in local.permutations : sort(p)\r\n  ])\r\n}\r\n```\r\n\r\n```\r\nsorted_permutations = toset([\r\n  tolist([\r\n    \"Apple\",\r\n    \"Banana\",\r\n  ]),\r\n  tolist([\r\n    \"Apple\",\r\n    \"Orange\",\r\n  ]),\r\n  tolist([\r\n    \"Banana\",\r\n    \"Orange\",\r\n  ]),\r\n])\r\n```\r\n", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "filtered-sentences": []}], "contains-topic": false, "filtered-sentences": []}