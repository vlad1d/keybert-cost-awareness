{"Id": "74034959", "PostTypeId": "1", "CreationDate": "2022-10-11T23:18:41.063", "Score": "0", "ViewCount": "189", "Body": "<p>I create few resources in the terraform -</p>\n<pre><code>resource &quot;aws_dms_replication_instance&quot; &quot;foobar_instance_1&quot; {\n\n}\n\nresource &quot;aws_dms_replication_instance&quot; &quot;foobar_instance_2&quot; {\n\n}\n\nresource &quot;aws_dms_endpoint&quot; &quot;foobar_source_1&quot; {\n\n}\n\nresource &quot;aws_dms_endpoint&quot; &quot;foobar_source_2&quot; {\n\n}\n</code></pre>\n<p>Then define a replication task that's dependent on above two resources -</p>\n<pre><code>resource &quot;aws_dms_replication_task&quot; &quot;foobar_task_1&quot; {\n\nreplication_instance_arn = aws_dms_replication_instance.foobar_instance_1.replication_instance_arn\nsource_endpoint_arn       = aws_dms_endpoint.foobar_source_1.endpoint_arn\n.\n.\n.\n}\n</code></pre>\n<p>I want to use a tf variable to automate a similar <code>aws_dms_replication_task</code> creation using for_each. I create a Map variable in <code>variables.tf</code>  that\nlooks like this -</p>\n<pre><code>variable &quot;task_map&quot; {\n  type        = map(object({\n    source_endpoint     = string\n    repl_instance     = string\n  }))\n  default = {\n    &quot;dms_attr_map&quot; = {\n      source_ep     = &quot;foobar_source_1&quot;\n      repl_instance = &quot;foobar_instance_1&quot;\n    },\n    &quot;dms_attr_map2&quot; = {\n      source_ep     = &quot;foobar_source_2&quot;\n      repl_instance = &quot;foobar_instance_2&quot;\n    }\n\n  }\n}\n</code></pre>\n<p>Now, I go on to create a resource block to loop over task_map and create replication_task</p>\n<pre><code>resource &quot;aws_dms_replication_task&quot; &quot;for_each_task_1&quot; {\n    for_each                  = var.task_map\n    replication_instance_arn  =  aws_dms_replication_instance.${each.value[&quot;repl_instance&quot;]}.replication_instance_arn\n    source_endpoint_arn       = aws_dms_endpoint.${each.value[&quot;source_ep&quot;]}.endpoint_arn\n    .   \n    .\n    .\n}\n</code></pre>\n<p>As I execute my plan, terrraform plan throws an error that referring to replication_instance using <code>${each.value[&quot;repl_instance&quot;]}</code> is wrong.</p>\n<p>Error message -</p>\n<blockquote>\n<p>\u2502 Error: Invalid character \u2502  \u2502 On ../modules/cdc/main.tf line 236:\nThis character is not used within the \u2502 language. \u2575</p>\n<p>\u2577 \u2502 Error: Invalid attribute name \u2502  \u2502 On ../modules/cdc/main.tf line\n233: An attribute name is required after a \u2502 dot. \u2575</p>\n</blockquote>\n<p>Error messages point to the specific line where I use for_each to refer to replication_instance and source_endpoint</p>\n<pre><code>aws_dms_endpoint.${each.value[&quot;source_ep&quot;]}.endpoint_arn\naws_dms_replication_instance.${each.value[&quot;repl_instance&quot;]}.replication_instance_arn\n</code></pre>\n<p>How do I refer to the resources created using their names using a <code>for_each</code>.</p>\n<p>Thank you.</p>\n", "OwnerUserId": "2289031", "LastEditorUserId": "248823", "LastEditDate": "2022-10-11T23:36:23.470", "LastActivityDate": "2022-10-12T02:08:26.860", "Title": "How to define a resource block with for_each that refers to other resources", "Tags": "<amazon-web-services><terraform><terraform-provider-aws>", "AnswerCount": "2", "CommentCount": "0", "ContentLicense": "CC BY-SA 4.0", "history": [{"Id": "279934710", "PostHistoryTypeId": "2", "PostId": "74034959", "RevisionGUID": "a89777a9-43ab-4f3b-a042-38418cb21d90", "CreationDate": "2022-10-11T23:18:41.063", "UserId": "2289031", "Text": "I create few resources in the terraform - \r\n\r\n\r\n    resource \"aws_dms_replication_instance\" \"foobar_instance_1\" {\r\n    \r\n    }\r\n    \r\n    resource \"aws_dms_replication_instance\" \"foobar_instance_2\" {\r\n    \r\n    }\r\n    \r\n    resource \"aws_dms_endpoint\" \"foobar_source_1\" {\r\n    \r\n    }\r\n    \r\n    resource \"aws_dms_endpoint\" \"foobar_source_2\" {\r\n    \r\n    }\r\n\r\nThen define a replication task that's dependent on above two resources - \r\n\r\n    resource \"aws_dms_replication_task\" \"foobar_task_1\" {\r\n    \r\n    replication_instance_arn = aws_dms_replication_instance.foobar_instance_1.replication_instance_arn\r\n    source_endpoint_arn       = aws_dms_endpoint.foobar_source_1.endpoint_arn\r\n    .\r\n    .\r\n    .\r\n    }\r\n\r\nI want to use a tf variable to automate a similar `aws_dms_replication_task` creation using for_each. I create a Map variable in `variables.tf`  that\r\nlooks like this - \r\n\r\n    variable \"task_map\" {\r\n      type        = map(object({\r\n        source_endpoint     = string\r\n        repl_instance     = string\r\n      }))\r\n      default = {\r\n        \"dms_attr_map\" = {\r\n          source_ep     = \"foobar_source_1\"\r\n          repl_instance = \"foobar_instance_1\"\r\n        },\r\n        \"dms_attr_map2\" = {\r\n          source_ep     = \"foobar_source_2\"\r\n          repl_instance = \"foobar_instance_2\"\r\n        }\r\n    \r\n      }\r\n    }\r\n\r\nNow, I go on to create a resource block to loop over task_map and create replication_task\r\n\r\n    resource \"aws_dms_replication_task\" \"for_each_task_1\" {\r\n     for_each                  = var.task_map\r\n     replication_instance_arn  =  aws_dms_replication_instance.${each.value[\"repl_instance\"]}.replication_instance_arn\r\n     source_endpoint_arn       = aws_dms_endpoint.${each.value[\"source_ep\"]}.endpoint_arn\r\n     . \r\n     .\r\n     .\r\n    }\r\n\r\nAs I execute my plan, terrraform plan throws an error that referring to replication_instance using `${each.value[\"repl_instance\"]}` is wrong.\r\n\r\nError message - \r\n\r\n> \u2502 Error: Invalid character \u2502  \u2502 On ../modules/cdc/main.tf line 236:\r\n> This character is not used within the \u2502 language. \u2575\r\n> \r\n> \u2577 \u2502 Error: Invalid attribute name \u2502  \u2502 On ../modules/cdc/main.tf line\r\n> 233: An attribute name is required after a \u2502 dot. \u2575\r\n\r\n\r\n\r\nError messages point to the specific line where I use for_each to refer to replication_instance and source_endpoint\r\n\r\n    aws_dms_endpoint.${each.value[\"source_ep\"]}.endpoint_arn\r\n    aws_dms_replication_instance.${each.value[\"repl_instance\"]}.replication_instance_arn\r\n\r\nHow do I refer to the resources created using their names using a `for_each`. \r\n\r\nThank you.\r\n\r\n\r\n", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "279934712", "PostHistoryTypeId": "1", "PostId": "74034959", "RevisionGUID": "a89777a9-43ab-4f3b-a042-38418cb21d90", "CreationDate": "2022-10-11T23:18:41.063", "UserId": "2289031", "Text": "How to define a resource block with for_each that refers to other resources", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "279934713", "PostHistoryTypeId": "3", "PostId": "74034959", "RevisionGUID": "a89777a9-43ab-4f3b-a042-38418cb21d90", "CreationDate": "2022-10-11T23:18:41.063", "UserId": "2289031", "Text": "<terraform><terraform-provider-aws>", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "279935155", "PostHistoryTypeId": "6", "PostId": "74034959", "RevisionGUID": "e9b298a0-53aa-4c35-b0f4-cc1854e09ab2", "CreationDate": "2022-10-11T23:36:23.470", "UserId": "248823", "Comment": "edited tags", "Text": "<amazon-web-services><terraform><terraform-provider-aws>", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "answers": [{"Id": "74035033", "PostTypeId": "2", "ParentId": "74034959", "CreationDate": "2022-10-11T23:35:45.137", "Score": "1", "Body": "<blockquote>\n<p>How do I refer to the resources created using their names using a for_each.</p>\n</blockquote>\n<p>You can't do this. In other words, you can't create dynamic references to resources in the form of:</p>\n<pre><code>aws_dms_endpoint.${each.value[&quot;source_ep&quot;]}.endpoint_arn\n</code></pre>\n<p>Instead you have to use <strong>maps or lists</strong> to create your <code>aws_dms_replication_instance</code> and <code>aws_dms_endpoint</code>. For example:</p>\n<pre><code>resource &quot;aws_dms_replication_instance&quot; &quot;foobar_instance&quot; {\n  for_each = toset([&quot;foobar_instance_1&quot;, &quot;foobar_instance_2&quot;])\n}\n\nresource &quot;aws_dms_endpoint&quot; &quot;foobar_source&quot; {\n  for_each = toset([&quot;foobar_source_1&quot;, &quot;foobar_source_2&quot;])\n}\n</code></pre>\n<p>end then refer to them as follows:</p>\n<pre><code>resource &quot;aws_dms_replication_task&quot; &quot;for_each_task_1&quot; {\n    for_each                  = var.task_map\n    replication_instance_arn  = aws_dms_replication_instance.foobar_instance[each.value[&quot;repl_instance&quot;]].replication_instance_arn\n    source_endpoint_arn       = aws_dms_endpoint.foobar_source[each.value[&quot;source_ep&quot;]].endpoint_arn\n    .   \n    .\n    .\n}\n</code></pre>\n", "OwnerUserId": "248823", "LastActivityDate": "2022-10-11T23:35:45.137", "CommentCount": "0", "ContentLicense": "CC BY-SA 4.0", "history": [{"Id": "279935125", "PostHistoryTypeId": "2", "PostId": "74035033", "RevisionGUID": "a24aa1a0-25c8-4efb-a38d-3458a45fb33c", "CreationDate": "2022-10-11T23:35:45.137", "UserId": "248823", "Text": "> How do I refer to the resources created using their names using a for_each.\r\n\r\nYou can't do this. In other words, you can't create dynamic references to resources in the form of:\r\n\r\n```\r\naws_dms_endpoint.${each.value[\"source_ep\"]}.endpoint_arn\r\n```\r\n\r\nInstead you have to use **maps or lists** to create your `aws_dms_replication_instance` and `aws_dms_endpoint`. For example:\r\n\r\n\r\n```\r\nresource \"aws_dms_replication_instance\" \"foobar_instance\" {\r\n  for_each = toset([\"foobar_instance_1\", \"foobar_instance_2\"])\r\n}\r\n\r\nresource \"aws_dms_endpoint\" \"foobar_source\" {\r\n  for_each = toset([\"foobar_source_1\", \"foobar_source_2\"])\r\n}\r\n```\r\n\r\nend then refer to them as follows:\r\n\r\n```\r\nresource \"aws_dms_replication_task\" \"for_each_task_1\" {\r\n    for_each                  = var.task_map\r\n    replication_instance_arn  = aws_dms_replication_instance.foobar_instance[each.value[\"repl_instance\"]].replication_instance_arn\r\n    source_endpoint_arn       = aws_dms_endpoint.foobar_source[each.value[\"source_ep\"]].endpoint_arn\r\n    .   \r\n    .\r\n    .\r\n}\r\n```", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "filtered-sentences": []}, {"Id": "74035753", "PostTypeId": "2", "ParentId": "74034959", "CreationDate": "2022-10-12T02:08:26.860", "Score": "1", "Body": "<p>When thinking about problems like this it's important to recognize that a reference expression like <code>aws_dms_replication_instance.foobar_instance_1</code> is an indivisible unit: <code>aws_dms_replication_instance</code> alone doesn't exist as a separate data structure that you can query dynamically, because Terraform needs to be able to determine exactly which resources a particular expression depends on in order to produce the dependency graph, before evaluating any expressions.</p>\n<p>However, you <em>can</em> construct your own mapping data structure which incorporates the set of resources you are interested in:</p>\n<pre><code>locals {\n  source_endpoints = {\n    &quot;foobar_1&quot; = aws_dms_endpoint.foobar_source_1\n    &quot;foobar_2&quot; = aws_dms_endpoint.foobar_source_2\n  }\n  replication_instances = {\n    &quot;foobar_1&quot; = aws_dms_replication_instance.foobar_instance_1\n    &quot;foobar_2&quot; = aws_dms_replication_instance.foobar_instance_2\n  }\n}\n</code></pre>\n<p>You can then use <code>local.source_endpoints</code> and <code>local.replication_instances</code> as mappings to look up the keys specified by your module's caller:</p>\n<pre><code>resource &quot;aws_dms_replication_task&quot; &quot;for_each_task_1&quot; {\n  for_each = var.task_map\n\n  replication_instance_arn = local.replication_instances[each.value.repl_instance].replication_instance_arn\n  source_endpoint_arn      = local.source_endpoints[each.value.source_ep].endpoint_arn\n\n  # ...\n}\n</code></pre>\n<p>This can work because a local value is also an object that participates in the dependency graph. Terraform can see that <code>local.source_endpoints</code> depends on both <code>aws_dms_endpoint.foobar_source_1</code> and <code>aws_dms_endpoint.foobar_source_2</code>, and so therefore indirectly anything which depends on <code>local.source_endpoints</code> must effectively depend on those resources.</p>\n<hr />\n<p>Although it's not crucial to your question, I want to note that this design means that your module will declare the full set of <code>aws_dms_endpoint</code> and <code>aws_dms_replication_instance</code> objects, even if some of them don't have any <code>var.task_map</code> elements referring to them.</p>\n<p>I wouldn't worry about that if the only practical use of the module involves referring to all of them, but if that isn't true then a variant of this design is to allow the caller to also specify via input variables which endpoints and replication instances they need, and use <code>for_each</code> on all three of these resources.</p>\n<p>If you do <em>that</em> then you can avoid constructing the intermediate data structure, because <code>for_each</code> resources are already naturally maps which support the same sort of dynamic lookup:</p>\n<pre><code>resource &quot;aws_dms_replication_instance&quot; &quot;example&quot; {\n  for_each = var.replication_instances\n\n  # ...\n}\n\nresource &quot;aws_dms_endpoint&quot; &quot;example&quot; {\n  for_each = var.source_endpoints\n\n  # ...\n}\n\nresource &quot;aws_dms_replication_task&quot; &quot;for_each_task_1&quot; {\n  for_each = var.task_map\n\n  replication_instance_arn = aws_dms_replication_instance.example[each.value.repl_instance].replication_instance_arn\n  source_endpoint_arn      = aws_dms_endpoint.example[each.value.source_ep].endpoint_arn\n\n  # ...\n}\n</code></pre>\n<p>In this variant, the caller of the module controls both which replication instances and endpoints exist <em>and</em> which of those each of the tasks use, so the burden for the user of your module is greater but they also get the flexibility of not declaring objects they won't actually use, in case these objects have a significant cost.</p>\n", "OwnerUserId": "281848", "LastActivityDate": "2022-10-12T02:08:26.860", "CommentCount": "0", "ContentLicense": "CC BY-SA 4.0", "history": [{"Id": "279939094", "PostHistoryTypeId": "2", "PostId": "74035753", "RevisionGUID": "a3ec95f2-1e67-402f-abec-5d943a6464e3", "CreationDate": "2022-10-12T02:08:26.860", "UserId": "281848", "Text": "When thinking about problems like this it's important to recognize that a reference expression like `aws_dms_replication_instance.foobar_instance_1` is an indivisible unit: `aws_dms_replication_instance` alone doesn't exist as a separate data structure that you can query dynamically, because Terraform needs to be able to determine exactly which resources a particular expression depends on in order to produce the dependency graph, before evaluating any expressions.\r\n\r\nHowever, you _can_ construct your own mapping data structure which incorporates the set of resources you are interested in:\r\n\r\n```\r\nlocals {\r\n  source_endpoints = {\r\n    \"foobar_1\" = aws_dms_endpoint.foobar_source_1\r\n    \"foobar_2\" = aws_dms_endpoint.foobar_source_2\r\n  }\r\n  replication_instances = {\r\n    \"foobar_1\" = aws_dms_replication_instance.foobar_instance_1\r\n    \"foobar_2\" = aws_dms_replication_instance.foobar_instance_2\r\n  }\r\n}\r\n```\r\n\r\nYou can then use `local.source_endpoints` and `local.replication_instances` as mappings to look up the keys specified by your module's caller:\r\n\r\n```\r\nresource \"aws_dms_replication_task\" \"for_each_task_1\" {\r\n  for_each = var.task_map\r\n\r\n  replication_instance_arn = local.replication_instances[each.value.repl_instance].replication_instance_arn\r\n  source_endpoint_arn      = local.source_endpoints[each.value.source_ep].endpoint_arn\r\n\r\n  # ...\r\n}\r\n```\r\n\r\nThis can work because a local value is also an object that participates in the dependency graph. Terraform can see that `local.source_endpoints` depends on both `aws_dms_endpoint.foobar_source_1` and `aws_dms_endpoint.foobar_source_2`, and so therefore indirectly anything which depends on `local.source_endpoints` must effectively depend on those resources.\r\n\r\n---\r\n\r\nAlthough it's not crucial to your question, I want to note that this design means that your module will declare the full set of `aws_dms_endpoint` and `aws_dms_replication_instance` objects, even if some of them don't have any `var.task_map` elements referring to them.\r\n\r\nI wouldn't worry about that if the only practical use of the module involves referring to all of them, but if that isn't true then a variant of this design is to allow the caller to also specify via input variables which endpoints and replication instances they need, and use `for_each` on all three of these resources.\r\n\r\nIf you do _that_ then you can avoid constructing the intermediate data structure, because `for_each` resources are already naturally maps which support the same sort of dynamic lookup:\r\n\r\n```\r\nresource \"aws_dms_replication_instance\" \"example\" {\r\n  for_each = var.replication_instances\r\n\r\n  # ...\r\n}\r\n\r\nresource \"aws_dms_endpoint\" \"example\" {\r\n  for_each = var.source_endpoints\r\n\r\n  # ...\r\n}\r\n\r\nresource \"aws_dms_replication_task\" \"for_each_task_1\" {\r\n  for_each = var.task_map\r\n\r\n  replication_instance_arn = aws_dms_replication_instance.example[each.value.repl_instance].replication_instance_arn\r\n  source_endpoint_arn      = aws_dms_endpoint.example[each.value.source_ep].endpoint_arn\r\n\r\n  # ...\r\n}\r\n```\r\n\r\nIn this variant, the caller of the module controls both which replication instances and endpoints exist _and_ which of those each of the tasks use, so the burden for the user of your module is greater but they also get the flexibility of not declaring objects they won't actually use, in case these objects have a significant cost.\r\n", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "In this variant, the caller of the module controls both which replication instances and endpoints exist _and_ which of those each of the tasks use, so the burden for the user of your module is greater but they also get the flexibility of not declaring objects they won't actually use, in case these objects have a significant cost.", "keywords": ["cost"]}]}], "filtered-sentences": [{"source": "Body", "text": "In this variant, the caller of the module controls both which replication instances and endpoints exist and which of those each of the tasks use, so the burden for the user of your module is greater but they also get the flexibility of not declaring objects they won't actually use, in case these objects have a significant cost.", "keywords": ["cost"]}]}], "contains-topic": true, "filtered-sentences": []}