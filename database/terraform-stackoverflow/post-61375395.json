{"Id": "61375395", "PostTypeId": "1", "CreationDate": "2020-04-22T21:27:52.160", "Score": "0", "ViewCount": "1881", "Body": "<p>I am trying to use regex to match terraform module and add a comment to the beginning of the line. I am not able to use regex for the module block only. Note that some lines do repeat on other blocks like resource. The idea is to scan for module block and comment it. Any help will be greatly appreciated. Spent a lot of time bouncing ideas... </p>\n\n<pre><code>module my module {\nname = myaws\nversion = 1.0\nsource = terraform.mycompany.com\ntag = { cost = poc }\n}\n\ndata \"my file\" \"file-name-creation-data\" {\n  template = file(\"path/file.json\")\n}\n\nresource aws_iam_role_policy \"my-role\" {\n name = \"first-policy\"\n role = new role.rolename\n tag = { cost = pic }\n}\n</code></pre>\n", "OwnerUserId": "12875564", "LastActivityDate": "2020-04-23T22:12:59.643", "Title": "Regex pattern to match terraform module code", "Tags": "<python><regex><terraform><multiline>", "AnswerCount": "1", "CommentCount": "0", "ContentLicense": "CC BY-SA 4.0", "history": [{"Id": "219875913", "PostHistoryTypeId": "2", "PostId": "61375395", "RevisionGUID": "a2167ea2-c715-41df-981a-1886ace51be2", "CreationDate": "2020-04-22T21:27:52.160", "UserId": "12875564", "Text": "I am trying to use regex to match terraform module and add a comment to the beginning of the line. I am not able to use regex for the module block only. Note that some lines do repeat on other blocks like resource. The idea is to scan for module block and comment it. Any help will be greatly appreciated. Spent a lot of time bouncing ideas... \r\n\r\n\r\n    module my module {\r\n    name = myaws\r\n    version = 1.0\r\n    source = terraform.mycompany.com\r\n    tag = { cost = poc }\r\n    }\r\n    \r\n    data \"my file\" \"file-name-creation-data\" {\r\n      template = file(\"path/file.json\")\r\n    }\r\n    \r\n    resource aws_iam_role_policy \"my-role\" {\r\n     name = \"first-policy\"\r\n     role = new role.rolename\r\n     tag = { cost = pic }\r\n    }\r\n\r\n", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "module my module { name = myaws version = 1.0 source = terraform.mycompany.com tag = { cost = poc } } data \"my file\" \"file-name-creation-data\" { template = file(\"path/file.json\") } resource aws_iam_role_policy \"my-role\" { name = \"first-policy\" role = new role.rolename tag = { cost = pic } }", "keywords": ["cost", "policy"]}]}, {"Id": "219875914", "PostHistoryTypeId": "1", "PostId": "61375395", "RevisionGUID": "a2167ea2-c715-41df-981a-1886ace51be2", "CreationDate": "2020-04-22T21:27:52.160", "UserId": "12875564", "Text": "Regex pattern to match terraform module code", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "219875915", "PostHistoryTypeId": "3", "PostId": "61375395", "RevisionGUID": "a2167ea2-c715-41df-981a-1886ace51be2", "CreationDate": "2020-04-22T21:27:52.160", "UserId": "12875564", "Text": "<python><regex><terraform><multiline>", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "answers": [{"Id": "61397882", "PostTypeId": "2", "ParentId": "61375395", "CreationDate": "2020-04-23T22:12:59.643", "Score": "0", "Body": "<p>The Terraform language is not a <a href=\"https://en.wikipedia.org/wiki/Regular_language\" rel=\"nofollow noreferrer\">regular language</a> and so there is no fully-general way to process it with regular expressions.</p>\n\n<p>However, the language has some constraints on its block syntax that mean you can potentially write a \"good enough\" heuristic that will deal with most cases (but still not all). Here are some useful facts about the Terraform language that can help constrain the problem a little:</p>\n\n<ul>\n<li><p>The opening of a block must always appear all on the same line, including the opening brace. It's not valid to include additional newlines between the <code>module</code> keyword and the <code>{</code> brace.</p></li>\n<li><p>There are two ways to write a block:</p>\n\n<ul>\n<li>Normal layout is for the header to be on a line of its own, ending with the opening brace that introduces the block body: <code>{</code>.</li>\n<li>The compact single-line layout has the entire block on one line, with a single argument inside like <code>module \"foo\" { source = \"./bar\" }</code>.</li>\n</ul></li>\n<li><p>The closing brace for a block in normal layout is always on a line of its own.</p></li>\n</ul>\n\n<p>There are some not-so-convenient facts too, of course:</p>\n\n<ul>\n<li><p>Terraform also uses braces for its object constructor expressions, so naively hunting for opening and closing braces will find both block boundaries and object constructor boundaries.</p></li>\n<li><p>The string template syntax uses <code>${</code> or <code>%{</code> as its opening delimiters, but it uses <code>}</code> as its closing delimiters, adding a third meaning of a closing brace.</p></li>\n<li><p>The \"heredoc\" syntax escapes from the normal parsing rules and means that arbitrary numbers of braces (that do not need to be balanced) can appear. But they always start with a <code>&lt;&lt;</code> or <code>&lt;&lt;-</code> followed by an identifier at the end of a line and then end with that same identifier on a line of its own.</p></li>\n</ul>\n\n<p>With all of that said, if you have control over the input and can ensure it will not include \"edge cases\" like comments in the middle of block headers, heredoc sequences containing what looks like a module block, etc then you may be able to get a \"good enough\" result by processing the input on a line-by-line basis:</p>\n\n<ul>\n<li>Let B = 0</li>\n<li>For each line in the input:\n\n<ul>\n<li>If B is zero:</li>\n<li>If the line matches <code>^module [\"\\w- ]*{</code> then take whatever action you want to take for a module block.</li>\n<li>For each character in the line:</li>\n<li>If character is <code>{</code> then increment B</li>\n<li>If character is <code>}</code> then decrement B</li>\n</ul></li>\n</ul>\n\n<p>This uses a naive brace-counting approach to approximate finding the boundaries of blocks. It will fail if the input contains literal string (either quoted or heredoc) with unbalanced braces inside it, so you might try to improve on that by counting open/close quote and heredoc marker pairs too.</p>\n\n<p>Anything short of a full parser for the language will always have some edge-case it can't handle, but if you can constrain your input to not include any situation that your simpler ruleset can't understand then an approach like the above might work for you.</p>\n\n<hr>\n\n<p>If you were willing to write your program in Go then you'd be able to use the <a href=\"https://pkg.go.dev/github.com/hashicorp/hcl/v2/hclwrite\" rel=\"nofollow noreferrer\"><code>hclwrite</code></a> package which is a part of the underlying library Terraform uses to implement its language syntax. It has a full parser and allows making \"surgical\" edits to what it reads, though at the time I write this it doesn't seem to have functions for adding comments to blocks in particular so it's not currently ready to solve your specific goal here.</p>\n\n<p>It might be useful to others who find this question in future that have other goals related to modifying existing Terraform configurations, and it may get additional functionality to support other use-cases in the future.</p>\n", "OwnerUserId": "281848", "LastActivityDate": "2020-04-23T22:12:59.643", "CommentCount": "2", "ContentLicense": "CC BY-SA 4.0", "comments": [{"Id": "108614782", "PostId": "61397882", "Score": "0", "Text": "Martin,\nThanks a lot for the thoughtful post. Unfortunately I am in the edge case where in the terraform file there will be resource blocks with here docs as well as module blocks with here docs. I have to only comment the module blocks as I am converting module to resources. \n\nThat is where the problem comes. I have to scan the file, replace module blocks with resource blocks by converting module blocks to resource blocks, write them in the terraform file and then go back find the module blocks and comment them. This is where I get stuck.\nThanks.!", "CreationDate": "2020-04-23T22:32:22.940", "UserId": "12875564", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "108614942", "PostId": "61397882", "Score": "1", "Text": "That set of requirements doesn't seem achievable using regular expressions. To do those steps robustly will require a full parser for the [the underlying grammar](https://github.com/hashicorp/hcl/blob/hcl2/hclsyntax/spec.md). I think it may be best to look for other ways to meet your underlying goal that do not involve making surgical changes to existing configuration files.", "CreationDate": "2020-04-23T22:39:45.003", "UserId": "281848", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "I think it may be best to look for other ways to meet your underlying goal that do not involve making surgical changes to existing configuration files.", "keywords": ["change"]}]}], "history": [{"Id": "219967912", "PostHistoryTypeId": "2", "PostId": "61397882", "RevisionGUID": "140e4115-271d-421c-8a16-2c085c44887c", "CreationDate": "2020-04-23T22:12:59.643", "UserId": "281848", "Text": "The Terraform language is not a [regular language](https://en.wikipedia.org/wiki/Regular_language) and so there is no fully-general way to process it with regular expressions.\r\n\r\nHowever, the language has some constraints on its block syntax that mean you can potentially write a \"good enough\" heuristic that will deal with most cases (but still not all). Here are some useful facts about the Terraform language that can help constrain the problem a little:\r\n\r\n* The opening of a block must always appear all on the same line, including the opening brace. It's not valid to include additional newlines between the `module` keyword and the `{` brace.\r\n\r\n* There are two ways to write a block:\r\n\r\n  - Normal layout is for the header to be on a line of its own, ending with the opening brace that introduces the block body: `{`.\r\n  - The compact single-line layout has the entire block on one line, with a single argument inside like `module \"foo\" { source = \"./bar\" }`.\r\n\r\n* The closing brace for a block in normal layout is always on a line of its own.\r\n\r\nThere are some not-so-convenient facts too, of course:\r\n\r\n* Terraform also uses braces for its object constructor expressions, so naively hunting for opening and closing braces will find both block boundaries and object constructor boundaries.\r\n\r\n* The string template syntax uses `${` or `%{` as its opening delimiters, but it uses `}` as its closing delimiters, adding a third meaning of a closing brace.\r\n\r\n* The \"heredoc\" syntax escapes from the normal parsing rules and means that arbitrary numbers of braces (that do not need to be balanced) can appear. But they always start with a `<<` or `<<-` followed by an identifier at the end of a line and then end with that same identifier on a line of its own.\r\n\r\nWith all of that said, if you have control over the input and can ensure it will not include \"edge cases\" like comments in the middle of block headers, heredoc sequences containing what looks like a module block, etc then you may be able to get a \"good enough\" result by processing the input on a line-by-line basis:\r\n\r\n- Let B = 0\r\n- For each line in the input:\r\n  - If B is zero:\r\n    - If the line matches `^module [\"\\w- ]*{` then take whatever action you want to take for a module block.\r\n  - For each character in the line:\r\n    - If character is `{` then increment B\r\n    - If character is `}` then decrement B\r\n\r\nThis uses a naive brace-counting approach to approximate finding the boundaries of blocks. It will fail if the input contains literal string (either quoted or heredoc) with unbalanced braces inside it, so you might try to improve on that by counting open/close quote and heredoc marker pairs too.\r\n\r\nAnything short of a full parser for the language will always have some edge-case it can't handle, but if you can constrain your input to not include any situation that your simpler ruleset can't understand then an approach like the above might work for you.\r\n\r\n---\r\n\r\nIf you were willing to write your program in Go then you'd be able to use the [`hclwrite`](https://pkg.go.dev/github.com/hashicorp/hcl/v2/hclwrite) package which is a part of the underlying library Terraform uses to implement its language syntax. It has a full parser and allows making \"surgical\" edits to what it reads, though at the time I write this it doesn't seem to have functions for adding comments to blocks in particular so it's not currently ready to solve your specific goal here.\r\n\r\nIt might be useful to others who find this question in future that have other goals related to modifying existing Terraform configurations, and it may get additional functionality to support other use-cases in the future.\r\n", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "filtered-sentences": []}], "contains-topic": true, "filtered-sentences": []}