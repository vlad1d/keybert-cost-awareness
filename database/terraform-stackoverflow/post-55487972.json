{"Id": "55487972", "PostTypeId": "1", "AcceptedAnswerId": "57995310", "CreationDate": "2019-04-03T05:55:07.690", "Score": "7", "ViewCount": "20054", "Body": "<p>Consider I have a variable that is a list of list of maps.</p>\n\n<p>Example: </p>\n\n<pre><code>    processes = [\n      [\n       {start_cmd: \"a-server-start\", attribute2:\"type_a\"}, \n       {start_cmd: \"a-worker-start\", attribute2:\"type_b\"}\n       {start_cmd: \"a--different-worker-start\", attribute2:\"type_c\"}\n      ],\n      [\n       {start_cmd: \"b-server-start\", attribute2:\"type_a\"},\n       {start_cmd: \"b-worker-start\", attribute2:\"type_b\"}\n      ]\n    ]\n</code></pre>\n\n<p>In each iteration, I need to take out the array of maps, then iterate over that array and take out the values of the map. How do I achieve this in terraform?</p>\n\n<p>I have considered having two counts and doing some arithmetic to trick terraform into performing a lookalike nested iteration <a href=\"https://serverfault.com/questions/833810/terraform-use-nested-loops-with-count\">Check reference here</a>. But in our case the number of maps in the inner array can vary. </p>\n\n<p>Also we are currently using the 0.11 terraform version but dont mind using the alpha 0.12 version of terraform if it is possible to achieve this in that version.</p>\n\n<p>Edit:</p>\n\n<p>Added how I would use this variable:</p>\n\n<pre><code>resource \u201ccreate_application\u201d \u201capplications\u201d {\n  // Create a resource for every array in the variable processes. 2 in this case\n  name        = \"\"              \n  migration_command = \"\" \n\n  proc {                \n    // For every map create this attribute for the resource.\n    name    = \u201c\u201c                \n    init_command   = \u201ca-server-start\u201d                   \n    type   = \u201cserver\u201d                \n  }                                    \n}                                      \n</code></pre>\n\n<p>Not sure if this clears up the requirement. Please do ask if it is still not clear.</p>\n", "OwnerUserId": "4983469", "LastEditorUserId": "4983469", "LastEditDate": "2019-04-03T09:30:37.583", "LastActivityDate": "2022-10-03T09:02:45.583", "Title": "Iterate over list of list of maps in terraform", "Tags": "<nested><iteration><terraform>", "AnswerCount": "2", "CommentCount": "4", "FavoriteCount": "0", "ContentLicense": "CC BY-SA 4.0", "comments": [{"Id": "97685586", "PostId": "55487972", "Score": "2", "Text": "What output are you wanting to see here?", "CreationDate": "2019-04-03T06:56:17.827", "UserId": "2291321", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "97690767", "PostId": "55487972", "Score": "0", "Text": "I have added an edit to address this question", "CreationDate": "2019-04-03T09:30:54.680", "UserId": "4983469", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "97698525", "PostId": "55487972", "Score": "0", "Text": "If I recall correctly from release notes, this is being included in 0.12 for the first time.", "CreationDate": "2019-04-03T12:55:40.787", "UserId": "5343387", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "97701097", "PostId": "55487972", "Score": "0", "Text": "We had a look at the 0.12-beta veriosn, but couldn't figure out a way to do it. If it is possible can you show a working way of doing nested iterations using the 0.12 beta version?", "CreationDate": "2019-04-03T14:01:48.050", "UserId": "4983469", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "history": [{"Id": "194987572", "PostHistoryTypeId": "2", "PostId": "55487972", "RevisionGUID": "88010473-5d77-499c-8bec-68950407caca", "CreationDate": "2019-04-03T05:55:07.690", "UserId": "4983469", "Text": "Consider I have a variable that is a list of list of maps.\r\n\r\nExample: \r\n\r\n        processes = [\r\n          [\r\n           {start_cmd: \"a-server-start\", attribute2:\"type_a\"}, \r\n           {start_cmd: \"a-worker-start\", attribute2:\"type_b\"}\r\n           {start_cmd: \"a--different-worker-start\", attribute2:\"type_c\"}\r\n          ],\r\n          [\r\n           {start_cmd: \"b-server-start\", attribute2:\"type_a\"},\r\n           {start_cmd: \"b-worker-start\", attribute2:\"type_b\"}\r\n          ]\r\n        ]\r\n\r\nIn each iteration, I need to take out the array of maps, then iterate over that array and take out the values of the map. How do I achieve this in terraform?\r\n\r\nI have considered having two counts and doing some arithmetic to trick terraform into performing a lookalike nested iteration [Check reference here][1]. But in our case the number of maps in the inner array can vary. \r\n\r\nAlso we are currently using the 0.11 terraform version but dont mind using the alpha 0.12 version of terraform if it is possible to achieve this in that version.\r\n\r\n\r\n  [1]: https://serverfault.com/questions/833810/terraform-use-nested-loops-with-count", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "194987573", "PostHistoryTypeId": "1", "PostId": "55487972", "RevisionGUID": "88010473-5d77-499c-8bec-68950407caca", "CreationDate": "2019-04-03T05:55:07.690", "UserId": "4983469", "Text": "Iterate over list of list of maps in terraform", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "194987574", "PostHistoryTypeId": "3", "PostId": "55487972", "RevisionGUID": "88010473-5d77-499c-8bec-68950407caca", "CreationDate": "2019-04-03T05:55:07.690", "UserId": "4983469", "Text": "<nested><iteration><terraform>", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "195002868", "PostHistoryTypeId": "5", "PostId": "55487972", "RevisionGUID": "37f37994-e1ba-4193-ad2c-65000692d3da", "CreationDate": "2019-04-03T09:30:37.583", "UserId": "4983469", "Comment": "Added how I would use this variable", "Text": "Consider I have a variable that is a list of list of maps.\r\n\r\nExample: \r\n\r\n        processes = [\r\n          [\r\n           {start_cmd: \"a-server-start\", attribute2:\"type_a\"}, \r\n           {start_cmd: \"a-worker-start\", attribute2:\"type_b\"}\r\n           {start_cmd: \"a--different-worker-start\", attribute2:\"type_c\"}\r\n          ],\r\n          [\r\n           {start_cmd: \"b-server-start\", attribute2:\"type_a\"},\r\n           {start_cmd: \"b-worker-start\", attribute2:\"type_b\"}\r\n          ]\r\n        ]\r\n\r\nIn each iteration, I need to take out the array of maps, then iterate over that array and take out the values of the map. How do I achieve this in terraform?\r\n\r\nI have considered having two counts and doing some arithmetic to trick terraform into performing a lookalike nested iteration [Check reference here][1]. But in our case the number of maps in the inner array can vary. \r\n\r\nAlso we are currently using the 0.11 terraform version but dont mind using the alpha 0.12 version of terraform if it is possible to achieve this in that version.\r\n\r\n\r\nEdit:\r\n\r\nAdded how I would use this variable:\r\n\r\n    resource \u201ccreate_application\u201d \u201capplications\u201d {\r\n      // Create a resource for every array in the variable processes. 2 in this case\r\n      name        = \"\"              \r\n      migration_command = \"\" \r\n    \r\n      proc {                \r\n        // For every map create this attribute for the resource.\r\n        name    = \u201c\u201c                \r\n        init_command   = \u201ca-server-start\u201d                   \r\n        type   = \u201cserver\u201d                \r\n      }                                    \r\n    }                                      \r\n\r\nNot sure if this clears up the requirement. Please do ask if it is still not clear.\r\n  [1]: https://serverfault.com/questions/833810/terraform-use-nested-loops-with-count\r\n", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "answers": [{"Id": "57995310", "PostTypeId": "2", "ParentId": "55487972", "CreationDate": "2019-09-18T14:35:41.083", "Score": "3", "Body": "<p>Using terraform 0.12.x</p>\n\n<pre class=\"lang-tf prettyprint-override\"><code>locals {\n  processes = [\n    [\n      { start_cmd: \"a-server-start\", type: \"type_a\", name: \"inglorious bastards\" },\n      { start_cmd: \"a-worker-start\", type: \"type_b\", name: \"kill bill\" },\n      { start_cmd: \"a--different-worker-start\", type: \"type_c\", name: \"pulp fiction\" },\n    ],\n    [\n      { start_cmd: \"b-server-start\", type: \"type_a\", name: \"inglorious bastards\" },\n      { start_cmd: \"b-worker-start\", type: \"type_b\", name: \"kill bill\" },\n    ]\n  ]\n}\n\n# just an example\ndata \"archive_file\" \"applications\" {\n  count = length(local.processes)\n\n  type = \"zip\"\n\n  output_path = \"applications.zip\"\n\n  dynamic \"source\" {\n    for_each = local.processes[count.index]\n\n    content {\n      content  = source.value.type\n      filename = source.value.name\n    }\n  }\n}\n</code></pre>\n\n<pre class=\"lang-sh prettyprint-override\"><code>$ terraform apply\ndata.archive_file.applications[0]: Refreshing state...\ndata.archive_file.applications[1]: Refreshing state...\n\nApply complete! Resources: 0 added, 0 changed, 0 destroyed.\n</code></pre>\n\n<p>If a <code>create_application</code> resource existed, it can be modeled like so</p>\n\n<pre class=\"lang-tf prettyprint-override\"><code>resource \"create_application\" \"applications\" {\n  count             = length(local.processes)\n  name              = \"\"\n  migration_command = \"\" \n\n  dynamic \"proc\" {\n    for_each = local.processes[count.index]\n\n    content {\n      name         = proc.value.name\n      init_command = proc.value.start_cmd\n      type         = proc.value.type\n    }\n  }\n}\n</code></pre>\n", "OwnerUserId": "2965993", "LastEditorUserId": "2965993", "LastEditDate": "2020-04-13T13:51:34.180", "LastActivityDate": "2020-04-13T13:51:34.180", "CommentCount": "0", "ContentLicense": "CC BY-SA 4.0", "history": [{"Id": "205596297", "PostHistoryTypeId": "2", "PostId": "57995310", "RevisionGUID": "ee6b35d9-a904-4dde-9327-c7d632f7abf4", "CreationDate": "2019-09-18T14:35:41.083", "UserId": "2965993", "Text": "Using terraform 0.12.x\r\n\r\n```terraform\r\nlocals {\r\n  processes = [\r\n    { start_cmd: \"a-server-start\", attribute2: \"type_a\", name: \"inglorious bastards\" },\r\n    { start_cmd: \"a-worker-start\", attribute2: \"type_b\", name: \"kill bill\" },\r\n    { start_cmd: \"a--different-worker-start\", attribute2: \"type_c\", name: \"pulp fiction\" },\r\n  ]\r\n}\r\n\r\noutput \"start_cmds\" {\r\n  value = [\r\n    for process in local.processes:\r\n      process.start_cmd\r\n  ]\r\n}\r\n\r\noutput \"attribute2s\" {\r\n  value = [\r\n    for process in local.processes:\r\n      process.attribute2\r\n  ]\r\n}\r\n\r\noutput \"names\" {\r\n  value = [\r\n    for process in local.processes:\r\n      process.name\r\n  ]\r\n}\r\n```\r\n\r\nThe apply then results in this\r\n\r\n```bash\r\n$ terraform apply\r\n\r\nApply complete! Resources: 0 added, 0 changed, 0 destroyed.\r\n\r\nOutputs:\r\n\r\nattribute2s = [\r\n  \"type_a\",\r\n  \"type_b\",\r\n  \"type_c\",\r\n]\r\nnames = [\r\n  \"inglorious bastards\",\r\n  \"kill bill\",\r\n  \"pulp fiction\",\r\n]\r\nstart_cmds = [\r\n  \"a-server-start\",\r\n  \"a-worker-start\",\r\n  \"a--different-worker-start\",\r\n]\r\n```\r\n\r\nso if there was a `create_application` resource, it can be modeled like so\r\n\r\n```terraform\r\nresource \"create_application\" \"applications\" {\r\n  count             = length(local.processes)\r\n  name              = local.processes.name[count.index]\r\n  migration_command = \"\" \r\n\r\n  proc {\r\n    name           = local.processes.name[count.index]\r\n    init_command   = local.processes.start_cmd[count.index]\r\n    type           = local.processes.attribute2[count.index]\r\n  }\r\n}\r\n``` ", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "Using terraform 0.12.x ```terraform locals { processes = [ { start_cmd: \"a-server-start\", attribute2: \"type_a\", name: \"inglorious bastards\" }, { start_cmd: \"a-worker-start\", attribute2: \"type_b\", name: \"kill bill\" }, { start_cmd: \"a--different-worker-start\", attribute2: \"type_c\", name: \"pulp fiction\" }, ] } output \"start_cmds\" { value = [ for process in local.processes: process.start_cmd ] } output \"attribute2s\" { value = [ for process in local.processes: process.attribute2 ] } output \"names\" { value = [ for process in local.processes: process.name ] } ``` The apply then results in this ```bash $ terraform apply Apply complete! Resources: 0 added, 0 changed, 0 destroyed. ", "keywords": ["bill", "change"]}, {"source": "Text", "text": "Outputs: attribute2s = [ \"type_a\", \"type_b\", \"type_c\", ] names = [ \"inglorious bastards\", \"kill bill\", \"pulp fiction\", ] start_cmds = [ \"a-server-start\", \"a-worker-start\", \"a--different-worker-start\", ] ``` so if there was a `create_application` resource, it can be modeled like so ```terraform resource \"create_application\" \"applications\" { count = length(local.processes) name = local.processes.name[count.index] migration_command = \"\" proc { name = local.processes.name[count.index] init_command = local.processes.start_cmd[count.index] type = local.processes.attribute2[count.index] } ", "keywords": ["bill"]}]}, {"Id": "205597437", "PostHistoryTypeId": "5", "PostId": "57995310", "RevisionGUID": "036c6f1f-8520-4cc1-8688-2f64fe59bce4", "CreationDate": "2019-09-18T14:50:28.360", "UserId": "2965993", "Comment": "fixes", "Text": "Using terraform 0.12.x\r\n\r\n```terraform\r\nlocals {\r\n  processes = [\r\n    [\r\n      { start_cmd: \"a-server-start\", type: \"type_a\", name: \"inglorious bastards\" },\r\n      { start_cmd: \"a-worker-start\", type: \"type_b\", name: \"kill bill\" },\r\n      { start_cmd: \"a--different-worker-start\", type: \"type_c\", name: \"pulp fiction\" },\r\n    ],\r\n    [\r\n      { start_cmd: \"b-server-start\", type: \"type_a\", name: \"inglorious bastards\" },\r\n      { start_cmd: \"b-worker-start\", type: \"type_b\", name: \"kill bill\" },\r\n    ]\r\n  ]\r\n}\r\n\r\noutput \"start_cmds\" {\r\n  value = [\r\n    for process in local.processes: [\r\n      for worker in process:\r\n        worker.start_cmd\r\n    ]\r\n  ]\r\n}\r\n\r\noutput \"types\" {\r\n  value = [\r\n    for process in local.processes: [\r\n      for worker in process:\r\n        worker.type\r\n    ]\r\n  ]\r\n}\r\n\r\noutput \"names\" {\r\n  value = [\r\n    for process in local.processes: [\r\n      for worker in process:\r\n        worker.name\r\n    ]\r\n  ]\r\n}\r\n```\r\n\r\n```bash\r\n$ terraform apply\r\n\r\nApply complete! Resources: 0 added, 0 changed, 0 destroyed.\r\n\r\nOutputs:\r\n\r\nnames = [\r\n  [\r\n    \"inglorious bastards\",\r\n    \"kill bill\",\r\n    \"pulp fiction\",\r\n  ],\r\n  [\r\n    \"inglorious bastards\",\r\n    \"kill bill\",\r\n  ],\r\n]\r\nstart_cmds = [\r\n  [\r\n    \"a-server-start\",\r\n    \"a-worker-start\",\r\n    \"a--different-worker-start\",\r\n  ],\r\n  [\r\n    \"b-server-start\",\r\n    \"b-worker-start\",\r\n  ],\r\n]\r\ntypes = [\r\n  [\r\n    \"type_a\",\r\n    \"type_b\",\r\n    \"type_c\",\r\n  ],\r\n  [\r\n    \"type_a\",\r\n    \"type_b\",\r\n  ],\r\n]\r\n```\r\n\r\nso if there was a `create_application` resource, it can be modeled like so\r\n\r\n```terraform\r\nresource \"create_application\" \"applications\" {\r\n  count             = length(local.processes)\r\n  name              = \"\"\r\n  migration_command = \"\" \r\n\r\n  dynamic \"proc\" {\r\n    for_each = local.processes[count.index]\r\n \r\n    content {\r\n      name         = proc.name\r\n      init_command = proc.start_cmd\r\n      type         = proc.type\r\n    }\r\n  }\r\n}\r\n``` ", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "Using terraform 0.12.x ```terraform locals { processes = [ [ { start_cmd: \"a-server-start\", type: \"type_a\", name: \"inglorious bastards\" }, { start_cmd: \"a-worker-start\", type: \"type_b\", name: \"kill bill\" }, { start_cmd: \"a--different-worker-start\", type: \"type_c\", name: \"pulp fiction\" }, ], [ { start_cmd: \"b-server-start\", type: \"type_a\", name: \"inglorious bastards\" }, { start_cmd: \"b-worker-start\", type: \"type_b\", name: \"kill bill\" }, ] ] } output \"start_cmds\" { value = [ for process in local.processes: [ for worker in process: worker.start_cmd ] ] } output \"types\" { value = [ for process in local.processes: [ for worker in process: worker.type ] ] } output \"names\" { value = [ for process in local.processes: [ for worker in process: worker.name ] ] } ``` ```bash $ terraform apply Apply complete! Resources: 0 added, 0 changed, 0 destroyed. ", "keywords": ["bill", "change"]}, {"source": "Text", "text": "Outputs: names = [ [ \"inglorious bastards\", \"kill bill\", \"pulp fiction\", ], [ \"inglorious bastards\", \"kill bill\", ], ] start_cmds = [ [ \"a-server-start\", \"a-worker-start\", \"a--different-worker-start\", ], [ \"b-server-start\", \"b-worker-start\", ], ] types = [ [ \"type_a\", \"type_b\", \"type_c\", ], [ \"type_a\", \"type_b\", ], ] ``` so if there was a `create_application` resource, it can be modeled like so ```terraform resource \"create_application\" \"applications\" { count = length(local.processes) name = \"\" migration_command = \"\" dynamic \"proc\" { for_each = local.processes[count.index] content { name = proc.name init_command = proc.start_cmd type = proc.type } ", "keywords": ["bill"]}]}, {"Id": "205598937", "PostHistoryTypeId": "5", "PostId": "57995310", "RevisionGUID": "a5b94c6d-6ff4-41d6-a26a-74c271cba00e", "CreationDate": "2019-09-18T15:10:46.983", "UserId": "2965993", "Comment": "used archive_file since create_application doesnt exist", "Text": "Using terraform 0.12.x\r\n\r\n```terraform\r\nlocals {\r\n  processes = [\r\n    [\r\n      { start_cmd: \"a-server-start\", type: \"type_a\", name: \"inglorious bastards\" },\r\n      { start_cmd: \"a-worker-start\", type: \"type_b\", name: \"kill bill\" },\r\n      { start_cmd: \"a--different-worker-start\", type: \"type_c\", name: \"pulp fiction\" },\r\n    ],\r\n    [\r\n      { start_cmd: \"b-server-start\", type: \"type_a\", name: \"inglorious bastards\" },\r\n      { start_cmd: \"b-worker-start\", type: \"type_b\", name: \"kill bill\" },\r\n    ]\r\n  ]\r\n}\r\n\r\n# just an example\r\ndata \"archive_file\" \"applications\" {\r\n  count = length(local.processes)\r\n\r\n  type = \"zip\"\r\n\r\n  output_path = \"applications.zip\"\r\n\r\n  dynamic \"source\" {\r\n    for_each = local.processes[count.index]\r\n\r\n    content {\r\n      content  = source.value.type\r\n      filename = source.value.name\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n```bash\r\n$ terraform apply\r\ndata.archive_file.applications[0]: Refreshing state...\r\ndata.archive_file.applications[1]: Refreshing state...\r\n\r\nApply complete! Resources: 0 added, 0 changed, 0 destroyed.\r\n```\r\n\r\nIf a `create_application` resource existed, it can be modeled like so\r\n\r\n```terraform\r\nresource \"create_application\" \"applications\" {\r\n  count             = length(local.processes)\r\n  name              = \"\"\r\n  migration_command = \"\" \r\n\r\n  dynamic \"proc\" {\r\n    for_each = local.processes[count.index]\r\n \r\n    content {\r\n      name         = proc.value.name\r\n      init_command = proc.value.start_cmd\r\n      type         = proc.value.type\r\n    }\r\n  }\r\n}\r\n```", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "Using terraform 0.12.x ```terraform locals { processes = [ [ { start_cmd: \"a-server-start\", type: \"type_a\", name: \"inglorious bastards\" }, { start_cmd: \"a-worker-start\", type: \"type_b\", name: \"kill bill\" }, { start_cmd: \"a--different-worker-start\", type: \"type_c\", name: \"pulp fiction\" }, ], [ { start_cmd: \"b-server-start\", type: \"type_a\", name: \"inglorious bastards\" }, { start_cmd: \"b-worker-start\", type: \"type_b\", name: \"kill bill\" }, ] ] } # just an example data \"archive_file\" \"applications\" { count = length(local.processes) type = \"zip\" output_path = \"applications.zip\" dynamic \"source\" { for_each = local.processes[count.index] content { content = source.value.type filename = source.value.name } } } ``` ```bash $ terraform apply data.archive_file.applications[0]: Refreshing state... data.archive_file.applications[1]: Refreshing state... ", "keywords": ["bill"]}, {"source": "Text", "text": "Apply complete! Resources: 0 added, 0 changed, 0 destroyed. ", "keywords": ["change"]}]}, {"Id": "219097044", "PostHistoryTypeId": "5", "PostId": "57995310", "RevisionGUID": "6382f605-e166-4e16-accb-348bfa57ddb4", "CreationDate": "2020-04-13T13:51:34.180", "UserId": "2965993", "Comment": "deleted 4 characters in body", "Text": "Using terraform 0.12.x\r\n\r\n```lang-tf\r\nlocals {\r\n  processes = [\r\n    [\r\n      { start_cmd: \"a-server-start\", type: \"type_a\", name: \"inglorious bastards\" },\r\n      { start_cmd: \"a-worker-start\", type: \"type_b\", name: \"kill bill\" },\r\n      { start_cmd: \"a--different-worker-start\", type: \"type_c\", name: \"pulp fiction\" },\r\n    ],\r\n    [\r\n      { start_cmd: \"b-server-start\", type: \"type_a\", name: \"inglorious bastards\" },\r\n      { start_cmd: \"b-worker-start\", type: \"type_b\", name: \"kill bill\" },\r\n    ]\r\n  ]\r\n}\r\n\r\n# just an example\r\ndata \"archive_file\" \"applications\" {\r\n  count = length(local.processes)\r\n\r\n  type = \"zip\"\r\n\r\n  output_path = \"applications.zip\"\r\n\r\n  dynamic \"source\" {\r\n    for_each = local.processes[count.index]\r\n\r\n    content {\r\n      content  = source.value.type\r\n      filename = source.value.name\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n```bash\r\n$ terraform apply\r\ndata.archive_file.applications[0]: Refreshing state...\r\ndata.archive_file.applications[1]: Refreshing state...\r\n\r\nApply complete! Resources: 0 added, 0 changed, 0 destroyed.\r\n```\r\n\r\nIf a `create_application` resource existed, it can be modeled like so\r\n\r\n```lang-tf\r\nresource \"create_application\" \"applications\" {\r\n  count             = length(local.processes)\r\n  name              = \"\"\r\n  migration_command = \"\" \r\n\r\n  dynamic \"proc\" {\r\n    for_each = local.processes[count.index]\r\n \r\n    content {\r\n      name         = proc.value.name\r\n      init_command = proc.value.start_cmd\r\n      type         = proc.value.type\r\n    }\r\n  }\r\n}\r\n```", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "Using terraform 0.12.x ```lang-tf locals { processes = [ [ { start_cmd: \"a-server-start\", type: \"type_a\", name: \"inglorious bastards\" }, { start_cmd: \"a-worker-start\", type: \"type_b\", name: \"kill bill\" }, { start_cmd: \"a--different-worker-start\", type: \"type_c\", name: \"pulp fiction\" }, ], [ { start_cmd: \"b-server-start\", type: \"type_a\", name: \"inglorious bastards\" }, { start_cmd: \"b-worker-start\", type: \"type_b\", name: \"kill bill\" }, ] ] } # just an example data \"archive_file\" \"applications\" { count = length(local.processes) type = \"zip\" output_path = \"applications.zip\" dynamic \"source\" { for_each = local.processes[count.index] content { content = source.value.type filename = source.value.name } } } ``` ```bash $ terraform apply data.archive_file.applications[0]: Refreshing state... data.archive_file.applications[1]: Refreshing state... Apply complete! Resources: 0 added, 0 changed, 0 destroyed. ", "keywords": ["bill", "change"]}]}], "filtered-sentences": []}, {"Id": "73933224", "PostTypeId": "2", "ParentId": "55487972", "CreationDate": "2022-10-03T09:02:45.583", "Score": "0", "Body": "<p>Here is my solution that work like charm. Just note the tricks <code>google_service_account.purpose[each.value[&quot;name&quot;]].name</code> where I can retrieve the named array element by using its name.</p>\n<pre><code>  variable &quot;my_envs&quot; {\n  type = map(object({\n    name   = string\n    bucket = string\n  }))\n  default = {\n    &quot;dev&quot; = {\n      name   = &quot;dev&quot;\n      bucket = &quot;my-bucket-fezfezfez&quot;\n    }\n    &quot;prod&quot; = {\n      name   = &quot;prod&quot;\n      bucket = &quot;my-bucket-ezaeazeaz&quot;\n    }\n  }\n}\n\n\nresource &quot;google_service_account&quot; &quot;purpose&quot; {\n  for_each     = var.my_envs\n  display_name = &quot;blablabla (terraform)&quot;\n  project      = each.value[&quot;name&quot;]\n  account_id   = &quot;purpose-${each.value[&quot;name&quot;]}&quot;\n}\n\nresource &quot;google_service_account_iam_binding&quot; &quot;purpose_workload_identity_binding&quot; {\n  for_each           = var.my_envs\n  service_account_id = google_service_account.purpose[each.value[&quot;name&quot;]].name\n  role               = &quot;roles/iam.whatever&quot;\n\n  members = [\n    &quot;serviceAccount:${each.value[&quot;name&quot;]}.svc.id.goog[purpose/purpose]&quot;,\n  ]\n}\n\nresource &quot;google_storage_bucket_iam_member&quot; &quot;purpose_artifacts&quot; {\n  for_each = var.my_envs\n  bucket   = each.value[&quot;bucket&quot;]\n  role     = &quot;roles/storage.whatever&quot;\n  member   = &quot;serviceAccount:${google_service_account.purpose[each.value[&quot;name&quot;]].email}&quot;\n}\n</code></pre>\n", "OwnerUserId": "17916426", "LastActivityDate": "2022-10-03T09:02:45.583", "CommentCount": "0", "ContentLicense": "CC BY-SA 4.0", "history": [{"Id": "279382208", "PostHistoryTypeId": "2", "PostId": "73933224", "RevisionGUID": "6283ab2b-96bd-48ab-8b88-b521580a8fde", "CreationDate": "2022-10-03T09:02:45.583", "UserId": "17916426", "Text": "Here is my solution that work like charm. Just note the tricks `google_service_account.purpose[each.value[\"name\"]].name` where I can retrieve the named array element by using its name.\r\n\r\n\r\n      variable \"my_envs\" {\r\n      type = map(object({\r\n        name   = string\r\n        bucket = string\r\n      }))\r\n      default = {\r\n        \"dev\" = {\r\n          name   = \"dev\"\r\n          bucket = \"my-bucket-fezfezfez\"\r\n        }\r\n        \"prod\" = {\r\n          name   = \"prod\"\r\n          bucket = \"my-bucket-ezaeazeaz\"\r\n        }\r\n      }\r\n    }\r\n    \r\n    \r\n    resource \"google_service_account\" \"purpose\" {\r\n      for_each     = var.my_envs\r\n      display_name = \"blablabla (terraform)\"\r\n      project      = each.value[\"name\"]\r\n      account_id   = \"purpose-${each.value[\"name\"]}\"\r\n    }\r\n    \r\n    resource \"google_service_account_iam_binding\" \"purpose_workload_identity_binding\" {\r\n      for_each           = var.my_envs\r\n      service_account_id = google_service_account.purpose[each.value[\"name\"]].name\r\n      role               = \"roles/iam.whatever\"\r\n    \r\n      members = [\r\n        \"serviceAccount:${each.value[\"name\"]}.svc.id.goog[purpose/purpose]\",\r\n      ]\r\n    }\r\n    \r\n    resource \"google_storage_bucket_iam_member\" \"purpose_artifacts\" {\r\n      for_each = var.my_envs\r\n      bucket   = each.value[\"bucket\"]\r\n      role     = \"roles/storage.whatever\"\r\n      member   = \"serviceAccount:${google_service_account.purpose[each.value[\"name\"]].email}\"\r\n    }\r\n\r\n", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "variable \"my_envs\" { type = map(object({ name = string bucket = string })) default = { \"dev\" = { name = \"dev\" bucket = \"my-bucket-fezfezfez\" } \"prod\" = { name = \"prod\" bucket = \"my-bucket-ezaeazeaz\" } } } resource \"google_service_account\" \"purpose\" { for_each = var.my_envs display_name = \"blablabla (terraform)\" project = each.value[\"name\"] account_id = \"purpose-${each.value[\"name\"]}\" } resource \"google_service_account_iam_binding\" \"purpose_workload_identity_binding\" { for_each = var.my_envs service_account_id = google_service_account.purpose[each.value[\"name\"]].name role = \"roles/iam.whatever\" members = [ \"serviceAccount:${each.value[\"name\"]}.svc.id.goog[purpose/purpose]\", ] } resource \"google_storage_bucket_iam_member\" \"purpose_artifacts\" { for_each = var.my_envs bucket = each.value[\"bucket\"] role = \"roles/storage.whatever\" member = \"serviceAccount:${google_service_account.purpose[each.value[\"name\"]].email}\" ", "keywords": ["storage"]}]}], "filtered-sentences": []}], "contains-topic": true, "filtered-sentences": []}