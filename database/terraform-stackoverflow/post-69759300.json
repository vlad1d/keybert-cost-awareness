{"Id": "69759300", "PostTypeId": "1", "AcceptedAnswerId": "69761518", "CreationDate": "2021-10-28T18:38:22.520", "Score": "0", "ViewCount": "929", "Body": "<p>Given some conditional/filtered <code>for_each</code> statement, how can I use the remaining objects for downstream dependencies?</p>\n<p>Note: Terraform 0.13.7</p>\n<p>For example, if a user does not have an s3 bucket terraform should create one and set it's notification policy.  If they do have a bucket then terraform should look up the bucket and set it's notification.</p>\n<p>So far i've tried formatted my payload like such:</p>\n<pre><code>&quot;snowpipes&quot;: {\n  . . .\n  &quot;create_staging_bucket&quot;: true,\n  &quot;staging_bucket&quot;: {\n    &quot;name&quot;: &quot;existing-bucket-deployment&quot;,\n    &quot;url&quot;: &quot;old-dirty-bucket&quot;,\n    &quot;arn&quot;: &quot;arn:aws:s3:::old-dirty-bucket&quot;\n  },\n  . . .\n}\n</code></pre>\n<p>And then constructed my terraform like so:</p>\n<pre><code>resource &quot;aws_s3_bucket&quot; &quot;staging_bucket&quot; {\n  for_each = {for k, v in var.snowpipes : k =&gt; v if v.create_staging_bucket == true}\n  bucket = lower(each.value.staging_bucket.url)\n}\n\nresource &quot;aws_s3_bucket_notification&quot; &quot;bucket_notification&quot; {\n  for_each = var.snowpipes\n  bucket = aws_s3_bucket.staging_bucket[each.key].id\n  . . .\n}\n</code></pre>\n<p>but then I get errors like this, suggesting that the given key was filtered out:</p>\n<pre><code>Error: Invalid index\n\n  on main.tf line 504, in resource &quot;aws_s3_bucket_notification&quot; &quot;bucket_notification&quot;:\n 504:   bucket = aws_s3_bucket.staging_bucket[each.key].id\n    |----------------\n    | aws_s3_bucket.staging_bucket is object with no attributes\n    | each.key is &quot;existing-bucket-deployment&quot;\n\nThe given key does not identify an element in this collection value.\n</code></pre>\n<p>Not sure if there's a way to swap back and forth between a <code>resource</code> and a <code>data</code> object?</p>\n", "OwnerUserId": "5660197", "LastEditorUserId": "5660197", "LastEditDate": "2021-10-28T18:44:43.573", "LastActivityDate": "2021-10-28T22:10:28.330", "Title": "Terraform conditional `for_each` with downstream dependencies", "Tags": "<amazon-s3><terraform><terraform-provider-aws><terraform0.12+>", "AnswerCount": "1", "CommentCount": "0", "ContentLicense": "CC BY-SA 4.0", "history": [{"Id": "256837852", "PostHistoryTypeId": "2", "PostId": "69759300", "RevisionGUID": "df04ea8f-1056-496a-af7f-d9fb4999bd81", "CreationDate": "2021-10-28T18:38:22.520", "UserId": "5660197", "Text": "Given some conditional/filtered `for_each` statement, how can I use the remaining objects for downstream dependencies? \r\n\r\nNote: Terraform 0.13.7\r\n\r\nFor example, if a user does not have an s3 bucket terraform should create one and set it's notification policy.  If they do have a bucket then terraform should look up the bucket and set it's notification.\r\n\r\nSo far i've tried formatted my payload like such:\r\n```\r\n{\r\n. . .\r\n\"create_staging_bucket\": true,\r\n\"staging_bucket\": {\r\n  \"name\": \"existing-bucket-deployment\",\r\n  \"url\": \"old-dirty-bucket\",\r\n  \"arn\": \"arn:aws:s3:::old-dirty-bucket\",\r\n. . .\r\n},\r\n```\r\n\r\nAnd then constructed my terraform like so:\r\n\r\n```terraform\r\nresource \"aws_s3_bucket\" \"staging_bucket\" {\r\n  for_each = {for k, v in var.snowpipes : k => v if v.create_staging_bucket == true}\r\n  bucket = lower(each.value.staging_bucket.url)\r\n}\r\n\r\nresource \"aws_s3_bucket_notification\" \"bucket_notification\" {\r\n  for_each = var.snowpipes\r\n  bucket = aws_s3_bucket.staging_bucket[each.key].id\r\n  queue {\r\n    id        = \"snowpipe_${each.value.name}_event_stream\"\r\n    queue_arn = snowflake_pipe.snowpipe[each.key].notification_channel\r\n    events    = [\"s3:ObjectCreated:*\"]\r\n  }\r\n  depends_on = [snowflake_pipe.snowpipe]\r\n}\r\n```\r\n\r\nbut then I get errors like this, suggesting that the given key was filtered out:\r\n```\r\nError: Invalid index\r\n\r\n  on main.tf line 504, in resource \"aws_s3_bucket_notification\" \"bucket_notification\":\r\n 504:   bucket = aws_s3_bucket.staging_bucket[each.key].id\r\n    |----------------\r\n    | aws_s3_bucket.staging_bucket is object with no attributes\r\n    | each.key is \"existing-bucket-deployment\"\r\n\r\nThe given key does not identify an element in this collection value.\r\n```\r\n\r\nNot sure if there's a way to swap back and forth between a `resource` and a `data` object?", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "For example, if a user does not have an s3 bucket terraform should create one and set it's notification policy. ", "keywords": ["policy"]}]}, {"Id": "256837854", "PostHistoryTypeId": "1", "PostId": "69759300", "RevisionGUID": "df04ea8f-1056-496a-af7f-d9fb4999bd81", "CreationDate": "2021-10-28T18:38:22.520", "UserId": "5660197", "Text": "Terraform conditional `for_each` with downstream dependencies", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "256837855", "PostHistoryTypeId": "3", "PostId": "69759300", "RevisionGUID": "df04ea8f-1056-496a-af7f-d9fb4999bd81", "CreationDate": "2021-10-28T18:38:22.520", "UserId": "5660197", "Text": "<amazon-s3><terraform><terraform-provider-aws><terraform0.12+>", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "256838227", "PostHistoryTypeId": "5", "PostId": "69759300", "RevisionGUID": "8a9e4005-17ae-4393-95b2-d1a3fb06daea", "CreationDate": "2021-10-28T18:44:43.573", "UserId": "5660197", "Comment": "clean up code a bit", "Text": "Given some conditional/filtered `for_each` statement, how can I use the remaining objects for downstream dependencies? \r\n\r\nNote: Terraform 0.13.7\r\n\r\nFor example, if a user does not have an s3 bucket terraform should create one and set it's notification policy.  If they do have a bucket then terraform should look up the bucket and set it's notification.\r\n\r\nSo far i've tried formatted my payload like such:\r\n```\r\n\"snowpipes\": {\r\n  . . .\r\n  \"create_staging_bucket\": true,\r\n  \"staging_bucket\": {\r\n    \"name\": \"existing-bucket-deployment\",\r\n    \"url\": \"old-dirty-bucket\",\r\n    \"arn\": \"arn:aws:s3:::old-dirty-bucket\"\r\n  },\r\n  . . .\r\n}\r\n```\r\n\r\nAnd then constructed my terraform like so:\r\n\r\n```terraform\r\nresource \"aws_s3_bucket\" \"staging_bucket\" {\r\n  for_each = {for k, v in var.snowpipes : k => v if v.create_staging_bucket == true}\r\n  bucket = lower(each.value.staging_bucket.url)\r\n}\r\n\r\nresource \"aws_s3_bucket_notification\" \"bucket_notification\" {\r\n  for_each = var.snowpipes\r\n  bucket = aws_s3_bucket.staging_bucket[each.key].id\r\n  . . .\r\n}\r\n```\r\n\r\nbut then I get errors like this, suggesting that the given key was filtered out:\r\n```\r\nError: Invalid index\r\n\r\n  on main.tf line 504, in resource \"aws_s3_bucket_notification\" \"bucket_notification\":\r\n 504:   bucket = aws_s3_bucket.staging_bucket[each.key].id\r\n    |----------------\r\n    | aws_s3_bucket.staging_bucket is object with no attributes\r\n    | each.key is \"existing-bucket-deployment\"\r\n\r\nThe given key does not identify an element in this collection value.\r\n```\r\n\r\nNot sure if there's a way to swap back and forth between a `resource` and a `data` object?", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "For example, if a user does not have an s3 bucket terraform should create one and set it's notification policy. ", "keywords": ["policy"]}]}], "answers": [{"Id": "69761518", "PostTypeId": "2", "ParentId": "69759300", "CreationDate": "2021-10-28T22:10:28.330", "Score": "1", "Body": "<p>I would typically recommend keeping a shared module simpler by making a hard decision about whether creating the bucket is part of its scope or not, and then having the calling module <em>always</em> declare its own S3 bucket if you decide that the S3 bucket is not part of its scope, but I can also see that sometimes it's convenient to be flexible in this way, and it is possible to do so at the expense of some extra complexity in the configuration.</p>\n<p>Let's start by showing the variable declaration I'm going to assume for the rest of this:</p>\n<pre><code>variable &quot;snowpipes&quot; {\n  type = map(object({\n    create_staging_bucket = bool\n    staging_bucket = object({\n      name = string\n      url  = string\n      arn  = string\n    })\n    # (and whatever else you need, immaterial to this question)\n  }))\n}\n</code></pre>\n<p>Next let's declare the <code>aws_s3_bucket</code> resource for the subset of these elements that have <code>create_staging_bucket</code> set, which is the same as what you wrote already:</p>\n<pre><code>resource &quot;aws_s3_bucket&quot; &quot;staging_bucket&quot; {\n  for_each = {\n    for k, v in var.snowpipes : k =&gt; v\n    if v.create_staging_bucket == true\n  }\n\n  bucket = lower(each.value.staging_bucket.url)\n}\n</code></pre>\n<p>So far I hope I've just repeated essentially what you already had. My next step would be to merge the results of this resource into the settings from the original variable in order to create a flat map of all of the staging buckets, regardless of whether they were created here or not:</p>\n<pre><code>locals {\n  staging_buckets = merge(\n    { for k, sp in var.snowpipes : k =&gt; sp.staging_bucket }\n    {\n      for k, b in aws_s3_bucket.staging_bucket : k =&gt; {\n        name = b.bucket\n        url  = b.bucket # (not sure about this, but following your example above)\n        arn  = b.arn\n      }\n    }\n  }\n}\n</code></pre>\n<p>Now we're back to a map that has all of the same keys as we started with in <code>var.snowpipes</code>, where some of the elements are just verbatim what was in the input and others are synthetic based on the resource we declared. Due to the priority behavior of <code>merge</code>, it'll prefer to use a key from the second map rather than from the first map wherever the map keys collide.</p>\n<p>We can use that for the bucket notification resource:</p>\n<pre><code>resource &quot;aws_s3_bucket_notification&quot; &quot;bucket_notification&quot; {\n  for_each = local.staging_buckets\n\n  bucket = each.value.name\n  # ...\n}\n</code></pre>\n", "OwnerUserId": "281848", "LastActivityDate": "2021-10-28T22:10:28.330", "CommentCount": "1", "ContentLicense": "CC BY-SA 4.0", "comments": [{"Id": "123311910", "PostId": "69761518", "Score": "0", "Text": "Thanks, I didn't even know there was a merge, and definitely didn't realize the power of using local variables.  Coming from a lot of TF12 I ended up creating two resources (resource.s3 & data.s3) conditioned on the map and two notification resources, but this looks a lot cleaner.", "CreationDate": "2021-10-28T22:30:20.547", "UserId": "5660197", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "history": [{"Id": "256849572", "PostHistoryTypeId": "2", "PostId": "69761518", "RevisionGUID": "cb865eb9-a29d-47ad-88b1-40cae4acc4f7", "CreationDate": "2021-10-28T22:10:28.330", "UserId": "281848", "Text": "I would typically recommend keeping a shared module simpler by making a hard decision about whether creating the bucket is part of its scope or not, and then having the calling module _always_ declare its own S3 bucket if you decide that the S3 bucket is not part of its scope, but I can also see that sometimes it's convenient to be flexible in this way, and it is possible to do so at the expense of some extra complexity in the configuration.\r\n\r\nLet's start by showing the variable declaration I'm going to assume for the rest of this:\r\n\r\n```\r\nvariable \"snowpipes\" {\r\n  type = map(object({\r\n    create_staging_bucket = bool\r\n    staging_bucket = object({\r\n      name = string\r\n      url  = string\r\n      arn  = string\r\n    })\r\n    # (and whatever else you need, immaterial to this question)\r\n  }))\r\n}\r\n```\r\n\r\nNext let's declare the `aws_s3_bucket` resource for the subset of these elements that have `create_staging_bucket` set, which is the same as what you wrote already:\r\n\r\n```\r\nresource \"aws_s3_bucket\" \"staging_bucket\" {\r\n  for_each = {\r\n    for k, v in var.snowpipes : k => v\r\n    if v.create_staging_bucket == true\r\n  }\r\n\r\n  bucket = lower(each.value.staging_bucket.url)\r\n}\r\n```\r\n\r\nSo far I hope I've just repeated essentially what you already had. My next step would be to merge the results of this resource into the settings from the original variable in order to create a flat map of all of the staging buckets, regardless of whether they were created here or not:\r\n\r\n```\r\nlocals {\r\n  staging_buckets = merge(\r\n    { for k, sp in var.snowpipes : k => sp.staging_bucket }\r\n    {\r\n      for k, b in aws_s3_bucket.staging_bucket : k => {\r\n        name = b.bucket\r\n        url  = b.bucket # (not sure about this, but following your example above)\r\n        arn  = b.arn\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nNow we're back to a map that has all of the same keys as we started with in `var.snowpipes`, where some of the elements are just verbatim what was in the input and others are synthetic based on the resource we declared. Due to the priority behavior of `merge`, it'll prefer to use a key from the second map rather than from the first map wherever the map keys collide.\r\n\r\nWe can use that for the bucket notification resource:\r\n\r\n```\r\nresource \"aws_s3_bucket_notification\" \"bucket_notification\" {\r\n  for_each = local.staging_buckets\r\n\r\n  bucket = each.value.name\r\n  # ...\r\n}\r\n```\r\n\r\n", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "I would typically recommend keeping a shared module simpler by making a hard decision about whether creating the bucket is part of its scope or not, and then having the calling module _always_ declare its own S3 bucket if you decide that the S3 bucket is not part of its scope, but I can also see that sometimes it's convenient to be flexible in this way, and it is possible to do so at the expense of some extra complexity in the configuration. ", "keywords": ["expense"]}]}], "filtered-sentences": [{"source": "Body", "text": "I would typically recommend keeping a shared module simpler by making a hard decision about whether creating the bucket is part of its scope or not, and then having the calling module always declare its own S3 bucket if you decide that the S3 bucket is not part of its scope, but I can also see that sometimes it's convenient to be flexible in this way, and it is possible to do so at the expense of some extra complexity in the configuration. ", "keywords": ["expense"]}]}], "contains-topic": true, "filtered-sentences": [{"source": "Body", "text": "For example, if a user does not have an s3 bucket terraform should create one and set it's notification policy. ", "keywords": ["policy"]}]}