{"Id": "68986334", "PostTypeId": "1", "CreationDate": "2021-08-30T15:08:51.190", "Score": "1", "ViewCount": "1303", "Body": "<p>First of all, I am surprised that I have found very few resources on Google that mention this issue with Terraform.\nThis is an essential feature for optimizing the cost of cloud instances though, so I'm probably missing out on a few things, thanks for your tips and ideas!</p>\n<p>I want to create an instance and manage its start and stop daily, programmatically.\nThe resource &quot;google_compute_resource_policy&quot; seems to meet my use case. However, when I change the stop or start time, Terraform plans to destroy and recreate the instance... which I absolutely don't want!</p>\n<p>The resource &quot;google_compute_resource_policy&quot; is attached to the instance via the argument <a href=\"https://registry.terraform.io/providers/hashicorp/google/latest/docs/resources/compute_instance#resource_policies\" rel=\"nofollow noreferrer\">resource_policies</a> where it is specified: &quot;Modifying this list will cause the instance to recreate.&quot;</p>\n<p>I don't understand why Terraform handles this simple update so badly. It is true that it is not possible to update a scheduler, whereas it is perfectly possible to detach it manually from the instance, then to destroy it before recreating it with the new stop/start schedule and the attach to the instance again.</p>\n<p>Is there a workaround without going through a null resource to run a gcloud script to do these steps?</p>\n<p>I tried to add an &quot;ignore_changes&quot; lifecycle on the &quot;resource_policies&quot; argument of my instance, Terraform no longer wants to destroy my instance, but it gives me the following error:</p>\n<pre><code>Error when reading or editing ResourcePolicy: googleapi: Error 400: The resource_policy resource 'projects/my-project-id/regions/europe-west1/resourcePolicies/my-instance-schedule' is already being used by 'projects/my-project-id/zones/europe-west1-b/instances/my-instance', resourceInUseByAnotherResource&quot;\n</code></pre>\n<p>Here is my Terraform code</p>\n<pre><code>resource &quot;google_compute_resource_policy&quot; &quot;instance_schedule&quot; {\n  name = &quot;my-instance-schedule&quot;\n  region = var.region\n  description = &quot;Start and stop instance&quot;\n\n  instance_schedule_policy {\n    vm_start_schedule {\n      schedule = var.vm_start_schedule\n    }\n    vm_stop_schedule {\n      schedule = var.vm_stop_schedule\n    }\n    time_zone = &quot;Europe/Paris&quot;\n  }\n}\n\nresource &quot;google_compute_instance&quot; &quot;my-instance&quot; {\n\n  // ******** This is my attempted workaround ********\n  lifecycle {\n    ignore_changes = [resource_policies]\n  }\n\n  name = &quot;my-instance&quot;\n  machine_type = var.machine_type\n  zone = &quot;${var.region}-b&quot;\n\n  allow_stopping_for_update = true\n\n  resource_policies = [\n    google_compute_resource_policy.instance_schedule.id\n  ]\n\n  boot_disk {\n    device_name = local.ref_name\n    initialize_params {\n      image = var.boot_disk_image\n      type = var.disk_type\n      size = var.disk_size\n    }\n  }\n\n  network_interface {\n    network = data.google_compute_network.default.name\n    access_config {\n      nat_ip = google_compute_address.static.address\n    }\n  }\n}\n</code></pre>\n<p>If it can be useful, here is what the <code>terraform apply</code> returns</p>\n<pre><code>An execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n  - destroy\n-/+ destroy and then create replacement\n\nTerraform will perform the following actions:\n\n  # google_compute_resource_policy.instance_schedule must be replaced\n-/+ resource &quot;google_compute_resource_policy&quot; &quot;instance_schedule&quot; {\n      ~ id          = &quot;projects/my-project-id/regions/europe-west1/resourcePolicies/my-instance-schedule&quot; -&gt; (known after apply)\n        name        = &quot;my-instance-schedule&quot;\n      ~ project     = &quot;my-project-id&quot; -&gt; (known after apply)\n      ~ region      = &quot;https://www.googleapis.com/compute/v1/projects/my-project-id/regions/europe-west1&quot; -&gt; &quot;europe-west1&quot;\n      ~ self_link   = &quot;https://www.googleapis.com/compute/v1/projects/my-project-id/regions/europe-west1/resourcePolicies/my-instance-schedule&quot; -&gt; (known after apply)\n        # (1 unchanged attribute hidden)\n\n      ~ instance_schedule_policy {\n            # (1 unchanged attribute hidden)\n\n          ~ vm_start_schedule {\n              ~ schedule = &quot;0 9 * * *&quot; -&gt; &quot;0 8 * * *&quot; # forces replacement\n            }\n\n            # (1 unchanged block hidden)\n        }\n    }\n\nPlan: 1 to add, 0 to change, 1 to destroy.\n\nDo you want to perform these actions in workspace &quot;prd&quot;?\n  Terraform will perform the actions described above.\n  Only 'yes' will be accepted to approve.\n\n  Enter a value: yes\n\ngoogle_compute_resource_policy.instance_schedule: Destroying... [id=projects/my-project-id/regions/europe-west1/resourcePolicies/my-instance-schedule]\n\nError: Error when reading or editing ResourcePolicy: googleapi: Error 400: The resource_policy resource 'projects/my-project-id/regions/europe-west1/resourcePolicies/my-instance-schedule' is already being used by 'projects/my-project-id/zones/europe-west1-b/instances/my-instance', resourceInUseByAnotherResource\n\n</code></pre>\n<p><strong>NB:</strong> I am working with Terraform 0.14.7 and I am using google provider version 3.76.0</p>\n", "OwnerUserId": "10701542", "LastEditorUserId": "10701542", "LastEditDate": "2021-08-30T18:16:07.317", "LastActivityDate": "2022-04-22T10:31:51.860", "Title": "Terraform wants to replace Google compute engine if its start/stop scheduler is modified", "Tags": "<google-cloud-platform><terraform><cloud><google-compute-engine>", "AnswerCount": "3", "CommentCount": "0", "ContentLicense": "CC BY-SA 4.0", "history": [{"Id": "252872376", "PostHistoryTypeId": "2", "PostId": "68986334", "RevisionGUID": "98eb5bcd-45a6-42e2-9abd-8fcc1bfc6def", "CreationDate": "2021-08-30T15:08:51.190", "UserId": "10701542", "Text": "First of all, I am surprised that I have found very few resources on Google that mention this issue with Terraform.\r\nThis is an essential feature for optimizing the cost of cloud instances though, so I'm probably missing out on a few things, thanks for your tips and ideas!\r\n\r\nI want to create an instance and manage its start and stop daily, programmatically.\r\nThe resource \"google_compute_resource_policy\" seems to meet my use case. However, when I change the stop or start time, Terraform plans to destroy and recreate the instance... which I absolutely don't want!\r\n\r\nThe resource \"google_compute_resource_policy\" is attached to the instance via the argument [resource_policies][1] where it is specified: \"Modifying this list will cause the instance to recreate.\"\r\n\r\nI don't understand why Terraform handles this simple update so badly. It is true that it is not possible to update a scheduler, whereas it is perfectly possible to detach it manually from the instance, then to destroy it before recreating it with the new stop/start schedule and the attach to the instance again.\r\n\r\nIs there a workaround without going through a null resource to run a gcloud script to do these steps?\r\n\r\nI tried to add an \"ignore_changes\" lifecycle on the \"resource_policies\" argument of my instance, Terraform no longer wants to destroy my instance, but it gives me the following error:\r\n```\r\nError when reading or editing ResourcePolicy: googleapi: Error 400: The resource_policy resource 'projects/my-project-id/regions/europe-west1/resourcePolicies/my-instance-schedule' is already being used by 'projects/my-project-id/zones/europe-west1-b/instances/my-instance', resourceInUseByAnotherResource\"\r\n```\r\n\r\nHere is my Terraform code\r\n```\r\nresource \"google_compute_resource_policy\" \"instance_schedule\" {\r\n  name = \"my-instance-schedule\"\r\n  region = var.region\r\n  description = \"Start and stop instance\"\r\n\r\n  instance_schedule_policy {\r\n    vm_start_schedule {\r\n      schedule = var.vm_start_schedule\r\n    }\r\n    vm_stop_schedule {\r\n      schedule = var.vm_stop_schedule\r\n    }\r\n    time_zone = \"Europe/Paris\"\r\n  }\r\n}\r\n\r\nresource \"google_compute_instance\" \"my-instance\" {\r\n\r\n  // ******** This is my attempted workaround ********\r\n  lifecycle {\r\n    ignore_changes = [resource_policies]\r\n  }\r\n\r\n  name = \"my-instance\"\r\n  machine_type = var.machine_type\r\n  zone = \"${var.region}-b\"\r\n\r\n  allow_stopping_for_update = true\r\n\r\n  resource_policies = [\r\n    google_compute_resource_policy.instance_schedule.id\r\n  ]\r\n\r\n  boot_disk {\r\n    device_name = local.ref_name\r\n    initialize_params {\r\n      image = var.boot_disk_image\r\n      type = var.disk_type\r\n      size = var.disk_size\r\n    }\r\n  }\r\n\r\n  network_interface {\r\n    network = data.google_compute_network.default.name\r\n    access_config {\r\n      nat_ip = google_compute_address.static.address\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n  [1]: https://registry.terraform.io/providers/hashicorp/google/latest/docs/resources/compute_instance#resource_policies", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "This is an essential feature for optimizing the cost of cloud instances though, so I'm probably missing out on a few things, thanks for your tips and ideas! ", "keywords": ["cost", "feature"]}, {"source": "Text", "text": "I want to create an instance and manage its start and stop daily, programmatically. ", "keywords": ["instance"]}, {"source": "Text", "text": "However, when I change the stop or start time, Terraform plans to destroy and recreate the instance... which I absolutely don't want! ", "keywords": ["instance", "change"]}, {"source": "Text", "text": "The resource \"google_compute_resource_policy\" is attached to the instance via the argument [resource_policies][1] where it is specified: \"Modifying this list will cause the instance to recreate.\" ", "keywords": ["instance"]}, {"source": "Text", "text": "It is true that it is not possible to update a scheduler, whereas it is perfectly possible to detach it manually from the instance, then to destroy it before recreating it with the new stop/start schedule and the attach to the instance again. ", "keywords": ["instance"]}, {"source": "Text", "text": "I tried to add an \"ignore_changes\" lifecycle on the \"resource_policies\" argument of my instance, Terraform no longer wants to destroy my instance, but it gives me the following error: ``` ", "keywords": ["instance"]}, {"source": "Text", "text": "Error when reading or editing ResourcePolicy: googleapi: Error 400: The resource_policy resource 'projects/my-project-id/regions/europe-west1/resourcePolicies/my-instance-schedule' is already being used by 'projects/my-project-id/zones/europe-west1-b/instances/my-instance', resourceInUseByAnotherResource\" ``` Here is my Terraform code ``` resource \"google_compute_resource_policy\" \"instance_schedule\" { name = \"my-instance-schedule\" region = var.region description = \"Start and stop instance\" instance_schedule_policy { vm_start_schedule { schedule = var.vm_start_schedule } vm_stop_schedule { schedule = var.vm_stop_schedule } time_zone = \"Europe/Paris\" } } resource \"google_compute_instance\" \"my-instance\" { // ******** This is my attempted workaround ******** lifecycle { ignore_changes = [resource_policies] } name = \"my-instance\" machine_type = var.machine_type zone = \"${var.region}-b\" allow_stopping_for_update = true resource_policies = [ google_compute_resource_policy.instance_schedule.id ] boot_disk { device_name = local.ref_name initialize_params { image = var.boot_disk_image type = var.disk_type size = var.disk_size } } network_interface { network = data.google_compute_network.default.name access_config { nat_ip = google_compute_address.static.address } } } ``` ", "keywords": ["instance"]}]}, {"Id": "252872377", "PostHistoryTypeId": "1", "PostId": "68986334", "RevisionGUID": "98eb5bcd-45a6-42e2-9abd-8fcc1bfc6def", "CreationDate": "2021-08-30T15:08:51.190", "UserId": "10701542", "Text": "Terraform always tries to replace gcp compute engine if its start/stop scheduler is modified", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "252872378", "PostHistoryTypeId": "3", "PostId": "68986334", "RevisionGUID": "98eb5bcd-45a6-42e2-9abd-8fcc1bfc6def", "CreationDate": "2021-08-30T15:08:51.190", "UserId": "10701542", "Text": "<google-cloud-platform><terraform><cloud><google-compute-engine><instance>", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "252873003", "PostHistoryTypeId": "5", "PostId": "68986334", "RevisionGUID": "a193b5c4-1366-4f6a-abe8-613a99c34cbe", "CreationDate": "2021-08-30T15:19:32.753", "UserId": "10701542", "Comment": "added 40 characters in body", "Text": "First of all, I am surprised that I have found very few resources on Google that mention this issue with Terraform.\r\nThis is an essential feature for optimizing the cost of cloud instances though, so I'm probably missing out on a few things, thanks for your tips and ideas!\r\n\r\nI want to create an instance and manage its start and stop daily, programmatically.\r\nThe resource \"google_compute_resource_policy\" seems to meet my use case. However, when I change the stop or start time, Terraform plans to destroy and recreate the instance... which I absolutely don't want!\r\n\r\nThe resource \"google_compute_resource_policy\" is attached to the instance via the argument [resource_policies][1] where it is specified: \"Modifying this list will cause the instance to recreate.\"\r\n\r\nI don't understand why Terraform handles this simple update so badly. It is true that it is not possible to update a scheduler, whereas it is perfectly possible to detach it manually from the instance, then to destroy it before recreating it with the new stop/start schedule and the attach to the instance again.\r\n\r\nIs there a workaround without going through a null resource to run a gcloud script to do these steps?\r\n\r\nI tried to add an \"ignore_changes\" lifecycle on the \"resource_policies\" argument of my instance, Terraform no longer wants to destroy my instance, but it gives me the following error:\r\n```\r\nError when reading or editing ResourcePolicy: googleapi: Error 400: The resource_policy resource 'projects/my-project-id/regions/europe-west1/resourcePolicies/my-instance-schedule' is already being used by 'projects/my-project-id/zones/europe-west1-b/instances/my-instance', resourceInUseByAnotherResource\"\r\n```\r\n\r\nHere is my Terraform code\r\n```\r\nresource \"google_compute_resource_policy\" \"instance_schedule\" {\r\n  name = \"my-instance-schedule\"\r\n  region = var.region\r\n  description = \"Start and stop instance\"\r\n\r\n  instance_schedule_policy {\r\n    vm_start_schedule {\r\n      schedule = var.vm_start_schedule\r\n    }\r\n    vm_stop_schedule {\r\n      schedule = var.vm_stop_schedule\r\n    }\r\n    time_zone = \"Europe/Paris\"\r\n  }\r\n}\r\n\r\nresource \"google_compute_instance\" \"my-instance\" {\r\n\r\n  // ******** This is my attempted workaround ********\r\n  lifecycle {\r\n    ignore_changes = [resource_policies]\r\n  }\r\n\r\n  name = \"my-instance\"\r\n  machine_type = var.machine_type\r\n  zone = \"${var.region}-b\"\r\n\r\n  allow_stopping_for_update = true\r\n\r\n  resource_policies = [\r\n    google_compute_resource_policy.instance_schedule.id\r\n  ]\r\n\r\n  boot_disk {\r\n    device_name = local.ref_name\r\n    initialize_params {\r\n      image = var.boot_disk_image\r\n      type = var.disk_type\r\n      size = var.disk_size\r\n    }\r\n  }\r\n\r\n  network_interface {\r\n    network = data.google_compute_network.default.name\r\n    access_config {\r\n      nat_ip = google_compute_address.static.address\r\n    }\r\n  }\r\n}\r\n```\r\n**NB:** I am working with Terraform 0.14.7 and I am using google provider version 3.76.0\r\n\r\n  [1]: https://registry.terraform.io/providers/hashicorp/google/latest/docs/resources/compute_instance#resource_policies", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "This is an essential feature for optimizing the cost of cloud instances though, so I'm probably missing out on a few things, thanks for your tips and ideas! ", "keywords": ["cost", "feature"]}, {"source": "Text", "text": "I want to create an instance and manage its start and stop daily, programmatically. ", "keywords": ["instance"]}, {"source": "Text", "text": "However, when I change the stop or start time, Terraform plans to destroy and recreate the instance... which I absolutely don't want! ", "keywords": ["instance", "change"]}, {"source": "Text", "text": "The resource \"google_compute_resource_policy\" is attached to the instance via the argument [resource_policies][1] where it is specified: \"Modifying this list will cause the instance to recreate.\" ", "keywords": ["instance"]}, {"source": "Text", "text": "It is true that it is not possible to update a scheduler, whereas it is perfectly possible to detach it manually from the instance, then to destroy it before recreating it with the new stop/start schedule and the attach to the instance again. ", "keywords": ["instance"]}, {"source": "Text", "text": "I tried to add an \"ignore_changes\" lifecycle on the \"resource_policies\" argument of my instance, Terraform no longer wants to destroy my instance, but it gives me the following error: ``` ", "keywords": ["instance"]}, {"source": "Text", "text": "Error when reading or editing ResourcePolicy: googleapi: Error 400: The resource_policy resource 'projects/my-project-id/regions/europe-west1/resourcePolicies/my-instance-schedule' is already being used by 'projects/my-project-id/zones/europe-west1-b/instances/my-instance', resourceInUseByAnotherResource\" ``` Here is my Terraform code ``` resource \"google_compute_resource_policy\" \"instance_schedule\" { name = \"my-instance-schedule\" region = var.region description = \"Start and stop instance\" instance_schedule_policy { vm_start_schedule { schedule = var.vm_start_schedule } vm_stop_schedule { schedule = var.vm_stop_schedule } time_zone = \"Europe/Paris\" } } resource \"google_compute_instance\" \"my-instance\" { // ******** This is my attempted workaround ******** lifecycle { ignore_changes = [resource_policies] } name = \"my-instance\" machine_type = var.machine_type zone = \"${var.region}-b\" allow_stopping_for_update = true resource_policies = [ google_compute_resource_policy.instance_schedule.id ] boot_disk { device_name = local.ref_name initialize_params { image = var.boot_disk_image type = var.disk_type size = var.disk_size } } network_interface { network = data.google_compute_network.default.name access_config { nat_ip = google_compute_address.static.address } } } ``` ", "keywords": ["instance"]}, {"source": "Text", "text": "**NB:** I am working with Terraform 0.14.7 and I am using google provider version 3.76.0 [1]: https://registry.terraform.io/providers/hashicorp/google/latest/docs/resources/compute_instance#resource_policies", "keywords": ["provider"]}]}, {"Id": "252873911", "PostHistoryTypeId": "4", "PostId": "68986334", "RevisionGUID": "040c09a8-8889-49e0-8638-b6e6c571d73f", "CreationDate": "2021-08-30T15:35:51.727", "UserId": "10701542", "Comment": "edited title", "Text": "Terraform tries to replace gcp compute engine if its start/stop scheduler is modified", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "252879493", "PostHistoryTypeId": "4", "PostId": "68986334", "RevisionGUID": "42794c96-810f-4cc8-b75c-cf63934f5b58", "CreationDate": "2021-08-30T17:19:13.380", "UserId": "10701542", "Comment": "edited title", "Text": "Terraform wants to replace Google compute engine if its start/stop scheduler is modified", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "252881724", "PostHistoryTypeId": "5", "PostId": "68986334", "RevisionGUID": "4cfc17a2-e189-4fce-b25b-b632e960d53a", "CreationDate": "2021-08-30T18:10:58.530", "UserId": "10701542", "Comment": "Add \"terraform plan\" return", "Text": "First of all, I am surprised that I have found very few resources on Google that mention this issue with Terraform.\r\nThis is an essential feature for optimizing the cost of cloud instances though, so I'm probably missing out on a few things, thanks for your tips and ideas!\r\n\r\nI want to create an instance and manage its start and stop daily, programmatically.\r\nThe resource \"google_compute_resource_policy\" seems to meet my use case. However, when I change the stop or start time, Terraform plans to destroy and recreate the instance... which I absolutely don't want!\r\n\r\nThe resource \"google_compute_resource_policy\" is attached to the instance via the argument [resource_policies][1] where it is specified: \"Modifying this list will cause the instance to recreate.\"\r\n\r\nI don't understand why Terraform handles this simple update so badly. It is true that it is not possible to update a scheduler, whereas it is perfectly possible to detach it manually from the instance, then to destroy it before recreating it with the new stop/start schedule and the attach to the instance again.\r\n\r\nIs there a workaround without going through a null resource to run a gcloud script to do these steps?\r\n\r\nI tried to add an \"ignore_changes\" lifecycle on the \"resource_policies\" argument of my instance, Terraform no longer wants to destroy my instance, but it gives me the following error:\r\n```\r\nError when reading or editing ResourcePolicy: googleapi: Error 400: The resource_policy resource 'projects/my-project-id/regions/europe-west1/resourcePolicies/my-instance-schedule' is already being used by 'projects/my-project-id/zones/europe-west1-b/instances/my-instance', resourceInUseByAnotherResource\"\r\n```\r\n\r\nHere is my Terraform code\r\n```\r\nresource \"google_compute_resource_policy\" \"instance_schedule\" {\r\n  name = \"my-instance-schedule\"\r\n  region = var.region\r\n  description = \"Start and stop instance\"\r\n\r\n  instance_schedule_policy {\r\n    vm_start_schedule {\r\n      schedule = var.vm_start_schedule\r\n    }\r\n    vm_stop_schedule {\r\n      schedule = var.vm_stop_schedule\r\n    }\r\n    time_zone = \"Europe/Paris\"\r\n  }\r\n}\r\n\r\nresource \"google_compute_instance\" \"my-instance\" {\r\n\r\n  // ******** This is my attempted workaround ********\r\n  lifecycle {\r\n    ignore_changes = [resource_policies]\r\n  }\r\n\r\n  name = \"my-instance\"\r\n  machine_type = var.machine_type\r\n  zone = \"${var.region}-b\"\r\n\r\n  allow_stopping_for_update = true\r\n\r\n  resource_policies = [\r\n    google_compute_resource_policy.instance_schedule.id\r\n  ]\r\n\r\n  boot_disk {\r\n    device_name = local.ref_name\r\n    initialize_params {\r\n      image = var.boot_disk_image\r\n      type = var.disk_type\r\n      size = var.disk_size\r\n    }\r\n  }\r\n\r\n  network_interface {\r\n    network = data.google_compute_network.default.name\r\n    access_config {\r\n      nat_ip = google_compute_address.static.address\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nIf it can be useful, here is what the ```terraform plan``` returns\r\n\r\n```\r\nAn execution plan has been generated and is shown below.\r\nResource actions are indicated with the following symbols:\r\n  - destroy\r\n-/+ destroy and then create replacement\r\n\r\nTerraform will perform the following actions:\r\n\r\n  # google_compute_resource_policy.instance_schedule must be replaced\r\n-/+ resource \"google_compute_resource_policy\" \"instance_schedule\" {\r\n      ~ id          = \"projects/my-project-id/regions/europe-west1/resourcePolicies/my-instance-schedule\" -> (known after apply)\r\n        name        = \"my-instance-schedule\"\r\n      ~ project     = \"my-project-id\" -> (known after apply)\r\n      ~ region      = \"https://www.googleapis.com/compute/v1/projects/my-project-id/regions/europe-west1\" -> \"europe-west1\"\r\n      ~ self_link   = \"https://www.googleapis.com/compute/v1/projects/my-project-id/regions/europe-west1/resourcePolicies/my-instance-schedule\" -> (known after apply)\r\n        # (1 unchanged attribute hidden)\r\n\r\n      ~ instance_schedule_policy {\r\n            # (1 unchanged attribute hidden)\r\n\r\n          ~ vm_start_schedule {\r\n              ~ schedule = \"0 9 * * *\" -> \"0 8 * * *\" # forces replacement\r\n            }\r\n\r\n            # (1 unchanged block hidden)\r\n        }\r\n    }\r\n\r\nPlan: 1 to add, 0 to change, 1 to destroy.\r\n```\r\n\r\n\r\n**NB:** I am working with Terraform 0.14.7 and I am using google provider version 3.76.0\r\n\r\n  [1]: https://registry.terraform.io/providers/hashicorp/google/latest/docs/resources/compute_instance#resource_policies", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "This is an essential feature for optimizing the cost of cloud instances though, so I'm probably missing out on a few things, thanks for your tips and ideas! ", "keywords": ["cost", "feature"]}, {"source": "Text", "text": "I want to create an instance and manage its start and stop daily, programmatically. ", "keywords": ["instance"]}, {"source": "Text", "text": "However, when I change the stop or start time, Terraform plans to destroy and recreate the instance... which I absolutely don't want! ", "keywords": ["instance", "change"]}, {"source": "Text", "text": "The resource \"google_compute_resource_policy\" is attached to the instance via the argument [resource_policies][1] where it is specified: \"Modifying this list will cause the instance to recreate.\" ", "keywords": ["instance"]}, {"source": "Text", "text": "It is true that it is not possible to update a scheduler, whereas it is perfectly possible to detach it manually from the instance, then to destroy it before recreating it with the new stop/start schedule and the attach to the instance again. ", "keywords": ["instance"]}, {"source": "Text", "text": "I tried to add an \"ignore_changes\" lifecycle on the \"resource_policies\" argument of my instance, Terraform no longer wants to destroy my instance, but it gives me the following error: ``` ", "keywords": ["instance"]}, {"source": "Text", "text": "Error when reading or editing ResourcePolicy: googleapi: Error 400: The resource_policy resource 'projects/my-project-id/regions/europe-west1/resourcePolicies/my-instance-schedule' is already being used by 'projects/my-project-id/zones/europe-west1-b/instances/my-instance', resourceInUseByAnotherResource\" ``` Here is my Terraform code ``` resource \"google_compute_resource_policy\" \"instance_schedule\" { name = \"my-instance-schedule\" region = var.region description = \"Start and stop instance\" instance_schedule_policy { vm_start_schedule { schedule = var.vm_start_schedule } vm_stop_schedule { schedule = var.vm_stop_schedule } time_zone = \"Europe/Paris\" } } resource \"google_compute_instance\" \"my-instance\" { // ******** This is my attempted workaround ******** lifecycle { ignore_changes = [resource_policies] } name = \"my-instance\" machine_type = var.machine_type zone = \"${var.region}-b\" allow_stopping_for_update = true resource_policies = [ google_compute_resource_policy.instance_schedule.id ] boot_disk { device_name = local.ref_name initialize_params { image = var.boot_disk_image type = var.disk_type size = var.disk_size } } network_interface { network = data.google_compute_network.default.name access_config { nat_ip = google_compute_address.static.address } } } ``` ", "keywords": ["instance"]}, {"source": "Text", "text": "Resource actions are indicated with the following symbols: - destroy -/+ destroy and then create replacement Terraform will perform the following actions: # google_compute_resource_policy.instance_schedule must be replaced -/+ resource \"google_compute_resource_policy\" \"instance_schedule\" { ~ id = \"projects/my-project-id/regions/europe-west1/resourcePolicies/my-instance-schedule\" -> (known after apply) name = \"my-instance-schedule\" ~ project = \"my-project-id\" -> (known after apply) ~ region = \"https://www.googleapis.com/compute/v1/projects/my-project-id/regions/europe-west1\" -> \"europe-west1\" ~ self_link = \"https://www.googleapis.com/compute/v1/projects/my-project-id/regions/europe-west1/resourcePolicies/my-instance-schedule\" -> (known after apply) # (1 unchanged attribute hidden) ~ instance_schedule_policy { # (1 unchanged attribute hidden) ~ vm_start_schedule { ~ schedule = \"0 9 * * *\" -> \"0 8 * * *\" # forces replacement } # (1 unchanged block hidden) } } Plan: 1 to add, 0 to change, 1 to destroy. ", "keywords": ["instance", "change"]}, {"source": "Text", "text": "**NB:** I am working with Terraform 0.14.7 and I am using google provider version 3.76.0 [1]: https://registry.terraform.io/providers/hashicorp/google/latest/docs/resources/compute_instance#resource_policies", "keywords": ["provider"]}]}, {"Id": "252881725", "PostHistoryTypeId": "6", "PostId": "68986334", "RevisionGUID": "4cfc17a2-e189-4fce-b25b-b632e960d53a", "CreationDate": "2021-08-30T18:10:58.530", "UserId": "10701542", "Comment": "Add \"terraform plan\" return", "Text": "<google-cloud-platform><terraform><cloud><google-compute-engine>", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "252881953", "PostHistoryTypeId": "5", "PostId": "68986334", "RevisionGUID": "864658ca-5416-4f42-8f78-10432144d53f", "CreationDate": "2021-08-30T18:16:07.317", "UserId": "10701542", "Comment": "Add \"terraform plan\" return", "Text": "First of all, I am surprised that I have found very few resources on Google that mention this issue with Terraform.\r\nThis is an essential feature for optimizing the cost of cloud instances though, so I'm probably missing out on a few things, thanks for your tips and ideas!\r\n\r\nI want to create an instance and manage its start and stop daily, programmatically.\r\nThe resource \"google_compute_resource_policy\" seems to meet my use case. However, when I change the stop or start time, Terraform plans to destroy and recreate the instance... which I absolutely don't want!\r\n\r\nThe resource \"google_compute_resource_policy\" is attached to the instance via the argument [resource_policies][1] where it is specified: \"Modifying this list will cause the instance to recreate.\"\r\n\r\nI don't understand why Terraform handles this simple update so badly. It is true that it is not possible to update a scheduler, whereas it is perfectly possible to detach it manually from the instance, then to destroy it before recreating it with the new stop/start schedule and the attach to the instance again.\r\n\r\nIs there a workaround without going through a null resource to run a gcloud script to do these steps?\r\n\r\nI tried to add an \"ignore_changes\" lifecycle on the \"resource_policies\" argument of my instance, Terraform no longer wants to destroy my instance, but it gives me the following error:\r\n```\r\nError when reading or editing ResourcePolicy: googleapi: Error 400: The resource_policy resource 'projects/my-project-id/regions/europe-west1/resourcePolicies/my-instance-schedule' is already being used by 'projects/my-project-id/zones/europe-west1-b/instances/my-instance', resourceInUseByAnotherResource\"\r\n```\r\n\r\nHere is my Terraform code\r\n```\r\nresource \"google_compute_resource_policy\" \"instance_schedule\" {\r\n  name = \"my-instance-schedule\"\r\n  region = var.region\r\n  description = \"Start and stop instance\"\r\n\r\n  instance_schedule_policy {\r\n    vm_start_schedule {\r\n      schedule = var.vm_start_schedule\r\n    }\r\n    vm_stop_schedule {\r\n      schedule = var.vm_stop_schedule\r\n    }\r\n    time_zone = \"Europe/Paris\"\r\n  }\r\n}\r\n\r\nresource \"google_compute_instance\" \"my-instance\" {\r\n\r\n  // ******** This is my attempted workaround ********\r\n  lifecycle {\r\n    ignore_changes = [resource_policies]\r\n  }\r\n\r\n  name = \"my-instance\"\r\n  machine_type = var.machine_type\r\n  zone = \"${var.region}-b\"\r\n\r\n  allow_stopping_for_update = true\r\n\r\n  resource_policies = [\r\n    google_compute_resource_policy.instance_schedule.id\r\n  ]\r\n\r\n  boot_disk {\r\n    device_name = local.ref_name\r\n    initialize_params {\r\n      image = var.boot_disk_image\r\n      type = var.disk_type\r\n      size = var.disk_size\r\n    }\r\n  }\r\n\r\n  network_interface {\r\n    network = data.google_compute_network.default.name\r\n    access_config {\r\n      nat_ip = google_compute_address.static.address\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nIf it can be useful, here is what the ```terraform apply``` returns\r\n\r\n```\r\nAn execution plan has been generated and is shown below.\r\nResource actions are indicated with the following symbols:\r\n  - destroy\r\n-/+ destroy and then create replacement\r\n\r\nTerraform will perform the following actions:\r\n\r\n  # google_compute_resource_policy.instance_schedule must be replaced\r\n-/+ resource \"google_compute_resource_policy\" \"instance_schedule\" {\r\n      ~ id          = \"projects/my-project-id/regions/europe-west1/resourcePolicies/my-instance-schedule\" -> (known after apply)\r\n        name        = \"my-instance-schedule\"\r\n      ~ project     = \"my-project-id\" -> (known after apply)\r\n      ~ region      = \"https://www.googleapis.com/compute/v1/projects/my-project-id/regions/europe-west1\" -> \"europe-west1\"\r\n      ~ self_link   = \"https://www.googleapis.com/compute/v1/projects/my-project-id/regions/europe-west1/resourcePolicies/my-instance-schedule\" -> (known after apply)\r\n        # (1 unchanged attribute hidden)\r\n\r\n      ~ instance_schedule_policy {\r\n            # (1 unchanged attribute hidden)\r\n\r\n          ~ vm_start_schedule {\r\n              ~ schedule = \"0 9 * * *\" -> \"0 8 * * *\" # forces replacement\r\n            }\r\n\r\n            # (1 unchanged block hidden)\r\n        }\r\n    }\r\n\r\nPlan: 1 to add, 0 to change, 1 to destroy.\r\n\r\nDo you want to perform these actions in workspace \"prd\"?\r\n  Terraform will perform the actions described above.\r\n  Only 'yes' will be accepted to approve.\r\n\r\n  Enter a value: yes\r\n\r\ngoogle_compute_resource_policy.instance_schedule: Destroying... [id=projects/my-project-id/regions/europe-west1/resourcePolicies/my-instance-schedule]\r\n\r\nError: Error when reading or editing ResourcePolicy: googleapi: Error 400: The resource_policy resource 'projects/my-project-id/regions/europe-west1/resourcePolicies/my-instance-schedule' is already being used by 'projects/my-project-id/zones/europe-west1-b/instances/my-instance', resourceInUseByAnotherResource\r\n\r\n```\r\n\r\n\r\n**NB:** I am working with Terraform 0.14.7 and I am using google provider version 3.76.0\r\n\r\n  [1]: https://registry.terraform.io/providers/hashicorp/google/latest/docs/resources/compute_instance#resource_policies", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "This is an essential feature for optimizing the cost of cloud instances though, so I'm probably missing out on a few things, thanks for your tips and ideas! ", "keywords": ["cost", "feature"]}, {"source": "Text", "text": "I want to create an instance and manage its start and stop daily, programmatically. ", "keywords": ["instance"]}, {"source": "Text", "text": "However, when I change the stop or start time, Terraform plans to destroy and recreate the instance... which I absolutely don't want! ", "keywords": ["instance", "change"]}, {"source": "Text", "text": "The resource \"google_compute_resource_policy\" is attached to the instance via the argument [resource_policies][1] where it is specified: \"Modifying this list will cause the instance to recreate.\" ", "keywords": ["instance"]}, {"source": "Text", "text": "It is true that it is not possible to update a scheduler, whereas it is perfectly possible to detach it manually from the instance, then to destroy it before recreating it with the new stop/start schedule and the attach to the instance again. ", "keywords": ["instance"]}, {"source": "Text", "text": "I tried to add an \"ignore_changes\" lifecycle on the \"resource_policies\" argument of my instance, Terraform no longer wants to destroy my instance, but it gives me the following error: ``` ", "keywords": ["instance"]}, {"source": "Text", "text": "Error when reading or editing ResourcePolicy: googleapi: Error 400: The resource_policy resource 'projects/my-project-id/regions/europe-west1/resourcePolicies/my-instance-schedule' is already being used by 'projects/my-project-id/zones/europe-west1-b/instances/my-instance', resourceInUseByAnotherResource\" ``` Here is my Terraform code ``` resource \"google_compute_resource_policy\" \"instance_schedule\" { name = \"my-instance-schedule\" region = var.region description = \"Start and stop instance\" instance_schedule_policy { vm_start_schedule { schedule = var.vm_start_schedule } vm_stop_schedule { schedule = var.vm_stop_schedule } time_zone = \"Europe/Paris\" } } resource \"google_compute_instance\" \"my-instance\" { // ******** This is my attempted workaround ******** lifecycle { ignore_changes = [resource_policies] } name = \"my-instance\" machine_type = var.machine_type zone = \"${var.region}-b\" allow_stopping_for_update = true resource_policies = [ google_compute_resource_policy.instance_schedule.id ] boot_disk { device_name = local.ref_name initialize_params { image = var.boot_disk_image type = var.disk_type size = var.disk_size } } network_interface { network = data.google_compute_network.default.name access_config { nat_ip = google_compute_address.static.address } } } ``` ", "keywords": ["instance"]}, {"source": "Text", "text": "Resource actions are indicated with the following symbols: - destroy -/+ destroy and then create replacement Terraform will perform the following actions: # google_compute_resource_policy.instance_schedule must be replaced -/+ resource \"google_compute_resource_policy\" \"instance_schedule\" { ~ id = \"projects/my-project-id/regions/europe-west1/resourcePolicies/my-instance-schedule\" -> (known after apply) name = \"my-instance-schedule\" ~ project = \"my-project-id\" -> (known after apply) ~ region = \"https://www.googleapis.com/compute/v1/projects/my-project-id/regions/europe-west1\" -> \"europe-west1\" ~ self_link = \"https://www.googleapis.com/compute/v1/projects/my-project-id/regions/europe-west1/resourcePolicies/my-instance-schedule\" -> (known after apply) # (1 unchanged attribute hidden) ~ instance_schedule_policy { # (1 unchanged attribute hidden) ~ vm_start_schedule { ~ schedule = \"0 9 * * *\" -> \"0 8 * * *\" # forces replacement } # (1 unchanged block hidden) } } Plan: 1 to add, 0 to change, 1 to destroy. ", "keywords": ["instance", "change"]}, {"source": "Text", "text": "Enter a value: yes google_compute_resource_policy.instance_schedule: Destroying... [id=projects/my-project-id/regions/europe-west1/resourcePolicies/my-instance-schedule] Error: Error when reading or editing ResourcePolicy: googleapi: Error 400: The resource_policy resource 'projects/my-project-id/regions/europe-west1/resourcePolicies/my-instance-schedule' is already being used by 'projects/my-project-id/zones/europe-west1-b/instances/my-instance', resourceInUseByAnotherResource ``` **NB:** I am working with Terraform 0.14.7 and I am using google provider version 3.76.0 [1]: https://registry.terraform.io/providers/hashicorp/google/latest/docs/resources/compute_instance#resource_policies", "keywords": ["instance", "provider"]}]}], "answers": [{"Id": "68989759", "PostTypeId": "2", "ParentId": "68986334", "CreationDate": "2021-08-30T20:07:33.707", "Score": "1", "Body": "<p>An instance inside GCP can be power off without destroy it with the module <a href=\"https://registry.terraform.io/providers/hashicorp/google/latest/docs/resources/compute_instance\" rel=\"nofollow noreferrer\">google_compute_instance</a> using the argument <a href=\"https://registry.terraform.io/providers/hashicorp/google/latest/docs/resources/compute_instance#desired_status\" rel=\"nofollow noreferrer\">desired_status</a>, keep in mind that if you are creating the instance for the first time this argument needs to be on \u201cRUNNING\u201d. This module can be used as the following.</p>\n<pre><code>resource &quot;google_compute_instance&quot; &quot;default&quot; {\n  name         = &quot;test&quot;\n  machine_type = &quot;f1-micro&quot;\n  zone         = &quot;us-west1-a&quot;\n  desired_status = &quot;RUNNING&quot;\n}\n</code></pre>\n<p>You can also modify your \u201cmain.tf\u201d file if you need to stop the VM first and then started creating a <a href=\"https://learn.hashicorp.com/tutorials/terraform/dependencies#manage-explicit-dependencies\" rel=\"nofollow noreferrer\">dependency in terraform</a> with depends_on.</p>\n<p>As you can see in the following comment, the service account will be created but the key will be assigned until the first sentence is done.</p>\n<pre><code>resource &quot;google_service_account&quot; &quot;service_account&quot; { \n   account_id = &quot;terraform-test&quot; \n   display_name = &quot;Service Account&quot;\n}\n\nresource &quot;google_service_account_key&quot; &quot;mykey&quot; {\n  service_account_id = google_service_account.service_account.id \n  public_key_type = &quot;TYPE_X509_PEM_FILE&quot; \n  depends_on = [google_service_account.service_account]\n}\n</code></pre>\n<p>If the first component already exists, terraform only deploys the dependent.</p>\n", "OwnerUserId": "16344509", "LastActivityDate": "2021-08-30T20:07:33.707", "CommentCount": "1", "ContentLicense": "CC BY-SA 4.0", "comments": [{"Id": "121936394", "PostId": "68989759", "Score": "0", "Text": "Thanks for your proposition @Nadia Espinosa\nHowever, this does not seem to solve my problem. Adding the \"desired_status\" argument on \"RUNNING\" value indeed generates the same behavior of the instance (its destruction) when the \"google_compute_resource_policy\" resource is modified", "CreationDate": "2021-08-31T07:04:02.317", "UserId": "10701542", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "Adding the \"desired_status\" argument on \"RUNNING\" value indeed generates the same behavior of the instance (its destruction) when the \"google_compute_resource_policy\" resource is modified", "keywords": ["instance"]}]}], "history": [{"Id": "252886746", "PostHistoryTypeId": "2", "PostId": "68989759", "RevisionGUID": "6c5a10c9-5838-4f67-b30c-eff0344feba4", "CreationDate": "2021-08-30T20:07:33.707", "UserId": "16344509", "Text": "An instance inside GCP can be power off without destroy it with the module [google_compute_instance](https://registry.terraform.io/providers/hashicorp/google/latest/docs/resources/compute_instance) using the argument [desired_status](https://registry.terraform.io/providers/hashicorp/google/latest/docs/resources/compute_instance#desired_status), keep in mind that if you are creating the instance for the first time this argument needs to be on \u201cRUNNING\u201d. This module can be used as the following.\r\n\r\n```\r\nresource \"google_compute_instance\" \"default\" {\r\n  name         = \"test\"\r\n  machine_type = \"f1-micro\"\r\n  zone         = \"us-west1-a\"\r\n  desired_status = \"RUNNING\"\r\n}\r\n```\r\n\r\nYou can also modify your \u201cmain.tf\u201d file if you need to stop the VM first and then started creating a [dependency in terraform](https://learn.hashicorp.com/tutorials/terraform/dependencies#manage-explicit-dependencies) with depends_on.\r\n\r\nAs you can see in the following comment, the service account will be created but the key will be assigned until the first sentence is done.\r\n \r\n```\r\nresource \"google_service_account\" \"service_account\" { \r\n   account_id = \"terraform-test\" \r\n   display_name = \"Service Account\"\r\n}\r\n\r\nresource \"google_service_account_key\" \"mykey\" {\r\n  service_account_id = google_service_account.service_account.id \r\n  public_key_type = \"TYPE_X509_PEM_FILE\" \r\n  depends_on = [google_service_account.service_account]\r\n}\r\n```\r\n\r\nIf the first component already exists, terraform only deploys the dependent.", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "An instance inside GCP can be power off without destroy it with the module [google_compute_instance](https://registry.terraform.io/providers/hashicorp/google/latest/docs/resources/compute_instance) using the argument [desired_status](https://registry.terraform.io/providers/hashicorp/google/latest/docs/resources/compute_instance#desired_status), keep in mind that if you are creating the instance for the first time this argument needs to be on \u201cRUNNING\u201d. ", "keywords": ["instance"]}, {"source": "Text", "text": "``` resource \"google_compute_instance\" \"default\" { name = \"test\" machine_type = \"f1-micro\" zone = \"us-west1-a\" desired_status = \"RUNNING\" } ``` ", "keywords": ["test"]}, {"source": "Text", "text": "``` resource \"google_service_account\" \"service_account\" { account_id = \"terraform-test\" display_name = \"Service Account\" } resource \"google_service_account_key\" \"mykey\" { service_account_id = google_service_account.service_account.id public_key_type = \"TYPE_X509_PEM_FILE\" depends_on = [google_service_account.service_account] } ``` ", "keywords": ["test"]}]}], "filtered-sentences": [{"source": "Body", "text": "An instance inside GCP can be power off without destroy it with the module google_compute_instance using the argument desired_status, keep in mind that if you are creating the instance for the first time this argument needs to be on \u201cRUNNING\u201d. ", "keywords": ["instance"]}]}, {"Id": "71967314", "PostTypeId": "2", "ParentId": "68986334", "CreationDate": "2022-04-22T10:31:51.860", "Score": "0", "Body": "<p>I solved the &quot;resourceInUseByAnotherResource&quot; error by adding the following lifecycle to the google_compute_resource_policy resource:</p>\n<pre><code>lifecycle {\n  create_before_destroy = true\n}\n</code></pre>\n<p>Also, this requires to have a unique name with each change, otherwise, the new resource can't be created, because the resource with the same name already exists. So I appended a random ID to the end of the schedule name:</p>\n<pre><code>resource &quot;random_pet&quot; &quot;schedule&quot; {\n  keepers = {\n    start_schedule = &quot;${var.vm_start_schedule}&quot;\n    stop_schedule  = &quot;${var.vm_stop_schedule}&quot;\n  }\n}\n...\nresource &quot;google_compute_resource_policy&quot; &quot;schedule&quot; {\n  name = &quot;schedule-${random_pet.schedule.id}&quot;\n  ...\n  lifecycle {\n     create_before_destroy = true\n  }\n}\n</code></pre>\n", "OwnerUserId": "8175198", "LastActivityDate": "2022-04-22T10:31:51.860", "CommentCount": "0", "ContentLicense": "CC BY-SA 4.0", "history": [{"Id": "268671221", "PostHistoryTypeId": "2", "PostId": "71967314", "RevisionGUID": "1c09c978-c472-41ab-8f77-eeb1689e0bb2", "CreationDate": "2022-04-22T10:31:51.860", "UserId": "8175198", "Text": "I solved the \"resourceInUseByAnotherResource\" error by adding the following lifecycle to the google_compute_resource_policy resource:\r\n\r\n    lifecycle {\r\n      create_before_destroy = true\r\n    }\r\nAlso, this requires to have a unique name with each change, otherwise, the new resource can't be created, because the resource with the same name already exists. So I appended a random ID to the end of the schedule name:\r\n\r\n    resource \"random_pet\" \"schedule\" {\r\n      keepers = {\r\n        start_schedule = \"${var.vm_start_schedule}\"\r\n        stop_schedule  = \"${var.vm_stop_schedule}\"\r\n      }\r\n    }\r\n    ...\r\n    resource \"google_compute_resource_policy\" \"schedule\" {\r\n      name = \"schedule-${random_pet.schedule.id}\"\r\n      ...\r\n      lifecycle {\r\n         create_before_destroy = true\r\n      }\r\n    }", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "I solved the \"resourceInUseByAnotherResource\" error by adding the following lifecycle to the google_compute_resource_policy resource: lifecycle { create_before_destroy = true } Also, this requires to have a unique name with each change, otherwise, the new resource can't be created, because the resource with the same name already exists. ", "keywords": ["change"]}]}], "filtered-sentences": [{"source": "Body", "text": "I solved the \"resourceInUseByAnotherResource\" error by adding the following lifecycle to the google_compute_resource_policy resource: Also, this requires to have a unique name with each change, otherwise, the new resource can't be created, because the resource with the same name already exists. ", "keywords": ["change"]}]}, {"Id": "70262764", "PostTypeId": "2", "ParentId": "68986334", "CreationDate": "2021-12-07T15:25:06.337", "Score": "0", "Body": "<p>I faced same problem with snapshot policy.</p>\n<p>I controlled resource policy creation using a flag input variable and using count. For the first time, I created policy resource using flag as 'true'. When I want to change schedule time, I change the flag as 'false' and apply the plan. This will detach the resource.</p>\n<p>I then make flag as 'true' again and apply the plan with new time.</p>\n<p>This worked for me for snapshot policy. Hope it could solve yours too.</p>\n", "OwnerUserId": "17616084", "LastActivityDate": "2021-12-07T15:25:06.337", "CommentCount": "0", "ContentLicense": "CC BY-SA 4.0", "history": [{"Id": "259563711", "PostHistoryTypeId": "2", "PostId": "70262764", "RevisionGUID": "0d6940c4-f081-42e7-aaa0-ab07bc52dde0", "CreationDate": "2021-12-07T15:25:06.337", "UserId": "17616084", "Text": "I faced same problem with snapshot policy. \r\n\r\nI controlled resource policy creation using a flag input variable and using count. For the first time, I created policy resource using flag as 'true'. When I want to change schedule time, I change the flag as 'false' and apply the plan. This will detach the resource. \r\n\r\nI then make flag as 'true' again and apply the plan with new time.\r\n\r\nThis worked for me for snapshot policy. Hope it could solve yours too.", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "I faced same problem with snapshot policy. ", "keywords": ["policy"]}, {"source": "Text", "text": "I controlled resource policy creation using a flag input variable and using count. ", "keywords": ["policy"]}, {"source": "Text", "text": "For the first time, I created policy resource using flag as 'true'. ", "keywords": ["policy"]}, {"source": "Text", "text": "When I want to change schedule time, I change the flag as 'false' and apply the plan. ", "keywords": ["change"]}, {"source": "Text", "text": "This worked for me for snapshot policy. ", "keywords": ["policy"]}]}], "filtered-sentences": [{"source": "Body", "text": "I faced same problem with snapshot policy. ", "keywords": ["policy"]}, {"source": "Body", "text": "I controlled resource policy creation using a flag input variable and using count. ", "keywords": ["policy"]}, {"source": "Body", "text": "For the first time, I created policy resource using flag as 'true'. ", "keywords": ["policy"]}, {"source": "Body", "text": "When I want to change schedule time, I change the flag as 'false' and apply the plan. ", "keywords": ["change"]}, {"source": "Body", "text": "This worked for me for snapshot policy. ", "keywords": ["policy"]}]}], "contains-topic": true, "filtered-sentences": [{"source": "Body", "text": "This is an essential feature for optimizing the cost of cloud instances though, so I'm probably missing out on a few things, thanks for your tips and ideas! ", "keywords": ["cost", "feature"]}, {"source": "Body", "text": "I want to create an instance and manage its start and stop daily, programmatically. ", "keywords": ["instance"]}, {"source": "Body", "text": "However, when I change the stop or start time, Terraform plans to destroy and recreate the instance... which I absolutely don't want! ", "keywords": ["instance", "change"]}, {"source": "Body", "text": "The resource \"google_compute_resource_policy\" is attached to the instance via the argument resource_policies where it is specified: \"Modifying this list will cause the instance to recreate.\" ", "keywords": ["instance"]}, {"source": "Body", "text": "It is true that it is not possible to update a scheduler, whereas it is perfectly possible to detach it manually from the instance, then to destroy it before recreating it with the new stop/start schedule and the attach to the instance again. ", "keywords": ["instance"]}, {"source": "Body", "text": "I tried to add an \"ignore_changes\" lifecycle on the \"resource_policies\" argument of my instance, Terraform no longer wants to destroy my instance, but it gives me the following error: ", "keywords": ["instance"]}, {"source": "Body", "text": "If it can be useful, here is what the terraform apply returns NB: I am working with Terraform 0.14.7 and I am using google provider version 3.76.0", "keywords": ["provider"]}]}