{"Id": "63917235", "PostTypeId": "1", "CreationDate": "2020-09-16T09:37:38.107", "Score": "0", "ViewCount": "739", "Body": "<p>To provision tag policies in an AWS organization, I need to build the JSON <code>content</code> from variables. Management of tag policies, scp, etc. shall be centralized, so changes can be applied everywhere: Renaming, adding, removing tags, etc.</p>\n<pre><code>terraform {\n  required_providers {\n    aws = {\n      source = &quot;hashicorp/aws&quot;\n    }\n  }\n}\nprovider &quot;aws&quot; {\n  profile = &quot;default&quot;\n  region  = &quot;us-west-1&quot;\n}\n</code></pre>\n<p>The problem at hand I am facing is: How would I build the JSON object?</p>\n<p>Example variable/ tag map:</p>\n<pre><code># tag_policies.tf\nvariable &quot;resource_tags&quot; {\n  description = &quot;Central resource tags&quot;\n  type = list( object( {\n    name = string\n    tags = map(string)\n  } ) )\n  default = [\n    {\n      name = &quot;Environment&quot;\n      tags = {\n        prod = &quot;crn::env:prod&quot;\n        lab = &quot;crn::env:lab&quot;\n        dev = &quot;crn::env:dev&quot;\n      }\n    }\n  ]\n}\n</code></pre>\n<p>What I have tried so far is to use HCL template tags, but I end up with one <code>,</code> comma too much when iterating through the map of tag names. This works fine for the <code>join()</code> with the sub-map of tag names, but does not workout if I try to wrap the template markup. <em>Why did I try this? Because I ran out of ideas.</em></p>\n<pre><code># vars.tf\nresource &quot;aws_organizations_policy&quot; &quot;root-tag-policy&quot; {\n  name = &quot;RootTagPolicy&quot;\n  type = &quot;TAG_POLICY&quot;\n\n  content = &lt;&lt;CONTENT\n{\n  &quot;tags&quot;: {\n    %{ for tag in var.resource_tags_env ~}\n      &quot;${tag.name}&quot;: {\n        &quot;tag_key&quot;: {\n          &quot;@@assign&quot;: &quot;${tag.name}&quot;,\n          &quot;@@operators_allowed_for_child_policies&quot;: [ &quot;@@none&quot; ]\n        },\n        &quot;tag_value&quot;: { &quot;@@assign&quot;: [ &quot;${join( &quot;, &quot;, values( tag.tags ) )}&quot; ] }\n      },\n    %{ endfor ~}\n  }\n}\nCONTENT\n}\n</code></pre>\n", "OwnerUserId": "376483", "LastActivityDate": "2020-09-16T22:24:34.163", "Title": "Terraform 0.12 AWS resource containing JSON built from variable", "Tags": "<json><amazon-web-services><terraform><terraform-provider-aws><hcl>", "AnswerCount": "3", "CommentCount": "0", "ContentLicense": "CC BY-SA 4.0", "history": [{"Id": "230927445", "PostHistoryTypeId": "2", "PostId": "63917235", "RevisionGUID": "166c26bc-9901-4437-aa3d-3e5218f96d83", "CreationDate": "2020-09-16T09:37:38.107", "UserId": "376483", "Text": "To provision tag policies in an AWS organization, I need to build the JSON `content` from variables. Management of tag policies, scp, etc. shall be centralized, so changes can be applied everywhere: Renaming, adding, removing tags, etc.\r\n\r\n```hcl\r\nterraform {\r\n  required_providers {\r\n    aws = {\r\n      source = \"hashicorp/aws\"\r\n    }\r\n  }\r\n}\r\nprovider \"aws\" {\r\n  profile = \"default\"\r\n  region  = \"us-west-1\"\r\n}\r\n```\r\n\r\nThe problem at hand I am facing is: How would I build the JSON object?\r\n\r\nExample variable/ tag map:\r\n```hcl\r\n# tag_policies.tf\r\nvariable \"resource_tags\" {\r\n  description = \"Central resource tags\"\r\n  type = list( object( {\r\n    name = string\r\n    tags = map(string)\r\n  } ) )\r\n  default = [\r\n    {\r\n      name = \"Environment\"\r\n      tags = {\r\n        prod = \"crn::env:prod\"\r\n        lab = \"crn::env:lab\"\r\n        dev = \"crn::env:dev\"\r\n      }\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\nWhat I have tried so far is to use HCL template tags, but I end up with one `,` comma too much when iterating through the map of tag names. This works fine for the `join()` with the sub-map of tag names, but does not workout if I try to wrap the template markup. _Why did I try this? Because I ran out of ideas._\r\n\r\n```hcl\r\n# vars.tf\r\nresource \"aws_organizations_policy\" \"root-tag-policy\" {\r\n  name = \"RootTagPolicy\"\r\n  type = \"TAG_POLICY\"\r\n\r\n  content = <<CONTENT\r\n{\r\n  \"tags\": {\r\n    %{ for tag in var.resource_tags_env ~}\r\n      \"${tag.name}\": {\r\n        \"tag_key\": {\r\n          \"@@assign\": \"${tag.name}\",\r\n          \"@@operators_allowed_for_child_policies\": [ \"@@none\" ]\r\n        },\r\n        \"tag_value\": { \"@@assign\": [ \"${join( \", \", values( tag.tags ) )}\" ] }\r\n      },\r\n    %{ endfor ~}\r\n  }\r\n}\r\nCONTENT\r\n}\r\n```", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "Management of tag policies, scp, etc. shall be centralized, so changes can be applied everywhere: Renaming, adding, removing tags, etc. ```hcl terraform { required_providers { aws = { source = \"hashicorp/aws\" } } } provider \"aws\" { profile = \"default\" region = \"us-west-1\" } ``` ", "keywords": ["provider", "change"]}, {"source": "Text", "text": "_Why did I try this? Because I ran out of ideas._ ```hcl # vars.tf resource \"aws_organizations_policy\" \"root-tag-policy\" { name = \"RootTagPolicy\" type = \"TAG_POLICY\" content = <<CONTENT { \"tags\": { %{ for tag in var.resource_tags_env ~} \"${tag.name}\": { \"tag_key\": { \"@@assign\": \"${tag.name}\", \"@@operators_allowed_for_child_policies\": [ \"@@none\" ] }, \"tag_value\": { \"@@assign\": [ \"${join( \", \", values( tag.tags ) )}\" ] } }, %{ endfor ~} } } CONTENT } ```", "keywords": ["policy"]}]}, {"Id": "230927446", "PostHistoryTypeId": "1", "PostId": "63917235", "RevisionGUID": "166c26bc-9901-4437-aa3d-3e5218f96d83", "CreationDate": "2020-09-16T09:37:38.107", "UserId": "376483", "Text": "Terraform 0.12 AWS resource containing JSON built from variable", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "230927447", "PostHistoryTypeId": "3", "PostId": "63917235", "RevisionGUID": "166c26bc-9901-4437-aa3d-3e5218f96d83", "CreationDate": "2020-09-16T09:37:38.107", "UserId": "376483", "Text": "<json><amazon-web-services><terraform><terraform-provider-aws><hcl>", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "answers": [{"Id": "63917236", "PostTypeId": "2", "ParentId": "63917235", "CreationDate": "2020-09-16T09:37:38.107", "Score": "1", "Body": "<p>The solution actually was quite simple: Iterate of the tags using a <a href=\"https://www.terraform.io/docs/configuration/expressions.html#for-expressions\" rel=\"nofollow noreferrer\"><code>for</code> expression</a> and enclose it with curly braces <code>{ \u2026\u00a0}</code> to return an object (<code>=&gt;</code> returns tuples).</p>\n<p>Finally <code>jsonencode()</code> cares about converting the HCL <code>key = value</code> syntax to proper JSON.</p>\n<pre><code>resource &quot;aws_organizations_policy&quot; &quot;root-tag-policy&quot; {\n  name = &quot;RootTagPolicy&quot;\n  type = &quot;TAG_POLICY&quot;\n\n  content = jsonencode( [ for key, tag in var.resource_tags: {\n    &quot;${tag.name}&quot; = {\n      &quot;tag_key&quot; = {\n        &quot;@@assign&quot; = tag.name,\n        &quot;@@operators_allowed_for_child_policies&quot; = [ &quot;@@none&quot; ]\n      },\n      &quot;tag_value&quot; = { &quot;@@assign&quot; = [ join( &quot;, &quot;, values( tag.tags ) ) ] }\n    }\n  } ] )\n}\n</code></pre>\n<p><strong>EDIT</strong> This still does not work, as I forgot that the whole JSON object needs to get wrapped inside a <code>tags: {}</code>.</p>\n", "OwnerUserId": "376483", "LastEditorUserId": "376483", "LastEditDate": "2020-09-16T10:29:39.783", "LastActivityDate": "2020-09-16T10:29:39.783", "CommentCount": "0", "ContentLicense": "CC BY-SA 4.0", "history": [{"Id": "230927450", "PostHistoryTypeId": "2", "PostId": "63917236", "RevisionGUID": "45f26bc6-a6b9-4587-bb78-8bbd76fb47ea", "CreationDate": "2020-09-16T09:37:38.107", "UserId": "376483", "Text": "The solution actually was quite simple: Iterate of the tags using a [`for` expression](https://www.terraform.io/docs/configuration/expressions.html#for-expressions) and enclose it with curly braces `{ \u2026\u00a0}` to return an object (`=>` returns tuples).\r\n\r\nFinally `jsonencode()` cares about converting the HCL `key = value` syntax to proper JSON.\r\n\r\n```hcl\r\nresource \"aws_organizations_policy\" \"root-tag-policy\" {\r\n  name = \"RootTagPolicy\"\r\n  type = \"TAG_POLICY\"\r\n\r\n  content = jsonencode( [ for key, tag in var.resource_tags: {\r\n    \"${tag.name}\" = {\r\n      \"tag_key\" = {\r\n        \"@@assign\" = tag.name,\r\n        \"@@operators_allowed_for_child_policies\" = [ \"@@none\" ]\r\n      },\r\n      \"tag_value\" = { \"@@assign\" = [ join( \", \", values( tag.tags ) ) ] }\r\n    }\r\n  } ] )\r\n}\r\n```", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "```hcl resource \"aws_organizations_policy\" \"root-tag-policy\" { name = \"RootTagPolicy\" type = \"TAG_POLICY\" content = jsonencode( [ for key, tag in var.resource_tags: { \"${tag.name}\" = { \"tag_key\" = { \"@@assign\" = tag.name, \"@@operators_allowed_for_child_policies\" = [ \"@@none\" ] }, \"tag_value\" = { \"@@assign\" = [ join( \", \", values( tag.tags ) ) ] } } } ] ) } ```", "keywords": ["policy"]}]}, {"Id": "230931015", "PostHistoryTypeId": "5", "PostId": "63917236", "RevisionGUID": "235fa1a7-9450-4a83-9c58-3128f2c2c781", "CreationDate": "2020-09-16T10:29:39.783", "UserId": "376483", "Comment": "added 118 characters in body", "Text": "The solution actually was quite simple: Iterate of the tags using a [`for` expression](https://www.terraform.io/docs/configuration/expressions.html#for-expressions) and enclose it with curly braces `{ \u2026\u00a0}` to return an object (`=>` returns tuples).\r\n\r\nFinally `jsonencode()` cares about converting the HCL `key = value` syntax to proper JSON.\r\n\r\n```hcl\r\nresource \"aws_organizations_policy\" \"root-tag-policy\" {\r\n  name = \"RootTagPolicy\"\r\n  type = \"TAG_POLICY\"\r\n\r\n  content = jsonencode( [ for key, tag in var.resource_tags: {\r\n    \"${tag.name}\" = {\r\n      \"tag_key\" = {\r\n        \"@@assign\" = tag.name,\r\n        \"@@operators_allowed_for_child_policies\" = [ \"@@none\" ]\r\n      },\r\n      \"tag_value\" = { \"@@assign\" = [ join( \", \", values( tag.tags ) ) ] }\r\n    }\r\n  } ] )\r\n}\r\n```\r\n\r\n**EDIT** This still does not work, as I forgot that the whole JSON object needs to get wrapped inside a `tags: {}`.", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "```hcl resource \"aws_organizations_policy\" \"root-tag-policy\" { name = \"RootTagPolicy\" type = \"TAG_POLICY\" content = jsonencode( [ for key, tag in var.resource_tags: { \"${tag.name}\" = { \"tag_key\" = { \"@@assign\" = tag.name, \"@@operators_allowed_for_child_policies\" = [ \"@@none\" ] }, \"tag_value\" = { \"@@assign\" = [ join( \", \", values( tag.tags ) ) ] } } } ] ) } ``` ", "keywords": ["policy"]}]}], "filtered-sentences": []}, {"Id": "63928705", "PostTypeId": "2", "ParentId": "63917235", "CreationDate": "2020-09-16T22:24:34.163", "Score": "0", "Body": "<p>After reading @martin-atkins answer, I finally understood how the <code>for</code> works for <code>objects</code> and <code>maps</code>. The var <em>before</em> the <code>=&gt;</code> arrow actually is part of the resulting object. (This highly confused me as I compared it to other languages arrow functions and arguments.)</p>\n<p>The first part of the process is to build a map of maps. The main reason is that I don't want to have a <em>convention</em> of a <code>name</code> key in a map of variables. This might lead to handling of conventions later on, what should be avoided at all costs as it is a possible trap if one does not pay close attention or is aware of it. So the <code>key</code> actually is the <code>name</code> now.</p>\n<h3>Data Structure</h3>\n<pre><code>variable &quot;resource_tags&quot; {\n  description = &quot;Central resource tags&quot;\n  type = map(\n    map(string)\n  )\n  default = {\n    Environment = {\n      common = &quot;grn::env:common&quot;\n      prod = &quot;grn::env:prod&quot;\n      stage = &quot;grn::env:stage&quot;\n      dev = &quot;grn::env:dev&quot;\n      demo = &quot;grn::env:demo&quot;\n      lab = &quot;grn::env:lab&quot;\n    },\n    Foo = {\n      bar = &quot;baz&quot;\n    }\n  }\n}\n</code></pre>\n<h3>The <code>content</code> as JSON</h3>\n<p>After understanding that the key in <code>{ &quot;tags&quot;: { \u2026 } }</code> is just the part before the <code>=&gt;</code>, I could reduce the final resource to the following block.</p>\n<pre><code>resource &quot;aws_organizations_policy&quot; &quot;root-tag-policy&quot; {\n  name = &quot;RootTagPolicy&quot;\n  description = &quot;Tag policies, assigned to the root org.&quot;\n  type = &quot;TAG_POLICY&quot;\n\n  content = jsonencode({\n    tags = {\n      for key, tags in var.resource_tags : key =&gt; {\n        tag_key = {\n          &quot;@@assign&quot; = key\n          &quot;@@operators_allowed_for_child_policies&quot; = [&quot;@@none&quot;]\n        }\n        tag_value = {\n          &quot;@@assign&quot; = values( tags )\n        }\n      }\n    }\n  })\n}\n</code></pre>\n<h3>Quick test:</h3>\n<p>Add the following <code>output</code> statement after the <code>resource</code> block:</p>\n<pre><code>output &quot;debug&quot; {\n  value = aws_organizations_policy.tp_root-tag-policy.content\n}\n</code></pre>\n<p>Now <code>apply</code> (or <code>plan</code> or <code>refresh</code>) just this resource. It's faster this way. Then output the built <code>debug</code> from the <code>apply</code> or <code>refresh</code> run.</p>\n<pre class=\"lang-sh prettyprint-override\"><code>$ terraform apply -target=aws_organizations_policy.root-tag-policy\n\u2026things happening\u2026\n$ terraform output debug | json_pp\n</code></pre>\n<p><strong>ProTips:</strong></p>\n<ol>\n<li>Pipe the output of the <code>output</code> directly into <code>json_pp</code> or <code>jq</code> so you can read it.</li>\n<li>Use <code>jq .</code> if you want validation on top. If you see the output, it means it's valid. Else you should receive <code>0</code> as response.</li>\n</ol>\n", "OwnerUserId": "376483", "LastActivityDate": "2020-09-16T22:24:34.163", "CommentCount": "0", "ContentLicense": "CC BY-SA 4.0", "history": [{"Id": "230974592", "PostHistoryTypeId": "2", "PostId": "63928705", "RevisionGUID": "7e1465c9-c95a-40d9-937e-4e2663e8da1d", "CreationDate": "2020-09-16T22:24:34.163", "UserId": "376483", "Text": "After reading @martin-atkins answer, I finally understood how the `for` works for `objects` and `maps`. The var _before_ the `=>` arrow actually is part of the resulting object. (This highly confused me as I compared it to other languages arrow functions and arguments.)\r\n\r\nThe first part of the process is to build a map of maps. The main reason is that I don't want to have a _convention_ of a `name` key in a map of variables. This might lead to handling of conventions later on, what should be avoided at all costs as it is a possible trap if one does not pay close attention or is aware of it. So the `key` actually is the `name` now.\r\n\r\n### Data Structure\r\n\r\n```hcl\r\nvariable \"resource_tags\" {\r\n  description = \"Central resource tags\"\r\n  type = map(\r\n    map(string)\r\n  )\r\n  default = {\r\n    Environment = {\r\n      common = \"grn::env:common\"\r\n      prod = \"grn::env:prod\"\r\n      stage = \"grn::env:stage\"\r\n      dev = \"grn::env:dev\"\r\n      demo = \"grn::env:demo\"\r\n      lab = \"grn::env:lab\"\r\n    },\r\n    Foo = {\r\n      bar = \"baz\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### The `content` as JSON\r\n\r\nAfter understanding that the key in `{ \"tags\": { \u2026 } }` is just the part before the `=>`, I could reduce the final resource to the following block.\r\n\r\n```hcl\r\nresource \"aws_organizations_policy\" \"root-tag-policy\" {\r\n  name = \"RootTagPolicy\"\r\n  description = \"Tag policies, assigned to the root org.\"\r\n  type = \"TAG_POLICY\"\r\n\r\n  content = jsonencode({\r\n    tags = {\r\n      for key, tags in var.resource_tags : key => {\r\n        tag_key = {\r\n          \"@@assign\" = key\r\n          \"@@operators_allowed_for_child_policies\" = [\"@@none\"]\r\n        }\r\n        tag_value = {\r\n          \"@@assign\" = values( tags )\r\n        }\r\n      }\r\n    }\r\n  })\r\n}\r\n```\r\n\r\n### Quick test:\r\n\r\nAdd the following `output` statement after the `resource` block:\r\n```hcl\r\noutput \"debug\" {\r\n  value = aws_organizations_policy.tp_root-tag-policy.content\r\n}\r\n```\r\nNow `apply` (or `plan` or `refresh`) just this resource. It's faster this way. Then output the built `debug` from the `apply` or `refresh` run.\r\n\r\n```bash\r\n$ terraform apply -target=aws_organizations_policy.root-tag-policy\r\n\u2026things happening\u2026\r\n$ terraform output debug | json_pp\r\n```\r\n\r\n**ProTips:**\r\n1. Pipe the output of the `output` directly into `json_pp` or `jq` so you can read it. \r\n2. Use `jq .` if you want validation on top. If you see the output, it means it's valid. Else you should receive `0` as response.", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "This might lead to handling of conventions later on, what should be avoided at all costs as it is a possible trap if one does not pay close attention or is aware of it. ", "keywords": ["pay"]}, {"source": "Text", "text": "```hcl resource \"aws_organizations_policy\" \"root-tag-policy\" { name = \"RootTagPolicy\" description = \"Tag policies, assigned to the root org.\" type = \"TAG_POLICY\" content = jsonencode({ tags = { for key, tags in var.resource_tags : key => { tag_key = { \"@@assign\" = key \"@@operators_allowed_for_child_policies\" = [\"@@none\"] } tag_value = { \"@@assign\" = values( tags ) } } } }) } ``` ", "keywords": ["policy"]}, {"source": "Text", "text": "### Quick test: Add the following `output` statement after the `resource` block: ```hcl output \"debug\" { value = aws_organizations_policy.tp_root-tag-policy.content } ``` Now `apply` (or `plan` or `refresh`) just this resource. ", "keywords": ["policy", "test"]}, {"source": "Text", "text": "Then output the built `debug` from the `apply` or `refresh` run. ```bash $ terraform apply -target=aws_organizations_policy.root-tag-policy \u2026things happening\u2026 $ terraform output debug | json_pp ``` **ProTips:** 1. Pipe the output of the `output` directly into `json_pp` or `jq` so you can read it", "keywords": ["policy"]}]}], "filtered-sentences": [{"source": "Body", "text": "This might lead to handling of conventions later on, what should be avoided at all costs as it is a possible trap if one does not pay close attention or is aware of it. ", "keywords": ["pay"]}, {"source": "Body", "text": "Quick test: Add the following output statement after the resource block: Now apply (or plan or refresh) just this resource. ", "keywords": ["test"]}]}, {"Id": "63925652", "PostTypeId": "2", "ParentId": "63917235", "CreationDate": "2020-09-16T18:07:02.907", "Score": "1", "Body": "<p>kaiser's answer shows a good general approach: build a suitable data structure and then pass it to <a href=\"https://www.terraform.io/docs/configuration/functions/jsonencode.html\" rel=\"nofollow noreferrer\"><code>jsonencode</code></a> to get a valid JSON string from it.</p>\n<p>Here's an example that I think matches what the string template in the original question would've produced:</p>\n<pre><code>  content = jsonencode({\n    tags = {\n      for tag in var.resource_tags_env : tag.name =&gt; {\n        tag_key = {\n          &quot;@@assign&quot; = tag.name\n          &quot;@@operators_allowed_for_child_policies&quot; = [&quot;@@none&quot;]\n        }\n        tag_value = {\n          &quot;@@assign&quot; = values(tag.tags)\n        }\n      }\n    }\n  })\n</code></pre>\n<p>I'm not familiar with the <code>aws_organizations_policy</code> resource type so I'm sorry if I got some details wrong here, but hopefully you can adapt the above example to generate the JSON data structure you need.</p>\n", "OwnerUserId": "281848", "LastActivityDate": "2020-09-16T18:07:02.907", "CommentCount": "1", "ContentLicense": "CC BY-SA 4.0", "comments": [{"Id": "113045835", "PostId": "63925652", "Score": "0", "Text": "Thanks for stopping by and answering, Martin! You pushed me to the missing piece that could not understand from reading the docs: `key => { \u2026data\u2026 }` it is. I'll add another answer to show how I finally solved it (without using a `name` key). Couldn't have done it without your answer tough!", "CreationDate": "2020-09-16T22:12:26.960", "UserId": "376483", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "history": [{"Id": "230962194", "PostHistoryTypeId": "2", "PostId": "63925652", "RevisionGUID": "e93bdcb4-7fd8-4d3d-8a31-245cbcdf54b7", "CreationDate": "2020-09-16T18:07:02.907", "UserId": "281848", "Text": "kaiser's answer shows a good general approach: build a suitable data structure and then pass it to [`jsonencode`](https://www.terraform.io/docs/configuration/functions/jsonencode.html) to get a valid JSON string from it.\r\n\r\nHere's an example that I think matches what the string template in the original question would've produced:\r\n\r\n```\r\n  content = jsonencode({\r\n    tags = {\r\n      for tag in var.resource_tags_env : tag.name => {\r\n        tag_key = {\r\n          \"@@assign\" = tag.name\r\n          \"@@operators_allowed_for_child_policies\" = [\"@@none\"]\r\n        }\r\n        tag_value = {\r\n          \"@@assign\" = values(tag.tags)\r\n        }\r\n      }\r\n    }\r\n  })\r\n```\r\n\r\nI'm not familiar with the `aws_organizations_policy` resource type so I'm sorry if I got some details wrong here, but hopefully you can adapt the above example to generate the JSON data structure you need.\r\n", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "filtered-sentences": []}], "contains-topic": true, "filtered-sentences": [{"source": "Body", "text": "Management of tag policies, scp, etc. shall be centralized, so changes can be applied everywhere: Renaming, adding, removing tags, etc. ", "keywords": ["change"]}]}