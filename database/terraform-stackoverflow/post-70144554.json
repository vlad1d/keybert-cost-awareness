{"Id": "70144554", "PostTypeId": "1", "CreationDate": "2021-11-28T14:53:31.540", "Score": "5", "ViewCount": "5732", "Body": "<p>I am trying to create a GCP project with this:</p>\n<pre><code>module &quot;project-factory&quot; {\n  source  = &quot;terraform-google-modules/project-factory/google&quot;\n  version = &quot;11.2.3&quot;\n\n  name              = var.project_name\n  random_project_id = &quot;true&quot;\n  org_id            = var.organization_id\n  folder_id         = var.folder_id\n  billing_account   = var.billing_account\n  activate_apis = [\n    &quot;iam.googleapis.com&quot;,\n    &quot;run.googleapis.com&quot;\n  ]\n}\n</code></pre>\n<p>After that, I am trying to create a service account, like so:</p>\n<pre><code>module &quot;service_accounts&quot; {\n  source  = &quot;terraform-google-modules/service-accounts/google&quot;\n  version = &quot;4.0.3&quot;\n\n  project_id    = module.project-factory.project_id\n  generate_keys = &quot;true&quot;\n  names         = [&quot;backend-runner&quot;]\n  project_roles = [\n    &quot;${module.project-factory.project_id}=&gt;roles/cloudsql.client&quot;,\n    &quot;${module.project-factory.project_id}=&gt;roles/pubsub.publisher&quot;\n  ]\n}\n</code></pre>\n<p>To be honest, I am fairly new to Terraform. I have read a few answers on the topic (<a href=\"https://stackoverflow.com/questions/67476378/how-to-pull-a-subnet-id-based-on-the-cidr-block-in-terraform\">this</a> and <a href=\"https://stackoverflow.com/questions/67435352/how-to-fix-terraform-unpredict-instance-creation-issue\">this</a>) but I am unable to understand how that would apply here.</p>\n<p>I am getting the error:</p>\n<pre><code>\n\u2502 Error: Invalid for_each argument\n\u2502\n\u2502   on .terraform/modules/pubsub-exporter-service-account/main.tf line 47, in resource &quot;google_project_iam_member&quot; &quot;project-roles&quot;:\n\u2502   47:   for_each = local.project_roles_map_data\n\u2502     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u2502     \u2502 local.project_roles_map_data will be known only after apply\n\u2502\n\u2502 The &quot;for_each&quot; value depends on resource attributes that cannot be determined until apply, so Terraform cannot predict how many instances will be created. To work around this, use the\n\u2502 -target argument to first apply only the resources that the for_each depends on.\n</code></pre>\n<p>Looking forward to learn more about Terraform through this challenge.</p>\n", "OwnerUserId": "207426", "LastActivityDate": "2021-12-02T00:40:28.133", "Title": "How to solve for_each + \"Terraform cannot predict how many instances will be created\" issue?", "Tags": "<terraform><terraform-provider-gcp>", "AnswerCount": "1", "CommentCount": "3", "ContentLicense": "CC BY-SA 4.0", "comments": [{"Id": "123995136", "PostId": "70144554", "Score": "0", "Text": "Is the answer `use tags` to get around the issue?", "CreationDate": "2021-11-28T14:56:42.073", "UserId": "207426", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "123996282", "PostId": "70144554", "Score": "0", "Text": "Can you share the resource that is using ```for_each```?", "CreationDate": "2021-11-28T16:12:42.417", "UserId": "12125884", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "124001390", "PostId": "70144554", "Score": "0", "Text": "Your variables that you use in `for_each` must be know at compile time. It can't be dynamic.", "CreationDate": "2021-11-28T22:01:30.390", "UserId": "248823", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "links": [{"Id": "1952074155", "CreationDate": "2021-11-28T14:53:31.540", "PostId": "70144554", "RelatedPostId": "67476378", "LinkTypeId": "1"}, {"Id": "1952074156", "CreationDate": "2021-11-28T14:53:31.540", "PostId": "70144554", "RelatedPostId": "67435352", "LinkTypeId": "1"}], "history": [{"Id": "258930459", "PostHistoryTypeId": "2", "PostId": "70144554", "RevisionGUID": "7fdfb9a9-dbd7-465c-9ebb-4bf0d901db84", "CreationDate": "2021-11-28T14:53:31.540", "UserId": "207426", "Text": "I am trying to create a GCP project with this:\r\n\r\n```\r\nmodule \"project-factory\" {\r\n  source  = \"terraform-google-modules/project-factory/google\"\r\n  version = \"11.2.3\"\r\n\r\n  name              = var.project_name\r\n  random_project_id = \"true\"\r\n  org_id            = var.organization_id\r\n  folder_id         = var.folder_id\r\n  billing_account   = var.billing_account\r\n  activate_apis = [\r\n    \"iam.googleapis.com\",\r\n    \"run.googleapis.com\"\r\n  ]\r\n}\r\n```\r\n\r\nAfter that, I am trying to create a service account, like so:\r\n\r\n```\r\nmodule \"service_accounts\" {\r\n  source  = \"terraform-google-modules/service-accounts/google\"\r\n  version = \"4.0.3\"\r\n\r\n  project_id    = module.project-factory.project_id\r\n  generate_keys = \"true\"\r\n  names         = [\"backend-runner\"]\r\n  project_roles = [\r\n    \"${module.project-factory.project_id}=>roles/cloudsql.client\",\r\n    \"${module.project-factory.project_id}=>roles/pubsub.publisher\"\r\n  ]\r\n}\r\n```\r\n\r\nTo be honest, I am fairly new to Terraform. I have read a few answers on the topic ([this](https://stackoverflow.com/questions/67476378/how-to-pull-a-subnet-id-based-on-the-cidr-block-in-terraform) and [this](https://stackoverflow.com/questions/67435352/how-to-fix-terraform-unpredict-instance-creation-issue)) but I am unable to understand how that would apply here.\r\n\r\nI am getting the error:\r\n\r\n```\r\n\r\n\u2502 Error: Invalid for_each argument\r\n\u2502\r\n\u2502   on .terraform/modules/pubsub-exporter-service-account/main.tf line 47, in resource \"google_project_iam_member\" \"project-roles\":\r\n\u2502   47:   for_each = local.project_roles_map_data\r\n\u2502     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n\u2502     \u2502 local.project_roles_map_data will be known only after apply\r\n\u2502\r\n\u2502 The \"for_each\" value depends on resource attributes that cannot be determined until apply, so Terraform cannot predict how many instances will be created. To work around this, use the\r\n\u2502 -target argument to first apply only the resources that the for_each depends on.\r\n```\r\n\r\nLooking forward to learn more about Terraform through this challenge.", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "I am trying to create a GCP project with this: ``` module \"project-factory\" { source = \"terraform-google-modules/project-factory/google\" version = \"11.2.3\" name = var.project_name random_project_id = \"true\" org_id = var.organization_id folder_id = var.folder_id billing_account = var.billing_account activate_apis = [ \"iam.googleapis.com\", \"run.googleapis.com\" ] } ``` ", "keywords": ["bill"]}, {"source": "Text", "text": "I have read a few answers on the topic ([this](https://stackoverflow.com/questions/67476378/how-to-pull-a-subnet-id-based-on-the-cidr-block-in-terraform) and [this](https://stackoverflow.com/questions/67435352/how-to-fix-terraform-unpredict-instance-creation-issue)) but I am unable to understand how that would apply here. ", "keywords": ["instance"]}]}, {"Id": "258930461", "PostHistoryTypeId": "1", "PostId": "70144554", "RevisionGUID": "7fdfb9a9-dbd7-465c-9ebb-4bf0d901db84", "CreationDate": "2021-11-28T14:53:31.540", "UserId": "207426", "Text": "How to solve for_each + \"Terraform cannot predict how many instances will be created\" issue?", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "258930462", "PostHistoryTypeId": "3", "PostId": "70144554", "RevisionGUID": "7fdfb9a9-dbd7-465c-9ebb-4bf0d901db84", "CreationDate": "2021-11-28T14:53:31.540", "UserId": "207426", "Text": "<terraform><terraform-provider-gcp>", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "answers": [{"Id": "70192949", "PostTypeId": "2", "ParentId": "70144554", "CreationDate": "2021-12-02T00:40:28.133", "Score": "12", "Body": "<p>With only parts of the configuration visible here I'm guessing a little bit, but let's see. You mentioned that you'd like to learn more about Terraform as part of this exercise, so I'm going to go into a lot of detail about the chain here to explain <em>why</em> I'm recommending what I'm going to recommend, though you can skip to the end if you find this extra detail uninteresting.</p>\n<p>We'll start with <a href=\"https://github.com/terraform-google-modules/terraform-google-project-factory/blob/f5cce9e6851031065aa7afdc9ff1bf424352ccef/outputs.tf#L21-L23\" rel=\"noreferrer\">that first module's definition of its <code>project_id</code> output value</a>:</p>\n<pre><code>output &quot;project_id&quot; {\n  value = module.project-factory.project_id\n}\n</code></pre>\n<p><code>module.project-factory</code> here is referring to <a href=\"https://github.com/terraform-google-modules/terraform-google-project-factory/blob/f5cce9e6851031065aa7afdc9ff1bf424352ccef/main.tf#L28-L29\" rel=\"noreferrer\">a nested module call</a>, so we need to look one level deeper <a href=\"https://github.com/terraform-google-modules/terraform-google-project-factory/blob/f5cce9e6851031065aa7afdc9ff1bf424352ccef/modules/core_project_factory/outputs.tf#L21-L29\" rel=\"noreferrer\">in the nested module <code>terraform-google-modules/project-factory/google//modules/core_project_factory</code></a>:</p>\n<pre><code>output &quot;project_id&quot; {\n  value = module.project_services.project_id\n  depends_on = [\n    module.project_services,\n    google_project.main,\n    google_compute_shared_vpc_service_project.shared_vpc_attachment,\n    google_compute_shared_vpc_host_project.shared_vpc_host,\n  ]\n}\n</code></pre>\n<p>Another nested module call!  That one declares <a href=\"https://github.com/terraform-google-modules/terraform-google-project-factory/blob/master/modules/project_services/outputs.tf#L17-L20\" rel=\"noreferrer\">its <code>project_id</code></a> like this:</p>\n<pre><code>output &quot;project_id&quot; {\n  description = &quot;The GCP project you want to enable APIs on&quot;\n  value       = element(concat([for v in google_project_service.project_services : v.project], [var.project_id]), 0)\n}\n</code></pre>\n<p>Phew!  Finally an actual resource. This expression in this case seems to be taking the <code>project</code> attribute of a <code>google_project_service</code> resource instance, or potentially taking it from <code>var.project_id</code> if that resource was disabled in this instance of the module. Let's have a look at <a href=\"https://github.com/terraform-google-modules/terraform-google-project-factory/blob/f5cce9e6851031065aa7afdc9ff1bf424352ccef/modules/project_services/main.tf#L31-L37\" rel=\"noreferrer\">the <code>google_project_service.project_services</code> definition</a>:</p>\n<pre><code>resource &quot;google_project_service&quot; &quot;project_services&quot; {\n  for_each                   = local.services\n  project                    = var.project_id\n  service                    = each.value\n  disable_on_destroy         = var.disable_services_on_destroy\n  disable_dependent_services = var.disable_dependent_services\n}\n</code></pre>\n<p><code>project</code> here is set to <code>var.project_id</code>, so it seems like <em>either way</em> this innermost <code>project_id</code> output just reflects back the value of the <code>project_id</code> input variable, so we need to jump back up one level and look at <a href=\"https://github.com/terraform-google-modules/terraform-google-project-factory/blob/f5cce9e6851031065aa7afdc9ff1bf424352ccef/modules/core_project_factory/main.tf#L90-L98\" rel=\"noreferrer\">the module call</a> to this module to see what that was set to:</p>\n<pre><code>module &quot;project_services&quot; {\n  source = &quot;../project_services&quot;\n\n  project_id                  = google_project.main.project_id\n  activate_apis               = local.activate_apis\n  activate_api_identities     = var.activate_api_identities\n  disable_services_on_destroy = var.disable_services_on_destroy\n  disable_dependent_services  = var.disable_dependent_services\n}\n</code></pre>\n<p><code>project_id</code> is set to the <code>project_id</code> attribute of <a href=\"https://github.com/terraform-google-modules/terraform-google-project-factory/blob/f5cce9e6851031065aa7afdc9ff1bf424352ccef/modules/core_project_factory/main.tf#L65-L74\" rel=\"noreferrer\"><code>google_project.main</code></a>:</p>\n<pre><code>resource &quot;google_project&quot; &quot;main&quot; {\n  name                = var.name\n  project_id          = local.temp_project_id\n  org_id              = local.project_org_id\n  folder_id           = local.project_folder_id\n  billing_account     = var.billing_account\n  auto_create_network = var.auto_create_network\n\n  labels = var.labels\n}\n</code></pre>\n<p><code>project_id</code> here is set to <a href=\"https://github.com/terraform-google-modules/terraform-google-project-factory/blob/f5cce9e6851031065aa7afdc9ff1bf424352ccef/modules/core_project_factory/main.tf#L32-L36\" rel=\"noreferrer\"><code>local.temp_project_id</code></a>, which is declared further up in the same file:</p>\n<pre><code>  temp_project_id = var.random_project_id ? format(\n    &quot;%s-%s&quot;,\n    local.base_project_id,\n    random_id.random_project_id_suffix.hex,\n  ) : local.base_project_id\n</code></pre>\n<p>This expression includes a reference to <code>random_id.random_project_id_suffix.hex</code>, and <code>.hex</code> is a <em>result</em> attribute from <a href=\"https://registry.terraform.io/providers/hashicorp/random/latest/docs/resources/id\" rel=\"noreferrer\"><code>random_id</code></a>, and so its value won't be known until apply time due to how that <code>random_id</code> resource type is implemented. (It generates a random value during the apply step and saves it in the state so it'll stay consistent on future runs.)</p>\n<hr />\n<p>This means that (after all of this indirection) <code>module.project-factory.project_id</code> in <em>your</em> module is not a value defined statically in the configuration, and might instead be decided dynamically during the apply step. That means it's not an appropriate value to use as part of the instance key of a resource, and thus not appropriate to use as a key in a <code>for_each</code> map.</p>\n<p>Unfortunately the use of <code>for_each</code> here is hidden inside this other module <code>terraform-google-modules/service-accounts/google</code>, and so we'll need to have a look at that one too and see how it's making use of the <code>project_roles</code> input variable. First, let's look at <a href=\"https://github.com/terraform-google-modules/terraform-google-service-accounts/blob/c0e1fd11867cdf5a95aadc295c8f371a076ccce6/main.tf#L46-L66\" rel=\"noreferrer\">the specific resource block the error message was talking about</a>:</p>\n<pre><code>resource &quot;google_project_iam_member&quot; &quot;project-roles&quot; {\n  for_each = local.project_roles_map_data\n\n  project = element(\n    split(\n      &quot;=&gt;&quot;,\n      each.value.role\n    ),\n    0,\n  )\n\n  role = element(\n    split(\n      &quot;=&gt;&quot;,\n      each.value.role\n    ),\n    1,\n  )\n\n  member = &quot;serviceAccount:${google_service_account.service_accounts[each.value.name].email}&quot;\n}\n</code></pre>\n<p>There's a couple somewhat-complex things going on here, but the most relevant thing for what we're looking at here is that this resource configuration is creating multiple instances based on the content of <code>local.project_roles_map_data</code>. Let's look at <a href=\"https://github.com/terraform-google-modules/terraform-google-service-accounts/blob/c0e1fd11867cdf5a95aadc295c8f371a076ccce6/main.tf#L27-L33\" rel=\"noreferrer\"><code>local.project_roles_map_data</code></a> now:</p>\n<pre><code>  project_roles_map_data = zipmap(\n    [for pair in local.name_role_pairs : &quot;${pair[0]}-${pair[1]}&quot;],\n    [for pair in local.name_role_pairs : {\n      name = pair[0]\n      role = pair[1]\n    }]\n  )\n</code></pre>\n<p>A little more complexity here that isn't super important to what we're looking for; the main thing to consider here is that this is constructing a map whose keys are built from element zero and element one of <code>local.name_role_pairs</code>, which is declared directly above, along with <code>local.names</code> that it refers to:</p>\n<pre><code>  names                 = toset(var.names)\n  name_role_pairs       = setproduct(local.names, toset(var.project_roles))\n</code></pre>\n<p>So what we've learned here is that the values in <code>var.names</code> and the values in <code>var.project_roles</code> both contribute to the keys of the <code>for_each</code> on that resource, which means that neither of those variable values should contain anything decided dynamically during the apply step.</p>\n<p>However, we've also learned (above) that the <code>project</code> and <code>role</code> arguments of <code>google_project_iam_member.project-roles</code> are derived from the prefixes of elements in the two lists you provided as <code>names</code> and <code>project_roles</code> in your own module call.</p>\n<hr />\n<p>Let's return back to where we started then, with all of this extra information in mind:</p>\n<pre><code>module &quot;service_accounts&quot; {\n  source  = &quot;terraform-google-modules/service-accounts/google&quot;\n  version = &quot;4.0.3&quot;\n\n  project_id    = module.project-factory.project_id\n  generate_keys = &quot;true&quot;\n  names         = [&quot;backend-runner&quot;]\n  project_roles = [\n    &quot;${module.project-factory.project_id}=&gt;roles/cloudsql.client&quot;,\n    &quot;${module.project-factory.project_id}=&gt;roles/pubsub.publisher&quot;\n  ]\n}\n</code></pre>\n<p>We've learned that <code>names</code> and <code>project_roles</code> must both contain only static values decided in the configuration, and so it isn't appropriate to use <code>module.project-factory.project_id</code> because that won't be known until the random project ID has been generated during the apply step.</p>\n<p>However, we <em>also</em> know that this module is expecting the prefix of each item in <code>project_roles</code> (the part before the <code>=&gt;</code>) to be a valid project ID, so there isn't any other value that would be reasonable to use there.</p>\n<p>Therefore we're at a bit of an empasse: this second module has a rather awkward design decision that it's trying to derive a both a local instance key <em>and</em> a reference to a real remote object from the same value, and those two situations have conflicting requirements. But this isn't a module you created, so you can't easily modify it to address that design quirk.</p>\n<p>Given that, I see two possible approaches to move forward, neither ideal but both workable with some caveats:</p>\n<ul>\n<li><p>You could take the approach the error message offered as a workaround, asking Terraform to plan and apply the resources in the first module alone first, and then plan and apply the rest on a subsequent run once the project ID is already decided and recorded in the state:</p>\n<pre><code>terraform apply -target=module.factory\nterraform apply\n</code></pre>\n<p>Although it's annoying to have to do this initial create in two steps, it does at least only matter for the initial <em>creation</em> of this infrastructure. If you update it later then you won't need to repeat this two-step process unless you've changed the configuration in a way that requires generating a new project ID.</p>\n</li>\n<li><p>While working through the above we saw that this approach of generating and returning a <em>random</em> project ID was optional based on that first module's <code>var.random_project_id</code>, which you set to <code>&quot;true&quot;</code> in your configuration. Without that, the <code>project_id</code> output would be just a copy of your given <code>name</code> argument, which seems to be statically defined by reference to a root module variable.</p>\n<p>Unless you particularly <em>need</em> that random suffix on your project ID, you could leave <code>random_project_id</code> unset and thus just get the project ID set to the same static value as your <code>var.project_name</code>, which should then be an acceptable value to use as a <code>for_each</code> key.</p>\n</li>\n</ul>\n<p>Ideally this second module would be designed to separate the values it's using for instance keys from the values it's using to refer to real remote objects, and thus it would be possible to use the random-suffixed name for the remote object but a statically-defined name for the local object. If this were a module under your control then I would've suggested a design change like that, but I assume the current unusual design of that third-party module (packing multiple values into a single string with a delimiter) is a compromise resulting from wanting to retain backward compatibility with an earlier iteration of the module.</p>\n", "OwnerUserId": "281848", "LastActivityDate": "2021-12-02T00:40:28.133", "CommentCount": "0", "ContentLicense": "CC BY-SA 4.0", "history": [{"Id": "259184831", "PostHistoryTypeId": "2", "PostId": "70192949", "RevisionGUID": "b3ff666f-00a7-4f85-af79-03b22f8d565a", "CreationDate": "2021-12-02T00:40:28.133", "UserId": "281848", "Text": "With only parts of the configuration visible here I'm guessing a little bit, but let's see. You mentioned that you'd like to learn more about Terraform as part of this exercise, so I'm going to go into a lot of detail about the chain here to explain _why_ I'm recommending what I'm going to recommend, though you can skip to the end if you find this extra detail uninteresting.\r\n\r\nWe'll start with [that first module's definition of its `project_id` output value](https://github.com/terraform-google-modules/terraform-google-project-factory/blob/f5cce9e6851031065aa7afdc9ff1bf424352ccef/outputs.tf#L21-L23):\r\n\r\n```\r\noutput \"project_id\" {\r\n  value = module.project-factory.project_id\r\n}\r\n```\r\n\r\n`module.project-factory` here is referring to [a nested module call](https://github.com/terraform-google-modules/terraform-google-project-factory/blob/f5cce9e6851031065aa7afdc9ff1bf424352ccef/main.tf#L28-L29), so we need to look one level deeper [in the nested module `terraform-google-modules/project-factory/google//modules/core_project_factory`](https://github.com/terraform-google-modules/terraform-google-project-factory/blob/f5cce9e6851031065aa7afdc9ff1bf424352ccef/modules/core_project_factory/outputs.tf#L21-L29):\r\n\r\n```\r\noutput \"project_id\" {\r\n  value = module.project_services.project_id\r\n  depends_on = [\r\n    module.project_services,\r\n    google_project.main,\r\n    google_compute_shared_vpc_service_project.shared_vpc_attachment,\r\n    google_compute_shared_vpc_host_project.shared_vpc_host,\r\n  ]\r\n}\r\n```\r\n\r\nAnother nested module call!  That one declares [its `project_id`](https://github.com/terraform-google-modules/terraform-google-project-factory/blob/master/modules/project_services/outputs.tf#L17-L20) like this:\r\n\r\n```\r\noutput \"project_id\" {\r\n  description = \"The GCP project you want to enable APIs on\"\r\n  value       = element(concat([for v in google_project_service.project_services : v.project], [var.project_id]), 0)\r\n}\r\n```\r\n\r\nPhew!  Finally an actual resource. This expression in this case seems to be taking the `project` attribute of a `google_project_service` resource instance, or potentially taking it from `var.project_id` if that resource was disabled in this instance of the module. Let's have a look at [the `google_project_service.project_services` definition](https://github.com/terraform-google-modules/terraform-google-project-factory/blob/f5cce9e6851031065aa7afdc9ff1bf424352ccef/modules/project_services/main.tf#L31-L37):\r\n\r\n```\r\nresource \"google_project_service\" \"project_services\" {\r\n  for_each                   = local.services\r\n  project                    = var.project_id\r\n  service                    = each.value\r\n  disable_on_destroy         = var.disable_services_on_destroy\r\n  disable_dependent_services = var.disable_dependent_services\r\n}\r\n```\r\n\r\n`project` here is set to `var.project_id`, so it seems like _either way_ this innermost `project_id` output just reflects back the value of the `project_id` input variable, so we need to jump back up one level and look at [the module call](https://github.com/terraform-google-modules/terraform-google-project-factory/blob/f5cce9e6851031065aa7afdc9ff1bf424352ccef/modules/core_project_factory/main.tf#L90-L98) to this module to see what that was set to:\r\n\r\n```\r\nmodule \"project_services\" {\r\n  source = \"../project_services\"\r\n\r\n  project_id                  = google_project.main.project_id\r\n  activate_apis               = local.activate_apis\r\n  activate_api_identities     = var.activate_api_identities\r\n  disable_services_on_destroy = var.disable_services_on_destroy\r\n  disable_dependent_services  = var.disable_dependent_services\r\n}\r\n```\r\n\r\n`project_id` is set to the `project_id` attribute of [`google_project.main`](https://github.com/terraform-google-modules/terraform-google-project-factory/blob/f5cce9e6851031065aa7afdc9ff1bf424352ccef/modules/core_project_factory/main.tf#L65-L74):\r\n\r\n```\r\nresource \"google_project\" \"main\" {\r\n  name                = var.name\r\n  project_id          = local.temp_project_id\r\n  org_id              = local.project_org_id\r\n  folder_id           = local.project_folder_id\r\n  billing_account     = var.billing_account\r\n  auto_create_network = var.auto_create_network\r\n\r\n  labels = var.labels\r\n}\r\n```\r\n\r\n`project_id` here is set to [`local.temp_project_id`](https://github.com/terraform-google-modules/terraform-google-project-factory/blob/f5cce9e6851031065aa7afdc9ff1bf424352ccef/modules/core_project_factory/main.tf#L32-L36), which is declared further up in the same file:\r\n\r\n```\r\n  temp_project_id = var.random_project_id ? format(\r\n    \"%s-%s\",\r\n    local.base_project_id,\r\n    random_id.random_project_id_suffix.hex,\r\n  ) : local.base_project_id\r\n```\r\n\r\nThis expression includes a reference to `random_id.random_project_id_suffix.hex`, and `.hex` is a _result_ attribute from [`random_id`](https://registry.terraform.io/providers/hashicorp/random/latest/docs/resources/id), and so its value won't be known until apply time due to how that `random_id` resource type is implemented. (It generates a random value during the apply step and saves it in the state so it'll stay consistent on future runs.)\r\n\r\n---\r\n\r\nThis means that (after all of this indirection) `module.project-factory.project_id` in _your_ module is not a value defined statically in the configuration, and might instead be decided dynamically during the apply step. That means it's not an appropriate value to use as part of the instance key of a resource, and thus not appropriate to use as a key in a `for_each` map.\r\n\r\nUnfortunately the use of `for_each` here is hidden inside this other module `terraform-google-modules/service-accounts/google`, and so we'll need to have a look at that one too and see how it's making use of the `project_roles` input variable. First, let's look at [the specific resource block the error message was talking about](https://github.com/terraform-google-modules/terraform-google-service-accounts/blob/c0e1fd11867cdf5a95aadc295c8f371a076ccce6/main.tf#L46-L66):\r\n\r\n```\r\nresource \"google_project_iam_member\" \"project-roles\" {\r\n  for_each = local.project_roles_map_data\r\n\r\n  project = element(\r\n    split(\r\n      \"=>\",\r\n      each.value.role\r\n    ),\r\n    0,\r\n  )\r\n\r\n  role = element(\r\n    split(\r\n      \"=>\",\r\n      each.value.role\r\n    ),\r\n    1,\r\n  )\r\n\r\n  member = \"serviceAccount:${google_service_account.service_accounts[each.value.name].email}\"\r\n}\r\n```\r\n\r\nThere's a couple somewhat-complex things going on here, but the most relevant thing for what we're looking at here is that this resource configuration is creating multiple instances based on the content of `local.project_roles_map_data`. Let's look at [`local.project_roles_map_data`](https://github.com/terraform-google-modules/terraform-google-service-accounts/blob/c0e1fd11867cdf5a95aadc295c8f371a076ccce6/main.tf#L27-L33) now:\r\n\r\n```\r\n  project_roles_map_data = zipmap(\r\n    [for pair in local.name_role_pairs : \"${pair[0]}-${pair[1]}\"],\r\n    [for pair in local.name_role_pairs : {\r\n      name = pair[0]\r\n      role = pair[1]\r\n    }]\r\n  )\r\n```\r\n\r\nA little more complexity here that isn't super important to what we're looking for; the main thing to consider here is that this is constructing a map whose keys are built from element zero and element one of `local.name_role_pairs`, which is declared directly above, along with `local.names` that it refers to:\r\n\r\n```\r\n  names                 = toset(var.names)\r\n  name_role_pairs       = setproduct(local.names, toset(var.project_roles))\r\n```\r\n\r\nSo what we've learned here is that the values in `var.names` and the values in `var.project_roles` both contribute to the keys of the `for_each` on that resource, which means that neither of those variable values should contain anything decided dynamically during the apply step.\r\n\r\nHowever, we've also learned (above) that the `project` and `role` arguments of `google_project_iam_member.project-roles` are derived from the prefixes of elements in the two lists you provided as `names` and `project_roles` in your own module call.\r\n\r\n---\r\n\r\nLet's return back to where we started then, with all of this extra information in mind:\r\n\r\n```\r\nmodule \"service_accounts\" {\r\n  source  = \"terraform-google-modules/service-accounts/google\"\r\n  version = \"4.0.3\"\r\n\r\n  project_id    = module.project-factory.project_id\r\n  generate_keys = \"true\"\r\n  names         = [\"backend-runner\"]\r\n  project_roles = [\r\n    \"${module.project-factory.project_id}=>roles/cloudsql.client\",\r\n    \"${module.project-factory.project_id}=>roles/pubsub.publisher\"\r\n  ]\r\n}\r\n```\r\n\r\nWe've learned that `names` and `project_roles` must both contain only static values decided in the configuration, and so it isn't appropriate to use `module.project-factory.project_id` because that won't be known until the random project ID has been generated during the apply step.\r\n\r\nHowever, we _also_ know that this module is expecting the prefix of each item in `project_roles` (the part before the `=>`) to be a valid project ID, so there isn't any other value that would be reasonable to use there.\r\n\r\nTherefore we're at a bit of an empasse: this second module has a rather awkward design decision that it's trying to derive a both a local instance key _and_ a reference to a real remote object from the same value, and those two situations have conflicting requirements. But this isn't a module you created, so you can't easily modify it to address that design quirk.\r\n\r\nGiven that, I see two possible approaches to move forward, neither ideal but both workable with some caveats:\r\n\r\n* You could take the approach the error message offered as a workaround, asking Terraform to plan and apply the resources in the first module alone first, and then plan and apply the rest on a subsequent run once the project ID is already decided and recorded in the state:\r\n\r\n    ```\r\n    terraform apply -target=module.factory\r\n    terraform apply\r\n    ```\r\n\r\n    Although it's annoying to have to do this initial create in two steps, it does at least only matter for the initial _creation_ of this infrastructure. If you update it later then you won't need to repeat this two-step process unless you've changed the configuration in a way that requires generating a new project ID.\r\n\r\n* While working through the above we saw that this approach of generating and returning a _random_ project ID was optional based on that first module's `var.random_project_id`, which you set to `\"true\"` in your configuration. Without that, the `project_id` output would be just a copy of your given `name` argument, which seems to be statically defined by reference to a root module variable.\r\n\r\n    Unless you particularly _need_ that random suffix on your project ID, you could leave `random_project_id` unset and thus just get the project ID set to the same static value as your `var.project_name`, which should then be an acceptable value to use as a `for_each` key.\r\n\r\nIdeally this second module would be designed to separate the values it's using for instance keys from the values it's using to refer to real remote objects, and thus it would be possible to use the random-suffixed name for the remote object but a statically-defined name for the local object. If this were a module under your control then I would've suggested a design change like that, but I assume the current unusual design of that third-party module (packing multiple values into a single string with a delimiter) is a compromise resulting from wanting to retain backward compatibility with an earlier iteration of the module.\r\n\r\n", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "This expression in this case seems to be taking the `project` attribute of a `google_project_service` resource instance, or potentially taking it from `var.project_id` if that resource was disabled in this instance of the module. ", "keywords": ["instance"]}, {"source": "Text", "text": "Let's have a look at [the `google_project_service.project_services` definition](https://github.com/terraform-google-modules/terraform-google-project-factory/blob/f5cce9e6851031065aa7afdc9ff1bf424352ccef/modules/project_services/main.tf#L31-L37): ``` resource \"google_project_service\" \"project_services\" { for_each = local.services project = var.project_id service = each.value disable_on_destroy = var.disable_services_on_destroy disable_dependent_services = var.disable_dependent_services } ``` `project` here is set to `var.project_id`, so it seems like _either way_ this innermost `project_id` output just reflects back the value of the `project_id` input variable, so we need to jump back up one level and look at [the module call](https://github.com/terraform-google-modules/terraform-google-project-factory/blob/f5cce9e6851031065aa7afdc9ff1bf424352ccef/modules/core_project_factory/main.tf#L90-L98) to this module to see what that was set to: ``` module \"project_services\" { source = \"../project_services\" project_id = google_project.main.project_id activate_apis = local.activate_apis activate_api_identities = var.activate_api_identities disable_services_on_destroy = var.disable_services_on_destroy disable_dependent_services = var.disable_dependent_services } ``` `project_id` is set to the `project_id` attribute of [`google_project.main`](https://github.com/terraform-google-modules/terraform-google-project-factory/blob/f5cce9e6851031065aa7afdc9ff1bf424352ccef/modules/core_project_factory/main.tf#L65-L74): ``` resource \"google_project\" \"main\" { name = var.name project_id = local.temp_project_id org_id = local.project_org_id folder_id = local.project_folder_id billing_account = var.billing_account auto_create_network = var.auto_create_network labels = var.labels } ``` `project_id` here is set to [`local.temp_project_id`](https://github.com/terraform-google-modules/terraform-google-project-factory/blob/f5cce9e6851031065aa7afdc9ff1bf424352ccef/modules/core_project_factory/main.tf#L32-L36), which is declared further up in the same file: ``` temp_project_id = var.random_project_id ? format( \"%s-%s\", local.base_project_id, random_id.random_project_id_suffix.hex, ) : local.base_project_id ``` ", "keywords": ["bill"]}, {"source": "Text", "text": "That means it's not an appropriate value to use as part of the instance key of a resource, and thus not appropriate to use as a key in a `for_each` map. ", "keywords": ["instance"]}, {"source": "Text", "text": "Therefore we're at a bit of an empasse: this second module has a rather awkward design decision that it's trying to derive a both a local instance key _and_ a reference to a real remote object from the same value, and those two situations have conflicting requirements. ", "keywords": ["instance"]}, {"source": "Text", "text": "If you update it later then you won't need to repeat this two-step process unless you've changed the configuration in a way that requires generating a new project ID. ", "keywords": ["change"]}, {"source": "Text", "text": "Ideally this second module would be designed to separate the values it's using for instance keys from the values it's using to refer to real remote objects, and thus it would be possible to use the random-suffixed name for the remote object but a statically-defined name for the local object. ", "keywords": ["instance"]}, {"source": "Text", "text": "If this were a module under your control then I would've suggested a design change like that, but I assume the current unusual design of that third-party module (packing multiple values into a single string with a delimiter) is a compromise resulting from wanting to retain backward compatibility with an earlier iteration of the module.", "keywords": ["change"]}]}], "filtered-sentences": [{"source": "Body", "text": "This expression in this case seems to be taking the project attribute of a google_project_service resource instance, or potentially taking it from var.project_id if that resource was disabled in this instance of the module. ", "keywords": ["instance"]}, {"source": "Body", "text": "That means it's not an appropriate value to use as part of the instance key of a resource, and thus not appropriate to use as a key in a for_each map. ", "keywords": ["instance"]}, {"source": "Body", "text": "Therefore we're at a bit of an empasse: this second module has a rather awkward design decision that it's trying to derive a both a local instance key and a reference to a real remote object from the same value, and those two situations have conflicting requirements. ", "keywords": ["instance"]}, {"source": "Body", "text": "If you update it later then you won't need to repeat this two-step process unless you've changed the configuration in a way that requires generating a new project ID. ", "keywords": ["change"]}, {"source": "Body", "text": "Ideally this second module would be designed to separate the values it's using for instance keys from the values it's using to refer to real remote objects, and thus it would be possible to use the random-suffixed name for the remote object but a statically-defined name for the local object. ", "keywords": ["instance"]}, {"source": "Body", "text": "If this were a module under your control then I would've suggested a design change like that, but I assume the current unusual design of that third-party module (packing multiple values into a single string with a delimiter) is a compromise resulting from wanting to retain backward compatibility with an earlier iteration of the module.", "keywords": ["change"]}]}], "contains-topic": true, "filtered-sentences": []}