{"Id": "75293087", "PostTypeId": "1", "CreationDate": "2023-01-31T05:41:24.927", "Score": "0", "ViewCount": "225", "Body": "<p>When deploying resources, the template terraform gave uses for_each. This poses as a problem as it will give</p>\n<pre><code>\n Error: Invalid for_each argument\n\u2502\n\u2502   on /home/baiyuc/workspaces/billow/src/GoAmzn-LambdaStackTools/configurations/terraform/sync.tf line 410, in resource &quot;aws_route53_record&quot; &quot;subdomain_cert_validation&quot;:\n\u2502  410:   for_each    = {\n\u2502  411:     for dvo in aws_acm_certificate.cert.domain_validation_options : dvo.domain_name =&gt; {\n\u2502  412:       name   = dvo.resource_record_name\n\u2502  413:       record = dvo.resource_record_value\n\u2502  414:       type   = dvo.resource_record_type\n\u2502  415:     }\n\u2502  416:   }\n\u2502     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u2502     \u2502 aws_acm_certificate.cert.domain_validation_options is a set of object, known only after apply\n\nThe &quot;for_each&quot; map includes keys derived from resource attributes that cannot be determined until apply, and so Terraform cannot determine the full set of keys that will identify the instances of this resource.\n\nWhen working with unknown values in for_each, it's better to define the map keys statically in your configuration and place apply-time results only in the map values.\n\nAlternatively, you could use the -target planning option to first apply only the resources that the for_each value depends on, and then apply a second time to fully converge.\n</code></pre>\n<p>error when using <code>terraform import</code>.</p>\n<p>I found a potential solution that suggests using <code>count</code> in this type of scenarios, but it didn't go into details. Anyone can give any details on how to do so?</p>\n<p>The code of interest is for <code>resource &quot;aws_route53_record&quot; &quot;subdomain_cert_validation&quot;</code>:</p>\n<pre><code>data &quot;aws_route53_zone&quot; &quot;root_domain&quot; {\n  name         = &quot;${var.root_domain}.&quot;\n  private_zone = false\n}\n\n\nresource &quot;aws_acm_certificate&quot; &quot;cert&quot; {\n  depends_on        = [aws_route53_record.sub-zone]\n  domain_name       = var.domain\n  validation_method = &quot;DNS&quot;\n}\n\nresource &quot;aws_route53_zone&quot; &quot;core-domain&quot; {\n  name  = var.domain\n  count = var.root_domain == var.domain ? 0 : 1 # If the two are the same, do not create this resource.\n  tags  = {\n    Environment = var.stack_tag\n  }\n}\n\nresource &quot;aws_route53_record&quot; &quot;sub-zone&quot; {\n  depends_on  = [aws_route53_zone.core-domain]\n  zone_id     = data.aws_route53_zone.root_domain.zone_id\n  name        = var.domain\n  type        = &quot;NS&quot;\n  ttl         = &quot;30&quot;\n  count       = var.root_domain == var.domain ? 0 : 1 # If the two are the same, do not create this resource.\n  records     = var.root_domain == var.domain ? [] : [\n    aws_route53_zone.core-domain[0].name_servers[0],\n    aws_route53_zone.core-domain[0].name_servers[1],\n    aws_route53_zone.core-domain[0].name_servers[2],\n    aws_route53_zone.core-domain[0].name_servers[3],\n  ]\n}\n\nresource &quot;aws_route53_record&quot; &quot;subdomain_cert_validation&quot; {\n  depends_on  = [aws_acm_certificate.cert]\n  for_each    = {\n    for dvo in aws_acm_certificate.cert.domain_validation_options : dvo.domain_name =&gt; {\n      name   = dvo.resource_record_name\n      record = dvo.resource_record_value\n      type   = dvo.resource_record_type\n    }\n  }\n  allow_overwrite = true\n\n  name    = each.value.name\n  records = [each.value.record]\n  type    = each.value.type\n  ttl     = 600\n  zone_id = var.root_domain == var.domain ? data.aws_route53_zone.root_domain.zone_id : aws_route53_zone.core-domain[0].zone_id\n}\n\nresource &quot;aws_acm_certificate_validation&quot; &quot;core&quot; {\n  certificate_arn         = aws_acm_certificate.cert.arn\n  validation_record_fqdns = [for record in aws_route53_record.subdomain_cert_validation : record.fqdn]\n}\n</code></pre>\n", "OwnerUserId": "6472650", "LastEditorUserId": "6472650", "LastEditDate": "2023-01-31T17:07:19.370", "LastActivityDate": "2023-01-31T17:07:19.370", "Title": "Use count instead of for_each for terraform resource", "Tags": "<terraform>", "AnswerCount": "1", "CommentCount": "2", "ContentLicense": "CC BY-SA 4.0", "comments": [{"Id": "132860050", "PostId": "75293087", "Score": "2", "Text": "What is the FULL error message, showing exactly where it occurs.", "CreationDate": "2023-01-31T05:44:53.817", "UserId": "248823", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "132872455", "PostId": "75293087", "Score": "0", "Text": "I added the whole error message.", "CreationDate": "2023-01-31T17:07:38.807", "UserId": "6472650", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "history": [{"Id": "287148583", "PostHistoryTypeId": "2", "PostId": "75293087", "RevisionGUID": "218e58c0-d8cf-479f-a61d-7105d9e72fbb", "CreationDate": "2023-01-31T05:41:24.927", "UserId": "6472650", "Text": "When deploying resources, the template terraform gave uses for_each. This poses as a problem as it will give `The \"for_each\" map includes keys derived from resource attributes that cannot be determined until apply, and so Terraform cannot determine the full set of keys that will identify the instances of this resource.` error when using `terraform import`. \r\n\r\nI found a potential solution that suggests using `count` in this type of scenarios, but it didn't go into details. Anyone can give any details on how to do so?\r\n\r\nThe code of interest is for `resource \"aws_route53_record\" \"subdomain_cert_validation\"`:\r\n\r\n\r\n```\r\ndata \"aws_route53_zone\" \"root_domain\" {\r\n  name         = \"${var.root_domain}.\"\r\n  private_zone = false\r\n}\r\n\r\n\r\nresource \"aws_acm_certificate\" \"cert\" {\r\n  depends_on        = [aws_route53_record.sub-zone]\r\n  domain_name       = var.domain\r\n  validation_method = \"DNS\"\r\n}\r\n\r\nresource \"aws_route53_zone\" \"core-domain\" {\r\n  name  = var.domain\r\n  count = var.root_domain == var.domain ? 0 : 1 # If the two are the same, do not create this resource.\r\n  tags  = {\r\n    Environment = var.stack_tag\r\n  }\r\n}\r\n\r\nresource \"aws_route53_record\" \"sub-zone\" {\r\n  depends_on  = [aws_route53_zone.core-domain]\r\n  zone_id     = data.aws_route53_zone.root_domain.zone_id\r\n  name        = var.domain\r\n  type        = \"NS\"\r\n  ttl         = \"30\"\r\n  count       = var.root_domain == var.domain ? 0 : 1 # If the two are the same, do not create this resource.\r\n  records     = var.root_domain == var.domain ? [] : [\r\n    aws_route53_zone.core-domain[0].name_servers[0],\r\n    aws_route53_zone.core-domain[0].name_servers[1],\r\n    aws_route53_zone.core-domain[0].name_servers[2],\r\n    aws_route53_zone.core-domain[0].name_servers[3],\r\n  ]\r\n}\r\n\r\nresource \"aws_route53_record\" \"subdomain_cert_validation\" {\r\n  depends_on  = [aws_acm_certificate.cert]\r\n  for_each    = {\r\n    for dvo in aws_acm_certificate.cert.domain_validation_options : dvo.domain_name => {\r\n      name   = dvo.resource_record_name\r\n      record = dvo.resource_record_value\r\n      type   = dvo.resource_record_type\r\n    }\r\n  }\r\n  allow_overwrite = true\r\n\r\n  name    = each.value.name\r\n  records = [each.value.record]\r\n  type    = each.value.type\r\n  ttl     = 600\r\n  zone_id = var.root_domain == var.domain ? data.aws_route53_zone.root_domain.zone_id : aws_route53_zone.core-domain[0].zone_id\r\n}\r\n\r\nresource \"aws_acm_certificate_validation\" \"core\" {\r\n  certificate_arn         = aws_acm_certificate.cert.arn\r\n  validation_record_fqdns = [for record in aws_route53_record.subdomain_cert_validation : record.fqdn]\r\n}\r\n```", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "The code of interest is for `resource \"aws_route53_record\" \"subdomain_cert_validation\"`: ``` data \"aws_route53_zone\" \"root_domain\" { name = \"${var.root_domain}.\" private_zone = false } resource \"aws_acm_certificate\" \"cert\" { depends_on = [aws_route53_record.sub-zone] domain_name = var.domain validation_method = \"DNS\" } resource \"aws_route53_zone\" \"core-domain\" { name = var.domain count = var.root_domain == var.domain ? 0 : 1 # If the two are the same, do not create this resource. tags = { Environment = var.stack_tag } } resource \"aws_route53_record\" \"sub-zone\" { depends_on = [aws_route53_zone.core-domain] zone_id = data.aws_route53_zone.root_domain.zone_id name = var.domain type = \"NS\" ttl = \"30\" count = var.root_domain == var.domain ? 0 : 1 # If the two are the same, do not create this resource. ", "keywords": ["domain"]}, {"source": "Text", "text": "records = var.root_domain == var.domain ? [] : [ aws_route53_zone.core-domain[0].name_servers[0], aws_route53_zone.core-domain[0].name_servers[1], aws_route53_zone.core-domain[0].name_servers[2], aws_route53_zone.core-domain[0].name_servers[3], ] } resource \"aws_route53_record\" \"subdomain_cert_validation\" { depends_on = [aws_acm_certificate.cert] for_each = { for dvo in aws_acm_certificate.cert.domain_validation_options : dvo.domain_name => { name = dvo.resource_record_name record = dvo.resource_record_value type = dvo.resource_record_type } } allow_overwrite = true name = each.value.name records = [each.value.record] type = each.value.type ttl = 600 zone_id = var.root_domain == var.domain ? data.aws_route53_zone.root_domain.zone_id : aws_route53_zone.core-domain[0]", "keywords": ["domain"]}]}, {"Id": "287148585", "PostHistoryTypeId": "1", "PostId": "75293087", "RevisionGUID": "218e58c0-d8cf-479f-a61d-7105d9e72fbb", "CreationDate": "2023-01-31T05:41:24.927", "UserId": "6472650", "Text": "Use count instead of for_each for terraform resource", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "287148586", "PostHistoryTypeId": "3", "PostId": "75293087", "RevisionGUID": "218e58c0-d8cf-479f-a61d-7105d9e72fbb", "CreationDate": "2023-01-31T05:41:24.927", "UserId": "6472650", "Text": "<terraform>", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "287189874", "PostHistoryTypeId": "5", "PostId": "75293087", "RevisionGUID": "0ca12e6b-9836-44c4-a5b3-8b8311ed66fc", "CreationDate": "2023-01-31T17:07:19.370", "UserId": "6472650", "Comment": "added 1005 characters in body", "Text": "When deploying resources, the template terraform gave uses for_each. This poses as a problem as it will give \r\n```\r\n\r\n Error: Invalid for_each argument\r\n\u2502\r\n\u2502   on /home/baiyuc/workspaces/billow/src/GoAmzn-LambdaStackTools/configurations/terraform/sync.tf line 410, in resource \"aws_route53_record\" \"subdomain_cert_validation\":\r\n\u2502  410:   for_each    = {\r\n\u2502  411:     for dvo in aws_acm_certificate.cert.domain_validation_options : dvo.domain_name => {\r\n\u2502  412:       name   = dvo.resource_record_name\r\n\u2502  413:       record = dvo.resource_record_value\r\n\u2502  414:       type   = dvo.resource_record_type\r\n\u2502  415:     }\r\n\u2502  416:   }\r\n\u2502     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n\u2502     \u2502 aws_acm_certificate.cert.domain_validation_options is a set of object, known only after apply\r\n\r\nThe \"for_each\" map includes keys derived from resource attributes that cannot be determined until apply, and so Terraform cannot determine the full set of keys that will identify the instances of this resource.\r\n\r\nWhen working with unknown values in for_each, it's better to define the map keys statically in your configuration and place apply-time results only in the map values.\r\n\r\nAlternatively, you could use the -target planning option to first apply only the resources that the for_each value depends on, and then apply a second time to fully converge.\r\n```\r\n\r\n error when using `terraform import`. \r\n\r\nI found a potential solution that suggests using `count` in this type of scenarios, but it didn't go into details. Anyone can give any details on how to do so?\r\n\r\nThe code of interest is for `resource \"aws_route53_record\" \"subdomain_cert_validation\"`:\r\n\r\n\r\n```\r\ndata \"aws_route53_zone\" \"root_domain\" {\r\n  name         = \"${var.root_domain}.\"\r\n  private_zone = false\r\n}\r\n\r\n\r\nresource \"aws_acm_certificate\" \"cert\" {\r\n  depends_on        = [aws_route53_record.sub-zone]\r\n  domain_name       = var.domain\r\n  validation_method = \"DNS\"\r\n}\r\n\r\nresource \"aws_route53_zone\" \"core-domain\" {\r\n  name  = var.domain\r\n  count = var.root_domain == var.domain ? 0 : 1 # If the two are the same, do not create this resource.\r\n  tags  = {\r\n    Environment = var.stack_tag\r\n  }\r\n}\r\n\r\nresource \"aws_route53_record\" \"sub-zone\" {\r\n  depends_on  = [aws_route53_zone.core-domain]\r\n  zone_id     = data.aws_route53_zone.root_domain.zone_id\r\n  name        = var.domain\r\n  type        = \"NS\"\r\n  ttl         = \"30\"\r\n  count       = var.root_domain == var.domain ? 0 : 1 # If the two are the same, do not create this resource.\r\n  records     = var.root_domain == var.domain ? [] : [\r\n    aws_route53_zone.core-domain[0].name_servers[0],\r\n    aws_route53_zone.core-domain[0].name_servers[1],\r\n    aws_route53_zone.core-domain[0].name_servers[2],\r\n    aws_route53_zone.core-domain[0].name_servers[3],\r\n  ]\r\n}\r\n\r\nresource \"aws_route53_record\" \"subdomain_cert_validation\" {\r\n  depends_on  = [aws_acm_certificate.cert]\r\n  for_each    = {\r\n    for dvo in aws_acm_certificate.cert.domain_validation_options : dvo.domain_name => {\r\n      name   = dvo.resource_record_name\r\n      record = dvo.resource_record_value\r\n      type   = dvo.resource_record_type\r\n    }\r\n  }\r\n  allow_overwrite = true\r\n\r\n  name    = each.value.name\r\n  records = [each.value.record]\r\n  type    = each.value.type\r\n  ttl     = 600\r\n  zone_id = var.root_domain == var.domain ? data.aws_route53_zone.root_domain.zone_id : aws_route53_zone.core-domain[0].zone_id\r\n}\r\n\r\nresource \"aws_acm_certificate_validation\" \"core\" {\r\n  certificate_arn         = aws_acm_certificate.cert.arn\r\n  validation_record_fqdns = [for record in aws_route53_record.subdomain_cert_validation : record.fqdn]\r\n}\r\n```", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "Error: Invalid for_each argument \u2502 \u2502 on /home/baiyuc/workspaces/billow/src/GoAmzn-LambdaStackTools/configurations/terraform/sync.tf line 410, in resource \"aws_route53_record\" \"subdomain_cert_validation\": \u2502 410: for_each = { \u2502 411: for dvo in aws_acm_certificate.cert.domain_validation_options : dvo.domain_name => { \u2502 412: name = dvo.resource_record_name \u2502 413: record = dvo.resource_record_value \u2502 414: type = dvo.resource_record_type \u2502 415: } \u2502 416: } \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 aws_acm_certificate.cert.domain_validation_options is a set of object, known only after apply ", "keywords": ["bill"]}, {"source": "Text", "text": "The code of interest is for `resource \"aws_route53_record\" \"subdomain_cert_validation\"`: ``` data \"aws_route53_zone\" \"root_domain\" { name = \"${var.root_domain}.\" private_zone = false } resource \"aws_acm_certificate\" \"cert\" { depends_on = [aws_route53_record.sub-zone] domain_name = var.domain validation_method = \"DNS\" } resource \"aws_route53_zone\" \"core-domain\" { name = var.domain count = var.root_domain == var.domain ? 0 : 1 # If the two are the same, do not create this resource. tags = { Environment = var.stack_tag } } resource \"aws_route53_record\" \"sub-zone\" { depends_on = [aws_route53_zone.core-domain] zone_id = data.aws_route53_zone.root_domain.zone_id name = var.domain type = \"NS\" ttl = \"30\" count = var.root_domain == var.domain ? 0 : 1 # If the two are the same, do not create this resource. records = var.root_domain == var.domain ? [] : [ aws_route53_zone.core-domain[0].name_servers[0], aws_route53_zone.core-domain[0].name_servers[1], aws_route53_zone.core-domain[0].name_servers[2], aws_route53_zone.core-domain[0].name_servers[3], ] } resource \"aws_route53_record\" \"subdomain_cert_validation\" { depends_on = [aws_acm_certificate.cert] for_each = { for dvo in aws_acm_certificate.cert.domain_validation_options : dvo.domain_name => { name = dvo.resource_record_name record = dvo.resource_record_value type = dvo.resource_record_type } } allow_overwrite = true name = each.value.name records = [each.value.record] type = each.value.type ttl = 600 zone_id = var.root_domain == var.domain ? data.aws_route53_zone.root_domain.zone_id : aws_route53_zone.core-domain[0]", "keywords": ["domain"]}]}], "answers": [{"Id": "75294702", "PostTypeId": "2", "ParentId": "75293087", "CreationDate": "2023-01-31T08:57:43.640", "Score": "0", "Body": "<p>this issue is pretty common when using iteration and is caused by trying to use keys that will be dynamically generated at apply time. You need to make sure that your keys are statically defined so they're known at apply time, the value of the map can then be dynamic. Some good reference, for this issue and solutions are here</p>\n<p><a href=\"https://discuss.hashicorp.com/t/for-each-value-depends-on-resource-attributes-that-cannot-be-determined-until-apply/6061\" rel=\"nofollow noreferrer\">for_each example and solution</a></p>\n<p><a href=\"https://discuss.hashicorp.com/t/the-for-each-value-depends-on-resource-attributes-that-cannot-be-determined-until-apply/25016\" rel=\"nofollow noreferrer\">for_each example and solution</a></p>\n", "OwnerUserId": "8622323", "LastActivityDate": "2023-01-31T08:57:43.640", "CommentCount": "0", "ContentLicense": "CC BY-SA 4.0", "history": [{"Id": "287157265", "PostHistoryTypeId": "2", "PostId": "75294702", "RevisionGUID": "18c846da-06e4-4ebf-8a3d-7cdbc8f7ca76", "CreationDate": "2023-01-31T08:57:43.640", "UserId": "8622323", "Text": "this issue is pretty common when using iteration and is caused by trying to use keys that will be dynamically generated at apply time. You need to make sure that your keys are statically defined so they're known at apply time, the value of the map can then be dynamic. Some good reference, for this issue and solutions are here\r\n\r\n[for_each example and solution][1]\r\n\r\n[for_each example and solution][2]\r\n\r\n\r\n  [1]: https://discuss.hashicorp.com/t/for-each-value-depends-on-resource-attributes-that-cannot-be-determined-until-apply/6061\r\n  [2]: https://discuss.hashicorp.com/t/the-for-each-value-depends-on-resource-attributes-that-cannot-be-determined-until-apply/25016", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "filtered-sentences": []}], "contains-topic": true, "filtered-sentences": []}