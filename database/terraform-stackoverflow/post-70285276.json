{"Id": "70285276", "PostTypeId": "1", "CreationDate": "2021-12-09T05:50:35.760", "Score": "1", "ViewCount": "193", "Body": "<p>I'm super new to Go and I'm trying to convert a JSON schema which contains terraform specific attribute names to AWS API specific JSON schema in Go.</p>\n<p>For example:\nThe input is of type:</p>\n<pre><code>{\n  &quot;egress&quot;: [\n    {\n      &quot;cidr_blocks&quot;: [\n        &quot;0.0.0.0/0&quot;\n      ],\n      &quot;description&quot;: &quot;Port 443&quot;,\n      &quot;from_port&quot;: 443,\n      &quot;protocol&quot;: &quot;tcp&quot;,\n      &quot;to_port&quot;: 443\n    }\n  ],\n  &quot;ingress&quot;: [\n    {\n      &quot;cidr_blocks&quot;: [\n        &quot;0.0.0.0/0&quot;\n      ],\n      &quot;description&quot;: &quot;Port 443&quot;,\n      &quot;from_port&quot;: 443,\n      &quot;protocol&quot;: &quot;tcp&quot;,\n      &quot;to_port&quot;: 443\n    }\n  ],\n  &quot;name&quot;: &quot;my_sec_group&quot;,\n  &quot;vpc_id&quot;: &quot;${aws_vpc.my_vpc.id}&quot;\n}\n</code></pre>\n<p>And the desired output should be matching the AWS API object which would be something like this:</p>\n<pre><code>{\n  &quot;SecurityGroups&quot;: [\n    {\n      &quot;GroupName&quot;: &quot;my_sec_group&quot;,\n      &quot;IpPermissions&quot;: [\n        {\n          &quot;FromPort&quot;: 443,\n          &quot;IpProtocol&quot;: &quot;tcp&quot;,\n          &quot;IpRanges&quot;: [\n            {\n              &quot;CidrIp&quot;: &quot;0.0.0.0/0&quot;,\n              &quot;Description&quot;: &quot;Port 443&quot;\n            }\n          ],\n          &quot;ToPort&quot;: 443\n        }\n      ],\n      &quot;IpPermissionsEgress&quot;: [\n        {\n          &quot;FromPort&quot;: 443,\n          &quot;IpProtocol&quot;: &quot;tcp&quot;,\n          &quot;IpRanges&quot;: [\n            {\n              &quot;CidrIp&quot;: &quot;0.0.0.0/0&quot;,\n              &quot;Description&quot;: &quot;Port 443&quot;\n            }\n          ],\n          &quot;ToPort&quot;: 443\n        }\n      ],\n      &quot;VpcId&quot;: &quot;${aws_vpc.my_vpc.id}&quot;\n    }\n  ]\n}\n</code></pre>\n<p><strong>What I have tried till now:</strong></p>\n<blockquote>\n<p><strong>I. Create a generic JSON spec and use it to convert the input JSON to desired output</strong></p>\n</blockquote>\n<p>My generic JSON spec looks something like this:</p>\n<pre><code>{\n      &quot;aws_security_group&quot;: [\n        {\n          &quot;terraform_attribute&quot;: &quot;name&quot;,\n          &quot;attribute_type&quot;: &quot;string&quot;,\n          &quot;aws_attribute&quot;: &quot;GroupName&quot;\n        },\n        {\n          &quot;terraform_attribute&quot;: &quot;vpc_id&quot;,\n          &quot;attribute_type&quot;: &quot;string&quot;,\n          &quot;aws_attribute&quot;: &quot;VpcId&quot;\n        },\n        {\n          &quot;terraform_attribute&quot;: &quot;description&quot;,\n          &quot;attribute_type&quot;: &quot;string&quot;,\n          &quot;aws_attribute&quot;: &quot;Description&quot;\n        },\n        {\n          &quot;terraform_attribute&quot;: &quot;ingress&quot;,\n          &quot;attribute_type&quot;: &quot;list&quot;,\n          &quot;aws_attribute&quot;: &quot;IpPermissions&quot;,\n          &quot;list_items&quot;: [\n            {\n              &quot;terraform_attribute&quot;: &quot;from_port&quot;,\n              &quot;attribute_type&quot;: &quot;string&quot;,\n              &quot;aws_attribute&quot;: &quot;FromPort&quot;\n            },\n            {\n              &quot;terraform_attribute&quot;: &quot;to_port&quot;,\n              &quot;attribute_type&quot;: &quot;string&quot;,\n              &quot;aws_attribute&quot;: &quot;ToPort&quot;\n            },\n            {\n              &quot;terraform_attribute&quot;: &quot;protocol&quot;,\n              &quot;attribute_type&quot;: &quot;string&quot;,\n              &quot;aws_attribute&quot;: &quot;IpProtocol&quot;\n            },\n            {\n              &quot;terraform_attribute&quot;: &quot;cidr_blocks&quot;,\n              &quot;attribute_type&quot;: &quot;list&quot;,\n              &quot;aws_attribute&quot;: &quot;IpRanges&quot;,\n              &quot;list_items&quot;: [\n                {\n                  &quot;terraform_attribute&quot;: &quot;cidr_blocks.value&quot;,\n                  &quot;attribute_type&quot;: &quot;string&quot;,\n                  &quot;aws_attribute&quot;: &quot;CidrIp&quot;\n                },\n                {\n                  &quot;terraform_attribute&quot;: &quot;description&quot;,\n                  &quot;attribute_type&quot;: &quot;string&quot;,\n                  &quot;aws_attribute&quot;: &quot;Description&quot;\n                }\n              ]\n            }\n          ]\n        },\n        {\n          &quot;terraform_attribute&quot;: &quot;egress&quot;,\n          &quot;attribute_type&quot;: &quot;list&quot;,\n          &quot;aws_attribute&quot;: &quot;IpPermissionsEgress&quot;,\n          &quot;list_items&quot;: [\n            {\n              &quot;terraform_attribute&quot;: &quot;from_port&quot;,\n              &quot;attribute_type&quot;: &quot;string&quot;,\n              &quot;aws_attribute&quot;: &quot;FromPort&quot;\n            },\n            {\n              &quot;terraform_attribute&quot;: &quot;to_port&quot;,\n              &quot;attribute_type&quot;: &quot;string&quot;,\n              &quot;aws_attribute&quot;: &quot;ToPort&quot;\n            },\n            {\n              &quot;terraform_attribute&quot;: &quot;protocol&quot;,\n              &quot;attribute_type&quot;: &quot;string&quot;,\n              &quot;aws_attribute&quot;: &quot;IpProtocol&quot;\n            },\n            {\n              &quot;terraform_attribute&quot;: &quot;cidr_blocks&quot;,\n              &quot;attribute_type&quot;: &quot;list&quot;,\n              &quot;aws_attribute&quot;: &quot;IpRanges&quot;,\n              &quot;list_items&quot;: [\n                {\n                  &quot;terraform_attribute&quot;: &quot;cidr_blocks.value&quot;,\n                  &quot;attribute_type&quot;: &quot;string&quot;,\n                  &quot;aws_attribute&quot;: &quot;CidrIp&quot;\n                },\n                {\n                  &quot;terraform_attribute&quot;: &quot;description&quot;,\n                  &quot;attribute_type&quot;: &quot;string&quot;,\n                  &quot;aws_attribute&quot;: &quot;Description&quot;\n                }\n              ]\n            }\n          ]\n        }\n      ]\n    }\n</code></pre>\n<p>Then I'm using this spec to convert the input JSON to desired output by recursively visiting each block within the input something like this:</p>\n<pre><code>for key, val := range configCopy {\n            for _, detail := range resourceDetails {\n                detail := detail.(map[string]interface{})\n                if detail[&quot;attribute_type&quot;] == &quot;string&quot; &amp;&amp; detail[&quot;terraform_attribute&quot;] == key {\n                    delete(configCopy, key)\n                    configCopy[detail[&quot;aws_attribute&quot;].(string)] = val\n                    break\n                } else if detail[&quot;attribute_type&quot;] == &quot;list&quot; &amp;&amp; detail[&quot;terraform_attribute&quot;] == key {\n                    delete(configCopy, key)\n                    configCopy[detail[&quot;aws_attribute&quot;].(string)] =\n                        buildListValue(val, detail[&quot;list_items&quot;].([]interface{}))\n                }\n            }\n        }\n\nfunc buildListValue(val interface{}, listItemVal []interface{}) []map[string]interface{} {\n    v := reflect.ValueOf(val)\n    var result []map[string]interface{}\n    fmt.Println(&quot;Val Kind:&quot;, v.Kind(), &quot;Val String: &quot;, v.String())\n    valCopy := make([]interface{}, v.Len())\n    if v.Kind() == reflect.Slice {\n        for i := 0; i &lt; v.Len(); i++ {\n            valCopy[i] = v.Index(i).Interface()\n        }\n    }\n\n    for _, eachVal := range valCopy {\n        res := make(map[string]interface{})\n        f := reflect.ValueOf(eachVal)\n        if f.Kind() == reflect.Map {\n            for _, key := range f.MapKeys() {\n                fmt.Println(&quot;Key:&quot;, key.String(), &quot; value:&quot;, f.MapIndex(key).Interface())\n                for _, listItem := range listItemVal {\n                    listItem := listItem.(map[string]interface{})\n                    if listItem[&quot;attribute_type&quot;] == &quot;string&quot; &amp;&amp; listItem[&quot;terraform_attribute&quot;] == key.String() {\n                        res[listItem[&quot;aws_attribute&quot;].(string)] = f.MapIndex(key).Interface()\n                        break\n                    } else if listItem[&quot;attribute_type&quot;] == &quot;list&quot; &amp;&amp; listItem[&quot;terraform_attribute&quot;] == key.String() {\n                        res[listItem[&quot;aws_attribute&quot;].(string)] =\n                            buildListValue(f.MapIndex(key).Interface(), listItem[&quot;list_items&quot;].([]interface{}))\n                        break\n                    }\n                }\n            }\n        } else if f.Kind() == reflect.String {\n            for _, listItem := range listItemVal {\n                listItem := listItem.(map[string]interface{})\n                if strings.HasSuffix(listItem[&quot;terraform_attribute&quot;].(string), &quot;.value&quot;) {\n                    res[listItem[&quot;aws_attribute&quot;].(string)] = f.String()\n                }\n            }\n        }\n        if len(res) &gt; 0 {\n            result = append(result, res)\n        }\n    }\n\n    return result\n}\n</code></pre>\n<p>Where <code>configCopy</code> is the input JSON. This approach works, but the problems associated with this approach are:</p>\n<ol>\n<li>It is a time consuming process as I need to manually create a spec for each resource type.</li>\n<li>Error prone as the transformation code is completely dependent on the manual spec being defined.</li>\n</ol>\n<blockquote>\n<p><strong>II. Tried using some open-source JSON transformers in Go like <a href=\"https://github.com/qntfy/kazaam\" rel=\"nofollow noreferrer\">kazaam</a></strong></p>\n</blockquote>\n<p>Project kazaam takes a JSON string and a schema spec as input and produces the result using the given spec very similar to project Jolt.</p>\n<p>I tried using a spec like this to convert the above input JSON:</p>\n<pre><code>[\n  {\n    &quot;operation&quot;: &quot;shift&quot;,\n    &quot;spec&quot;: {\n      &quot;SecurityGroups.Description&quot;: &quot;description&quot;,\n      &quot;SecurityGroups.GroupName&quot;: &quot;name&quot;,\n      &quot;SecurityGroups.VpcId&quot;: &quot;vpc_id&quot;,\n      &quot;SecurityGroups.IpPermissions.IpProtocol&quot;: &quot;ingress[*].protocol&quot;,\n      &quot;SecurityGroups.IpPermissions.FromPort&quot;: &quot;ingress[*].from_port&quot;,\n      &quot;SecurityGroups.IpPermissions.ToPort&quot;: &quot;ingress[*].to_port&quot;,\n      &quot;SecurityGroups.IpPermissions.IpRanges.CidrIp&quot;: &quot;ingress[*].cidr_blocks[*]&quot;,\n      &quot;SecurityGroups.IpPermissions.IpRanges.Description&quot;: &quot;ingress[*].description&quot;,\n      &quot;SecurityGroups.IpPermissionsEgress.IpProtocol&quot;: &quot;egress[*].protocol&quot;,\n      &quot;SecurityGroups.IpPermissionsEgress.FromPort&quot;: &quot;egress[*].from_port&quot;,\n      &quot;SecurityGroups.IpPermissionsEgress.ToPort&quot;: &quot;egress[*].to_port&quot;,\n      &quot;SecurityGroups.IpPermissionsEgress.IpRanges.CidrIp&quot;: &quot;egress[*].cidr_blocks[*]&quot;,\n      &quot;SecurityGroups.IpPermissionsEgress.IpRanges.Description&quot;: &quot;egress[*].description&quot;\n    }\n  }\n]\n</code></pre>\n<p>But the result produced was something like the one shown below which is not what I was expecting:</p>\n<pre><code>{\n  &quot;SecurityGroups&quot;: {\n    &quot;IpPermissionsEgress&quot;: {\n      &quot;FromPort&quot;: [\n        443\n      ],\n      &quot;ToPort&quot;: [\n        443\n      ],\n      &quot;IpRanges&quot;: {\n        &quot;Description&quot;: [\n          &quot;Port 443&quot;\n        ],\n        &quot;CidrIp&quot;: [\n          [\n            &quot;0.0.0.0/0&quot;\n          ]\n        ]\n      },\n      &quot;IpProtocol&quot;: [\n        &quot;tcp&quot;\n      ]\n    },\n    &quot;VpcId&quot;: &quot;${aws_vpc.my_vpc.id}&quot;,\n    &quot;IpPermissions&quot;: {\n      &quot;FromPort&quot;: [\n        443\n      ],\n      &quot;ToPort&quot;: [\n        443\n      ],\n      &quot;IpRanges&quot;: {\n        &quot;CidrIp&quot;: [\n          [\n            &quot;0.0.0.0/0&quot;\n          ]\n        ],\n        &quot;Description&quot;: [\n          &quot;Port 443&quot;\n        ]\n      },\n      &quot;IpProtocol&quot;: [\n        &quot;tcp&quot;\n      ]\n    },\n    &quot;Description&quot;: null,\n    &quot;GroupName&quot;: &quot;my_sec_group&quot;\n  }\n}\n</code></pre>\n<p>Which is not as expected. I may be doing something wrong while constructing the kazaam spec, but I'm not really sure.</p>\n<p>Is there any better/efficient way to address this use case? Any suggestions on this would be of great help.</p>\n", "OwnerUserId": "3982592", "LastActivityDate": "2021-12-09T05:50:35.760", "Title": "Efficient way of converting terraform JSON schema to AWS API JSON schema", "Tags": "<json><go><terraform>", "AnswerCount": "0", "CommentCount": "0", "FavoriteCount": "0", "ContentLicense": "CC BY-SA 4.0", "history": [{"Id": "259681599", "PostHistoryTypeId": "2", "PostId": "70285276", "RevisionGUID": "1922ac9a-d41b-453e-ac44-2713039b5538", "CreationDate": "2021-12-09T05:50:35.760", "UserId": "3982592", "Text": "I'm super new to Go and I'm trying to convert a JSON schema which contains terraform specific attribute names to AWS API specific JSON schema in Go.\r\n\r\nFor example:\r\nThe input is of type:\r\n```\r\n{\r\n  \"egress\": [\r\n    {\r\n      \"cidr_blocks\": [\r\n        \"0.0.0.0/0\"\r\n      ],\r\n      \"description\": \"Port 443\",\r\n      \"from_port\": 443,\r\n      \"protocol\": \"tcp\",\r\n      \"to_port\": 443\r\n    }\r\n  ],\r\n  \"ingress\": [\r\n    {\r\n      \"cidr_blocks\": [\r\n        \"0.0.0.0/0\"\r\n      ],\r\n      \"description\": \"Port 443\",\r\n      \"from_port\": 443,\r\n      \"protocol\": \"tcp\",\r\n      \"to_port\": 443\r\n    }\r\n  ],\r\n  \"name\": \"my_sec_group\",\r\n  \"vpc_id\": \"${aws_vpc.my_vpc.id}\"\r\n}\r\n```\r\nAnd the desired output should be matching the AWS API object which would be something like this:\r\n```\r\n{\r\n  \"SecurityGroups\": [\r\n    {\r\n      \"GroupName\": \"my_sec_group\",\r\n      \"IpPermissions\": [\r\n        {\r\n          \"FromPort\": 443,\r\n          \"IpProtocol\": \"tcp\",\r\n          \"IpRanges\": [\r\n            {\r\n              \"CidrIp\": \"0.0.0.0/0\",\r\n              \"Description\": \"Port 443\"\r\n            }\r\n          ],\r\n          \"ToPort\": 443\r\n        }\r\n      ],\r\n      \"IpPermissionsEgress\": [\r\n        {\r\n          \"FromPort\": 443,\r\n          \"IpProtocol\": \"tcp\",\r\n          \"IpRanges\": [\r\n            {\r\n              \"CidrIp\": \"0.0.0.0/0\",\r\n              \"Description\": \"Port 443\"\r\n            }\r\n          ],\r\n          \"ToPort\": 443\r\n        }\r\n      ],\r\n      \"VpcId\": \"${aws_vpc.my_vpc.id}\"\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n**What I have tried till now:**\r\n\r\n>**I. Create a generic JSON spec and use it to convert the input JSON to desired output**\r\n\r\nMy generic JSON spec looks something like this:\r\n```\r\n{\r\n      \"aws_security_group\": [\r\n        {\r\n          \"terraform_attribute\": \"name\",\r\n          \"attribute_type\": \"string\",\r\n          \"aws_attribute\": \"GroupName\"\r\n        },\r\n        {\r\n          \"terraform_attribute\": \"vpc_id\",\r\n          \"attribute_type\": \"string\",\r\n          \"aws_attribute\": \"VpcId\"\r\n        },\r\n        {\r\n          \"terraform_attribute\": \"description\",\r\n          \"attribute_type\": \"string\",\r\n          \"aws_attribute\": \"Description\"\r\n        },\r\n        {\r\n          \"terraform_attribute\": \"ingress\",\r\n          \"attribute_type\": \"list\",\r\n          \"aws_attribute\": \"IpPermissions\",\r\n          \"list_items\": [\r\n            {\r\n              \"terraform_attribute\": \"from_port\",\r\n              \"attribute_type\": \"string\",\r\n              \"aws_attribute\": \"FromPort\"\r\n            },\r\n            {\r\n              \"terraform_attribute\": \"to_port\",\r\n              \"attribute_type\": \"string\",\r\n              \"aws_attribute\": \"ToPort\"\r\n            },\r\n            {\r\n              \"terraform_attribute\": \"protocol\",\r\n              \"attribute_type\": \"string\",\r\n              \"aws_attribute\": \"IpProtocol\"\r\n            },\r\n            {\r\n              \"terraform_attribute\": \"cidr_blocks\",\r\n              \"attribute_type\": \"list\",\r\n              \"aws_attribute\": \"IpRanges\",\r\n              \"list_items\": [\r\n                {\r\n                  \"terraform_attribute\": \"cidr_blocks.value\",\r\n                  \"attribute_type\": \"string\",\r\n                  \"aws_attribute\": \"CidrIp\"\r\n                },\r\n                {\r\n                  \"terraform_attribute\": \"description\",\r\n                  \"attribute_type\": \"string\",\r\n                  \"aws_attribute\": \"Description\"\r\n                }\r\n              ]\r\n            }\r\n          ]\r\n        },\r\n        {\r\n          \"terraform_attribute\": \"egress\",\r\n          \"attribute_type\": \"list\",\r\n          \"aws_attribute\": \"IpPermissionsEgress\",\r\n          \"list_items\": [\r\n            {\r\n              \"terraform_attribute\": \"from_port\",\r\n              \"attribute_type\": \"string\",\r\n              \"aws_attribute\": \"FromPort\"\r\n            },\r\n            {\r\n              \"terraform_attribute\": \"to_port\",\r\n              \"attribute_type\": \"string\",\r\n              \"aws_attribute\": \"ToPort\"\r\n            },\r\n            {\r\n              \"terraform_attribute\": \"protocol\",\r\n              \"attribute_type\": \"string\",\r\n              \"aws_attribute\": \"IpProtocol\"\r\n            },\r\n            {\r\n              \"terraform_attribute\": \"cidr_blocks\",\r\n              \"attribute_type\": \"list\",\r\n              \"aws_attribute\": \"IpRanges\",\r\n              \"list_items\": [\r\n                {\r\n                  \"terraform_attribute\": \"cidr_blocks.value\",\r\n                  \"attribute_type\": \"string\",\r\n                  \"aws_attribute\": \"CidrIp\"\r\n                },\r\n                {\r\n                  \"terraform_attribute\": \"description\",\r\n                  \"attribute_type\": \"string\",\r\n                  \"aws_attribute\": \"Description\"\r\n                }\r\n              ]\r\n            }\r\n          ]\r\n        }\r\n      ]\r\n    }\r\n```\r\nThen I'm using this spec to convert the input JSON to desired output by recursively visiting each block within the input something like this:\r\n```\r\nfor key, val := range configCopy {\r\n   for _, detail := range resourceDetails {\r\n    detail := detail.(map[string]interface{})\r\n    if detail[\"attribute_type\"] == \"string\" && detail[\"terraform_attribute\"] == key {\r\n     delete(configCopy, key)\r\n     configCopy[detail[\"aws_attribute\"].(string)] = val\r\n     break\r\n    } else if detail[\"attribute_type\"] == \"list\" && detail[\"terraform_attribute\"] == key {\r\n     delete(configCopy, key)\r\n     configCopy[detail[\"aws_attribute\"].(string)] =\r\n      buildListValue(val, detail[\"list_items\"].([]interface{}))\r\n    }\r\n   }\r\n  }\r\n\r\nfunc buildListValue(val interface{}, listItemVal []interface{}) []map[string]interface{} {\r\n v := reflect.ValueOf(val)\r\n var result []map[string]interface{}\r\n fmt.Println(\"Val Kind:\", v.Kind(), \"Val String: \", v.String())\r\n valCopy := make([]interface{}, v.Len())\r\n if v.Kind() == reflect.Slice {\r\n  for i := 0; i < v.Len(); i++ {\r\n   valCopy[i] = v.Index(i).Interface()\r\n  }\r\n }\r\n\r\n for _, eachVal := range valCopy {\r\n  res := make(map[string]interface{})\r\n  f := reflect.ValueOf(eachVal)\r\n  if f.Kind() == reflect.Map {\r\n   for _, key := range f.MapKeys() {\r\n    fmt.Println(\"Key:\", key.String(), \" value:\", f.MapIndex(key).Interface())\r\n    for _, listItem := range listItemVal {\r\n     listItem := listItem.(map[string]interface{})\r\n     if listItem[\"attribute_type\"] == \"string\" && listItem[\"terraform_attribute\"] == key.String() {\r\n      res[listItem[\"aws_attribute\"].(string)] = f.MapIndex(key).Interface()\r\n      break\r\n     } else if listItem[\"attribute_type\"] == \"list\" && listItem[\"terraform_attribute\"] == key.String() {\r\n      res[listItem[\"aws_attribute\"].(string)] =\r\n       buildListValue(f.MapIndex(key).Interface(), listItem[\"list_items\"].([]interface{}))\r\n      break\r\n     }\r\n    }\r\n   }\r\n  } else if f.Kind() == reflect.String {\r\n   for _, listItem := range listItemVal {\r\n    listItem := listItem.(map[string]interface{})\r\n    if strings.HasSuffix(listItem[\"terraform_attribute\"].(string), \".value\") {\r\n     res[listItem[\"aws_attribute\"].(string)] = f.String()\r\n    }\r\n   }\r\n  }\r\n  if len(res) > 0 {\r\n   result = append(result, res)\r\n  }\r\n }\r\n\r\n return result\r\n}\r\n```\r\nWhere `configCopy` is the input JSON. This approach works, but the problems associated with this approach are:\r\n1. It is a time consuming process as I need to manually create a spec for each resource type.\r\n2. Error prone as the transformation code is completely dependent on the manual spec being defined.\r\n\r\n>**II. Tried using some open-source JSON transformers in Go like [kazaam][1]**\r\n\r\nProject kazaam takes a JSON string and a schema spec as input and produces the result using the given spec very similar to project Jolt.\r\n\r\nI tried using a spec like this to convert the above input JSON:\r\n```\r\n[\r\n  {\r\n    \"operation\": \"shift\",\r\n    \"spec\": {\r\n      \"SecurityGroups.Description\": \"description\",\r\n      \"SecurityGroups.GroupName\": \"name\",\r\n      \"SecurityGroups.VpcId\": \"vpc_id\",\r\n      \"SecurityGroups.IpPermissions.IpProtocol\": \"ingress[*].protocol\",\r\n      \"SecurityGroups.IpPermissions.FromPort\": \"ingress[*].from_port\",\r\n      \"SecurityGroups.IpPermissions.ToPort\": \"ingress[*].to_port\",\r\n      \"SecurityGroups.IpPermissions.IpRanges.CidrIp\": \"ingress[*].cidr_blocks[*]\",\r\n      \"SecurityGroups.IpPermissions.IpRanges.Description\": \"ingress[*].description\",\r\n      \"SecurityGroups.IpPermissionsEgress.IpProtocol\": \"egress[*].protocol\",\r\n      \"SecurityGroups.IpPermissionsEgress.FromPort\": \"egress[*].from_port\",\r\n      \"SecurityGroups.IpPermissionsEgress.ToPort\": \"egress[*].to_port\",\r\n      \"SecurityGroups.IpPermissionsEgress.IpRanges.CidrIp\": \"egress[*].cidr_blocks[*]\",\r\n      \"SecurityGroups.IpPermissionsEgress.IpRanges.Description\": \"egress[*].description\"\r\n    }\r\n  }\r\n]\r\n```\r\nBut the result produced was something like the one shown below which is not what I was expecting:\r\n```\r\n{\r\n  \"SecurityGroups\": {\r\n    \"IpPermissionsEgress\": {\r\n      \"FromPort\": [\r\n        443\r\n      ],\r\n      \"ToPort\": [\r\n        443\r\n      ],\r\n      \"IpRanges\": {\r\n        \"Description\": [\r\n          \"Port 443\"\r\n        ],\r\n        \"CidrIp\": [\r\n          [\r\n            \"0.0.0.0/0\"\r\n          ]\r\n        ]\r\n      },\r\n      \"IpProtocol\": [\r\n        \"tcp\"\r\n      ]\r\n    },\r\n    \"VpcId\": \"${aws_vpc.my_vpc.id}\",\r\n    \"IpPermissions\": {\r\n      \"FromPort\": [\r\n        443\r\n      ],\r\n      \"ToPort\": [\r\n        443\r\n      ],\r\n      \"IpRanges\": {\r\n        \"CidrIp\": [\r\n          [\r\n            \"0.0.0.0/0\"\r\n          ]\r\n        ],\r\n        \"Description\": [\r\n          \"Port 443\"\r\n        ]\r\n      },\r\n      \"IpProtocol\": [\r\n        \"tcp\"\r\n      ]\r\n    },\r\n    \"Description\": null,\r\n    \"GroupName\": \"my_sec_group\"\r\n  }\r\n}\r\n``` \r\nWhich is not as expected. I may be doing something wrong while constructing the kazaam spec, but I'm not really sure.\r\n\r\nIs there any better/efficient way to address this use case? Any suggestions on this would be of great help.\r\n\r\n\r\n  [1]: https://github.com/qntfy/kazaam", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "Is there any better/efficient way to address this use case? ", "keywords": ["efficient"]}]}, {"Id": "259681601", "PostHistoryTypeId": "1", "PostId": "70285276", "RevisionGUID": "1922ac9a-d41b-453e-ac44-2713039b5538", "CreationDate": "2021-12-09T05:50:35.760", "UserId": "3982592", "Text": "Efficient way of converting terraform JSON schema to AWS API JSON schema", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "Efficient way of converting terraform JSON schema to AWS API JSON schema", "keywords": ["efficient"]}]}, {"Id": "259681602", "PostHistoryTypeId": "3", "PostId": "70285276", "RevisionGUID": "1922ac9a-d41b-453e-ac44-2713039b5538", "CreationDate": "2021-12-09T05:50:35.760", "UserId": "3982592", "Text": "<json><go><terraform>", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "contains-topic": false, "filtered-sentences": [{"source": "Title", "text": "Efficient way of converting terraform JSON schema to AWS API JSON schema", "keywords": ["efficient"]}, {"source": "Body", "text": "Is there any better/efficient way to address this use case? ", "keywords": ["efficient"]}]}