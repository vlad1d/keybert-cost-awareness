{"Id": "62074303", "PostTypeId": "1", "CreationDate": "2020-05-28T20:50:49.833", "Score": "6", "ViewCount": "967", "Body": "<p>Is it possible to fail an aws_instance creation if script passed into user_data fails to run? e.g., with exit 1?</p>\n\n<p>I have a null_resource that uses depends_on [aws_instance.myVM] to post a JSON to the instance, and I need that depends_on to fail when the user_data script fails.</p>\n\n<p>Thanks!</p>\n", "OwnerUserId": "3290431", "LastActivityDate": "2022-05-17T11:02:49.920", "Title": "How to fail aws_instance creation if user_data fails to run to completion", "Tags": "<terraform>", "AnswerCount": "2", "CommentCount": "0", "ContentLicense": "CC BY-SA 4.0", "history": [{"Id": "222787790", "PostHistoryTypeId": "2", "PostId": "62074303", "RevisionGUID": "18935bad-855d-47ad-8bdd-9d5c1a7dde7a", "CreationDate": "2020-05-28T20:50:49.833", "UserId": "3290431", "Text": "Is it possible to fail an aws_instance creation if script passed into user_data fails to run? e.g., with exit 1?\r\n\r\nI have a null_resource that uses depends_on [aws_instance.myVM] to post a JSON to the instance, and I need that depends_on to fail when the user_data script fails.\r\n\r\nThanks!", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "I have a null_resource that uses depends_on [aws_instance.myVM] to post a JSON to the instance, and I need that depends_on to fail when the user_data script fails. ", "keywords": ["instance"]}]}, {"Id": "222787791", "PostHistoryTypeId": "1", "PostId": "62074303", "RevisionGUID": "18935bad-855d-47ad-8bdd-9d5c1a7dde7a", "CreationDate": "2020-05-28T20:50:49.833", "UserId": "3290431", "Text": "How to fail aws_instance creation if user_data fails to run to completion", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "222787792", "PostHistoryTypeId": "3", "PostId": "62074303", "RevisionGUID": "18935bad-855d-47ad-8bdd-9d5c1a7dde7a", "CreationDate": "2020-05-28T20:50:49.833", "UserId": "3290431", "Text": "<terraform>", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "answers": [{"Id": "72272898", "PostTypeId": "2", "ParentId": "62074303", "CreationDate": "2022-05-17T11:02:49.920", "Score": "0", "Body": "<p>One not so obvious way I am doing this is I register the instance as a consul service at the end of user data.  If the service never arrives, downstream polling for arrival of the consul service can also timeout and fail.  This could be located in another local exec function which could be used as a dependency, or it could be in other instance user data as well.</p>\n<p>Perhaps a better way would be to use the consul KV store though, and not to just rely on service arrival.  The KV store could be used to provide more information than just a binary state.</p>\n", "OwnerUserId": "1692999", "LastActivityDate": "2022-05-17T11:02:49.920", "CommentCount": "0", "ContentLicense": "CC BY-SA 4.0", "history": [{"Id": "270329337", "PostHistoryTypeId": "2", "PostId": "72272898", "RevisionGUID": "e487c96d-5c69-4c3e-840e-eb5f625c688d", "CreationDate": "2022-05-17T11:02:49.920", "UserId": "1692999", "Text": "One not so obvious way I am doing this is I register the instance as a consul service at the end of user data.  If the service never arrives, downstream polling for arrival of the consul service can also timeout and fail.  This could be located in another local exec function which could be used as a dependency, or it could be in other instance user data as well.\r\n\r\nPerhaps a better way would be to use the consul KV store though, and not to just rely on service arrival.  The KV store could be used to provide more information than just a binary state.\r\n\r\n", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "One not so obvious way I am doing this is I register the instance as a consul service at the end of user data. ", "keywords": ["instance"]}, {"source": "Text", "text": "This could be located in another local exec function which could be used as a dependency, or it could be in other instance user data as well. ", "keywords": ["instance"]}]}], "filtered-sentences": [{"source": "Body", "text": "One not so obvious way I am doing this is I register the instance as a consul service at the end of user data. ", "keywords": ["instance"]}, {"source": "Body", "text": "This could be located in another local exec function which could be used as a dependency, or it could be in other instance user data as well. ", "keywords": ["instance"]}]}, {"Id": "62076365", "PostTypeId": "2", "ParentId": "62074303", "CreationDate": "2020-05-28T23:48:03.803", "Score": "7", "Body": "<p><code>user_data</code> is handled by software running inside the instance itself, such as <code>cloud-init</code>, and so its processing is asynchronous from the <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html\" rel=\"noreferrer\"><code>ec2:RunInstances</code></a> call that Terraform's AWS provider makes to start the instance running. There is therefore no way to feed back status information from the <code>user_data</code> handling because it could potentially be running some time after the EC2 API starts reporting that the instance is \"running\", depending on where in the boot process it's dealt with.</p>\n\n<p>Also, <code>depends_on</code> is for ordering rather than for handling errors, so a <code>depends_on</code> clause will never change anything about Terraform's error handling.</p>\n\n<p>If you want to run software on your instance synchronously as part of Terraform's create operation then unfortunately the only practical option is to use <a href=\"https://www.terraform.io/docs/provisioners/remote-exec.html\" rel=\"noreferrer\">the <code>remote-exec</code> provisioners</a>. This comes at the expense of some considerable extra complexity, because Terraform must now be able to open an SSH session with the instance and authenticate with it to create a two-way communications channel.</p>\n\n<p>In return for that complexity, Terraform can be the one to run the code in question and so Terraform can detect whether it succeeded or not (using its exit status). If the remote command fails, Terraform will halt further processing, return an error, and mark the instance as tainted so that the next plan will attempt to create it again.</p>\n\n<p>With that said, it may be better to find a different way to achieve your goal that doesn't require coupling the Terraform run directly to the state of the software running in the virtual machine. It's not usually expected that a Terraform configuration should need to both start up a virtual machine <em>and</em> interact with software running in that virtual machine in the same operation. This could be a good point for some system decomposition, where you'd have one Terraform configuration that declares that the virtual machine should exist and then a second configuration that <em>assumes</em> that the virtual machine exists and takes actions against it. You can then run whatever other software you need to run in between those two, in order to check whether the instance started up successfully.</p>\n", "OwnerUserId": "281848", "LastActivityDate": "2020-05-28T23:48:03.803", "CommentCount": "1", "ContentLicense": "CC BY-SA 4.0", "comments": [{"Id": "129405417", "PostId": "62076365", "Score": "0", "Text": "It not that uncommon, instead, to run some basic setup commands. Those can be just a few usually to install some needed software. I understand you are thinking about stuff like ansible (which would use SSH anyway). Nonetheless, a full blown ansible-like solution could be overkilling anyway, Why then not naming those \"different ways\" you might have in mind?", "CreationDate": "2022-08-08T06:54:32.787", "UserId": "625111", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "history": [{"Id": "222796037", "PostHistoryTypeId": "2", "PostId": "62076365", "RevisionGUID": "40257f09-a5bf-451b-adbc-6b6aa55ab5eb", "CreationDate": "2020-05-28T23:48:03.803", "UserId": "281848", "Text": "`user_data` is handled by software running inside the instance itself, such as `cloud-init`, and so its processing is asynchronous from the [`ec2:RunInstances`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) call that Terraform's AWS provider makes to start the instance running. There is therefore no way to feed back status information from the `user_data` handling because it could potentially be running some time after the EC2 API starts reporting that the instance is \"running\", depending on where in the boot process it's dealt with.\r\n\r\nAlso, `depends_on` is for ordering rather than for handling errors, so a `depends_on` clause will never change anything about Terraform's error handling.\r\n\r\nIf you want to run software on your instance synchronously as part of Terraform's create operation then unfortunately the only practical option is to use [the `remote-exec` provisioners](https://www.terraform.io/docs/provisioners/remote-exec.html). This comes at the expense of some considerable extra complexity, because Terraform must now be able to open an SSH session with the instance and authenticate with it to create a two-way communications channel.\r\n\r\nIn return for that complexity, Terraform can be the one to run the code in question and so Terraform can detect whether it succeeded or not (using its exit status). If the remote command fails, Terraform will halt further processing, return an error, and mark the instance as tainted so that the next plan will attempt to create it again.\r\n\r\nWith that said, it may be better to find a different way to achieve your goal that doesn't require coupling the Terraform run directly to the state of the software running in the virtual machine. It's not usually expected that a Terraform configuration should need to both start up a virtual machine _and_ interact with software running in that virtual machine in the same operation. This could be a good point for some system decomposition, where you'd have one Terraform configuration that declares that the virtual machine should exist and then a second configuration that _assumes_ that the virtual machine exists and takes actions against it. You can then run whatever other software you need to run in between those two, in order to check whether the instance started up successfully.\r\n\r\n", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "`user_data` is handled by software running inside the instance itself, such as `cloud-init`, and so its processing is asynchronous from the [`ec2:RunInstances`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) call that Terraform's AWS provider makes to start the instance running. ", "keywords": ["instance", "provider"]}, {"source": "Text", "text": "There is therefore no way to feed back status information from the `user_data` handling because it could potentially be running some time after the EC2 API starts reporting that the instance is \"running\", depending on where in the boot process it's dealt with. ", "keywords": ["instance"]}, {"source": "Text", "text": "Also, `depends_on` is for ordering rather than for handling errors, so a `depends_on` clause will never change anything about Terraform's error handling. ", "keywords": ["change"]}, {"source": "Text", "text": "If you want to run software on your instance synchronously as part of Terraform's create operation then unfortunately the only practical option is to use [the `remote-exec` provisioners](https://www.terraform.io/docs/provisioners/remote-exec.html). ", "keywords": ["instance"]}, {"source": "Text", "text": "This comes at the expense of some considerable extra complexity, because Terraform must now be able to open an SSH session with the instance and authenticate with it to create a two-way communications channel. ", "keywords": ["expense", "instance"]}, {"source": "Text", "text": "If the remote command fails, Terraform will halt further processing, return an error, and mark the instance as tainted so that the next plan will attempt to create it again. ", "keywords": ["instance"]}, {"source": "Text", "text": "You can then run whatever other software you need to run in between those two, in order to check whether the instance started up successfully.", "keywords": ["instance"]}]}], "filtered-sentences": [{"source": "Body", "text": "user_data is handled by software running inside the instance itself, such as cloud-init, and so its processing is asynchronous from the ec2:RunInstances call that Terraform's AWS provider makes to start the instance running. ", "keywords": ["instance", "provider"]}, {"source": "Body", "text": "There is therefore no way to feed back status information from the user_data handling because it could potentially be running some time after the EC2 API starts reporting that the instance is \"running\", depending on where in the boot process it's dealt with. ", "keywords": ["instance"]}, {"source": "Body", "text": "Also, depends_on is for ordering rather than for handling errors, so a depends_on clause will never change anything about Terraform's error handling. ", "keywords": ["change"]}, {"source": "Body", "text": "If you want to run software on your instance synchronously as part of Terraform's create operation then unfortunately the only practical option is to use the remote-exec provisioners. ", "keywords": ["instance"]}, {"source": "Body", "text": "This comes at the expense of some considerable extra complexity, because Terraform must now be able to open an SSH session with the instance and authenticate with it to create a two-way communications channel. ", "keywords": ["expense", "instance"]}, {"source": "Body", "text": "If the remote command fails, Terraform will halt further processing, return an error, and mark the instance as tainted so that the next plan will attempt to create it again. ", "keywords": ["instance"]}, {"source": "Body", "text": "You can then run whatever other software you need to run in between those two, in order to check whether the instance started up successfully.", "keywords": ["instance"]}]}], "contains-topic": true, "filtered-sentences": [{"source": "Body", "text": "I have a null_resource that uses depends_on [aws_instance.myVM] to post a JSON to the instance, and I need that depends_on to fail when the user_data script fails. ", "keywords": ["instance"]}]}