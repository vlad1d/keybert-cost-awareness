{"Id": "72891018", "PostTypeId": "1", "CreationDate": "2022-07-07T00:07:29.400", "Score": "0", "ViewCount": "284", "Body": "<p>I have a Terraform module for a piece of automation code. It has individual IAM policy stanzas, each defined in <code>aws_iam_policy_document</code> data sources, that are hand-maintained. Each stanza represents the fine-grained permissions the automation process needs to manage one part of the system.</p>\n<p>I need to combine these policy stanzas into valid IAM policies, and attach those policies to a role used by the automation process. The problem is that an IAM policy has a character limit of 6,144 characters. So, I need to dynamically chunk the long list of policy stanzas into groups of policies that, concatenated, are &lt;= 6,144 characters each.</p>\n<p>I think there must be a way to nest <code>for</code> expressions that accomplishes it. The problem is that I think it needs to be purely functional and stateless, because I can't think of a way to store the index where the previous chunk ended so that it can be used as the start index of the next chunk. And I can't think of a way to be able to refer to the previous chunk when constructing the subsequent chunk: it seems like each chunk must be constructed with no knowledge of where any of the other chunks start or end, or what they contain.</p>\n<p>Note: I'm not trying to achieve a dynamic programming approach where I consider the length of every policy and create the fewest possible number of groups by intelligently packing the policies together. I'm just trying to slice up the list into chunks such that <code>length(join(&quot;\\n&quot;, chunk)) &lt;= 6,144</code> for each chunk. An IAM role can have 10 policies attached, and I'm not in danger of running against that limit.</p>\n<pre><code># There are several dozen of these.\ndata &quot;aws_iam_policy_document&quot; &quot;1&quot; {...}\n\ndata &quot;aws_iam_policy_document&quot; &quot;2&quot; {...}\n\n# ...\n\n# Here are all of them:\nlocals {\n  iam_policy_documents = [\n    data.aws_iam_policy_document.1.json,\n    data.aws_iam_policy_document.2.json,\n    # ...\n  ]\n}\n\ndata &quot;aws_iam_policy_document&quot; &quot;combined&quot; {\n  for_each = &quot;some heinous nested for expression that I can't figure out&quot;\n\n  source_policy_documents = each.key\n}\n\nresource &quot;aws_iam_policy&quot; &quot;combined&quot; {\n  for_each = data.aws_iam_policy_document.combined\n\n  policy = each.value.json\n}\n</code></pre>\n<p>Until now, I've been hand-maintaining chunks of policies and sort of eyeballing to make sure that each chunk doesn't go over the character limit, but the policies are templated in different environments with values of different lengths, so a hand-maintained chunk of policies that is &lt;= 6,144 characters in my dev environment is not necessarily &lt;= 6,144 characters in staging, production, or someone else's dev environment. It's been really painful. So I'd like Terraform to be able to chunk up the policies for me in a way that's always valid.</p>\n", "OwnerUserId": "1620653", "LastActivityDate": "2022-07-07T00:07:29.400", "Title": "Terraform: Chunk list of IAM policy stanzas to remain below 6,144 character limit", "Tags": "<terraform><amazon-iam>", "AnswerCount": "0", "CommentCount": "3", "FavoriteCount": "0", "ContentLicense": "CC BY-SA 4.0", "comments": [{"Id": "128745223", "PostId": "72891018", "Score": "0", "Text": "I also haven't yet figure out a way to mash together different Terraform language features to achieve this result, and I think a successful solution to it will be pretty expensive in space and/or time due to having to use intermediate collections to fake statekeeping between \"iterations\". I would probably consider instead using [my `apparentlymart/javascript` provider](https://registry.terraform.io/providers/apparentlymart/javascript/latest/docs) to escape into a general-purpose language (JavaScript) to perform this particular calculation, and then assign its result to the `for_each`. ", "CreationDate": "2022-07-07T00:26:50.667", "UserId": "281848", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "I also haven't yet figure out a way to mash together different Terraform language features to achieve this result, and I think a successful solution to it will be pretty expensive in space and/or time due to having to use intermediate collections to fake statekeeping between \"iterations\". ", "keywords": ["expense"]}, {"source": "Text", "text": "I would probably consider instead using [my `apparentlymart/javascript` provider](https://registry.terraform.io/providers/apparentlymart/javascript/latest/docs) to escape into a general-purpose language (JavaScript) to perform this particular calculation, and then assign its result to the `for_each`.", "keywords": ["provider"]}]}, {"Id": "128745303", "PostId": "72891018", "Score": "0", "Text": "If you _do_ want to try to solve it in the Terraform language directly, I might suggest considering what you can do with the limitation you stated that there can't possibly be more than 10 chunks; knowing that there's a finite number of possible chunks means that you could _in principle_ write 10 similar expressions that each refer to the one before it, effectively \"unrolling the loop\" to force Terraform to work sequentially rather than trying to evaluate the whole thing in a single step.", "CreationDate": "2022-07-07T00:35:41.693", "UserId": "281848", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "128745330", "PostId": "72891018", "Score": "0", "Text": "(perhaps you could have an eleventh expression which gathers up anything left over from the first 10, and then use a `precondition` block in your `data` block to make your module raise an error if there's too much policy content to fit in the allowed space)", "CreationDate": "2022-07-07T00:37:33.350", "UserId": "281848", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "(perhaps you could have an eleventh expression which gathers up anything left over from the first 10, and then use a `precondition` block in your `data` block to make your module raise an error if there's too much policy content to fit in the allowed space)", "keywords": ["policy"]}]}], "history": [{"Id": "273709515", "PostHistoryTypeId": "2", "PostId": "72891018", "RevisionGUID": "f2fdb56d-f9f2-4be6-aec8-03bb6ab7b7dd", "CreationDate": "2022-07-07T00:07:29.400", "UserId": "1620653", "Text": "I have a Terraform module for a piece of automation code. It has individual IAM policy stanzas, each defined in `aws_iam_policy_document` data sources, that are hand-maintained. Each stanza represents the fine-grained permissions the automation process needs to manage one part of the system.\r\n\r\nI need to combine these policy stanzas into valid IAM policies, and attach those policies to a role used by the automation process. The problem is that an IAM policy has a character limit of 6,144 characters. So, I need to dynamically chunk the long list of policy stanzas into groups of policies that, concatenated, are <= 6,144 characters each.\r\n\r\nI think there must be a way to nest `for` expressions that accomplishes it. The problem is that I think it needs to be purely functional and stateless, because I can't think of a way to store the index where the previous chunk ended so that it can be used as the start index of the next chunk. And I can't think of a way to be able to refer to the previous chunk when constructing the subsequent chunk: it seems like each chunk must be constructed with no knowledge of where any of the other chunks start or end, or what they contain.\r\n\r\nNote: I'm not trying to achieve a dynamic programming approach where I consider the length of every policy and create the fewest possible number of groups by intelligently packing the policies together. I'm just trying to slice up the list into chunks such that `length(join(\"\\n\", chunk)) <= 6,144` for each chunk. An IAM role can have 10 policies attached, and I'm not in danger of running against that limit.\r\n\r\n```hcl\r\n# There are several dozen of these.\r\ndata \"aws_iam_policy_document\" \"1\" {...}\r\n\r\ndata \"aws_iam_policy_document\" \"2\" {...}\r\n\r\n# ...\r\n\r\n# Here are all of them:\r\nlocals {\r\n  iam_policy_documents = [\r\n    data.aws_iam_policy_document.1.json,\r\n    data.aws_iam_policy_document.2.json,\r\n    # ...\r\n  ]\r\n}\r\n\r\ndata \"aws_iam_policy_document\" \"combined\" {\r\n  for_each = \"some heinous nested for expression that I can't figure out\"\r\n\r\n  source_policy_documents = each.key\r\n}\r\n\r\nresource \"aws_iam_policy\" \"combined\" {\r\n  for_each = data.aws_iam_policy_document.combined\r\n\r\n  policy = each.value.json\r\n}\r\n```\r\n\r\nUntil now, I've been hand-maintaining chunks of policies and sort of eyeballing to make sure that each chunk doesn't go over the character limit, but the policies are templated in different environments with values of different lengths, so a hand-maintained chunk of policies that is <= 6,144 characters in my dev environment is not necessarily <= 6,144 characters in staging, production, or someone else's dev environment. It's been really painful. So I'd like Terraform to be able to chunk up the policies for me in a way that's always valid.", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "It has individual IAM policy stanzas, each defined in `aws_iam_policy_document` data sources, that are hand-maintained. ", "keywords": ["policy"]}, {"source": "Text", "text": "I need to combine these policy stanzas into valid IAM policies, and attach those policies to a role used by the automation process. ", "keywords": ["policy"]}, {"source": "Text", "text": "The problem is that an IAM policy has a character limit of 6,144 characters. ", "keywords": ["policy"]}, {"source": "Text", "text": "So, I need to dynamically chunk the long list of policy stanzas into groups of policies that, concatenated, are <= 6,144 characters each. ", "keywords": ["policy"]}, {"source": "Text", "text": "Note: I'm not trying to achieve a dynamic programming approach where I consider the length of every policy and create the fewest possible number of groups by intelligently packing the policies together. ", "keywords": ["policy"]}, {"source": "Text", "text": "```hcl # There are several dozen of these. data \"aws_iam_policy_document\" \"1\" {...} data \"aws_iam_policy_document\" \"2\" {...} # ... # Here are all of them: locals { iam_policy_documents = [ data.aws_iam_policy_document.1.json, data.aws_iam_policy_document.2.json, # ... ] } data \"aws_iam_policy_document\" \"combined\" { for_each = \"some heinous nested for expression that I can't figure out\" source_policy_documents = each.key } resource \"aws_iam_policy\" \"combined\" { for_each = data.aws_iam_policy_document.combined policy = each.value.json } ``` ", "keywords": ["policy"]}]}, {"Id": "273709517", "PostHistoryTypeId": "1", "PostId": "72891018", "RevisionGUID": "f2fdb56d-f9f2-4be6-aec8-03bb6ab7b7dd", "CreationDate": "2022-07-07T00:07:29.400", "UserId": "1620653", "Text": "Terraform: Chunk list of IAM policy stanzas to remain below 6,144 character limit", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "Terraform: Chunk list of IAM policy stanzas to remain below 6,144 character limit", "keywords": ["policy"]}]}, {"Id": "273709518", "PostHistoryTypeId": "3", "PostId": "72891018", "RevisionGUID": "f2fdb56d-f9f2-4be6-aec8-03bb6ab7b7dd", "CreationDate": "2022-07-07T00:07:29.400", "UserId": "1620653", "Text": "<terraform><amazon-iam>", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "contains-topic": true, "filtered-sentences": [{"source": "Title", "text": "Terraform: Chunk list of IAM policy stanzas to remain below 6,144 character limit", "keywords": ["policy"]}, {"source": "Body", "text": "It has individual IAM policy stanzas, each defined in aws_iam_policy_document data sources, that are hand-maintained. ", "keywords": ["policy"]}, {"source": "Body", "text": "I need to combine these policy stanzas into valid IAM policies, and attach those policies to a role used by the automation process. ", "keywords": ["policy"]}, {"source": "Body", "text": "The problem is that an IAM policy has a character limit of 6,144 characters. ", "keywords": ["policy"]}, {"source": "Body", "text": "So, I need to dynamically chunk the long list of policy stanzas into groups of policies that, concatenated, are <= 6,144 characters each. ", "keywords": ["policy"]}, {"source": "Body", "text": "Note: I'm not trying to achieve a dynamic programming approach where I consider the length of every policy and create the fewest possible number of groups by intelligently packing the policies together. ", "keywords": ["policy"]}]}