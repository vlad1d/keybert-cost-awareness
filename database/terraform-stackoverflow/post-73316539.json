{"Id": "73316539", "PostTypeId": "1", "AcceptedAnswerId": "73340697", "CreationDate": "2022-08-11T07:04:23.833", "Score": "0", "ViewCount": "312", "Body": "<p>Context: Implementation a Terraform Provider via TF Provider SDKv2 by following an <a href=\"https://learn.hashicorp.com/tutorials/terraform/provider-create?in=terraform/providers\" rel=\"nofollow noreferrer\">official tutorial</a>.</p>\n<blockquote>\n<p>As a result, all of the schema elements in the corresponding Terraform Provider resource aws_launch_configuration are marked as ForceNew: true. This behavior instructs Terraform to first destroy and then recreate the resource if any of the attributes change in the configuration, as opposed to trying to update the existing resource.</p>\n</blockquote>\n<p>TF tutorial <a href=\"https://www.terraform.io/plugin/sdkv2/schemas/schema-behaviors#forcenew\" rel=\"nofollow noreferrer\">suggests</a> we should add <code>ForceNew: true</code> for every non-updatable field like:</p>\n<pre><code>&quot;base_image&quot;: {\n  Type:     schema.TypeString,\n  Required: true,\n  ForceNew: true,\n},\n\nresource &quot;example_instance&quot; &quot;ex&quot; {\n  name = &quot;bastion host&quot;\n  base_image = &quot;ubuntu_17.10&quot; # base_image updates are not supported\n}\n</code></pre>\n<p>However one might run into the following:</p>\n<p>Let's consider &quot;important&quot; resources <code>foo_db_instance</code> (a DB instance that should be deleted / recreated in exceptional scenarios) (<a href=\"https://stackoverflow.com/questions/73256919/shall-we-introduce-deletion-protection-attribute-to-important-terraform-resour\">related unanswered question</a>) that has <code>name</code> attribute:</p>\n<pre><code>resource &quot;foo_db_instance&quot; &quot;ex&quot; {\n  name = &quot;bar&quot; # name updates are not supported\n  ...\n}\n</code></pre>\n<p>However its underlying API was written in a weird way and it doesn't support updates for <code>name</code> attribute. There're 2 options:</p>\n<ol>\n<li><p>Following approach of the tutorial, we might add <code>ForceNew: true</code> and then, if a user doesn't pay attention to <code>terraform plan</code> output it might recreate <code>foo_db_instance.ex</code> when updating <code>name</code> attribute by accident that will create an outage.</p>\n</li>\n<li><p>Don't follow the approach from the tutorial and don't add <code>ForceNew: true</code>. As a result <code>terraform plan</code> will not output the error and it will make it look like the update is possible. However when running <code>terraform apply</code> a user will run into an error, if we add a custom code to <code>resourceUpdate()</code> like this:</p>\n</li>\n</ol>\n<pre><code>func resourceUpdate(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {\n    if d.HasChanges(&quot;name) {\n        return diag.Errorf(&quot;error updating foo_db_instance: name attribute updates are not supported&quot;)\n    }\n  ...\n}\n</code></pre>\n<p>There're 2 disadvantages of this approach:</p>\n<ul>\n<li>non-failing output of <code>terraform plan</code></li>\n<li>we might need some hack to restore tf state to override <code>d.Set(name, oldValue)</code>.</li>\n</ul>\n<p>Which approach should be preferrable?</p>\n<p>I know there's <code>prevent_destroy = true</code> <a href=\"https://www.terraform.io/language/meta-arguments/lifecycle\" rel=\"nofollow noreferrer\">lifecycle attribute</a> but it seems like it won't prevent this specific scenario (it only prevents from accidental <code>terraform destroy</code>).</p>\n", "OwnerUserId": "18509753", "LastActivityDate": "2022-08-12T23:53:40.160", "Title": "Shall we include ForceNew or throw an error during \"terraform apply\" for a new TF resource?", "Tags": "<terraform><terraform-provider-aws><terraform-provider-gcp>", "AnswerCount": "1", "CommentCount": "3", "ContentLicense": "CC BY-SA 4.0", "comments": [{"Id": "129484971", "PostId": "73316539", "Score": "0", "Text": "If you want the capability to manage the name, then you must take option 1. If you do not, then it can be removed from the schema entirely. If you believe this can be fixed by fixing the API, then that would be the best route. However, there are resources which legitimately cannot successfully Update a `name`, and do require a re-create, so it may just not be possible through an API update.", "CreationDate": "2022-08-11T12:43:06.960", "UserId": "5343387", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "129491205", "PostId": "73316539", "Score": "0", "Text": "Right, a user does have to specify `name` in a create request (it's a mandatory field on an API level) so it's not something we could just remove / convert to computed field. And yet, API can't be fixed. Do you still think #1 is the best route possible? It seems pretty dangerous.", "CreationDate": "2022-08-11T16:58:41.170", "UserId": "18509753", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "129491823", "PostId": "73316539", "Score": "1", "Text": "No, I believe fixing the API and/or the underlying resource would be the best route possible. As far as I know #1 is the only route possible otherwise (since you state that is not possible) based on my observed behavior of all other providers.", "CreationDate": "2022-08-11T17:32:59.270", "UserId": "5343387", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "links": [{"Id": "1997118992", "CreationDate": "2022-08-11T07:04:23.833", "PostId": "73316539", "RelatedPostId": "73256919", "LinkTypeId": "1"}], "history": [{"Id": "276026569", "PostHistoryTypeId": "2", "PostId": "73316539", "RevisionGUID": "92368058-882d-4281-b802-5377e80609b8", "CreationDate": "2022-08-11T07:04:23.833", "UserId": "18509753", "Text": "Context: Implementation a Terraform Provider via TF Provider SDKv2 by following an [official tutorial][1].\r\n\r\n> As a result, all of the schema elements in the corresponding Terraform Provider resource aws_launch_configuration are marked as ForceNew: true. This behavior instructs Terraform to first destroy and then recreate the resource if any of the attributes change in the configuration, as opposed to trying to update the existing resource.\r\n\r\nTF tutorial [suggests](https://www.terraform.io/plugin/sdkv2/schemas/schema-behaviors#forcenew) we should add `ForceNew: true` for every non-updatable field like:\r\n```\r\n\"base_image\": {\r\n  Type:     schema.TypeString,\r\n  Required: true,\r\n  ForceNew: true,\r\n},\r\n\r\nresource \"example_instance\" \"ex\" {\r\n  name = \"bastion host\"\r\n  base_image = \"ubuntu_17.10\" # base_image updates are not supported\r\n}\r\n```\r\n\r\nHowever one might run into the following:\r\n\r\nLet's consider \"important\" resources `foo_db_instance` (a DB instance that should be deleted / recreated in exceptional scenarios) ([related unanswered question][2]) that has `name` attribute:\r\n\r\n```\r\nresource \"foo_db_instance\" \"ex\" {\r\n  name = \"bar\" # name updates are not supported\r\n  ...\r\n}\r\n```\r\n\r\nHowever its underlying API was written in a weird way and it doesn't support updates for `name` attribute. There're 2 options:\r\n\r\n\r\n1. Following approach of the tutorial, we might add `ForceNew: true` and then, if a user doesn't pay attention to `terraform plan` output it might recreate `foo_db_instance.ex` when updating `name` attribute by accident that will create an outage.\r\n\r\n2. Don't follow the approach from the tutorial and don't add `ForceNew: true`. As a result `terraform plan` will not output the error and it will make it look like the update is possible. However when running `terraform apply` a user will run into an error, if we add a custom code to `resourceUpdate()` like this:\r\n```\r\nfunc resourceUpdate(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {\r\n if d.HasChanges(\"name) {\r\n  return diag.Errorf(\"error updating foo_db_instance: name attribute updates are not supported\")\r\n }\r\n  ...\r\n}\r\n```\r\nThere're 2 disadvantages of this approach:\r\n\r\n* non-failing output of `terraform plan`\r\n* we might need some hack to restore tf state to override `d.Set(name, oldValue)`.\r\n\r\nWhich approach should be preferrable?\r\n\r\nI know there's `prevent_destroy = true` [lifecycle attribute][3] but it seems like it won't prevent this specific scenario (it only prevents from accidental `terraform destroy`).\r\n\r\n\r\n  [1]: https://learn.hashicorp.com/tutorials/terraform/provider-create?in=terraform/providers\r\n  [2]: https://stackoverflow.com/questions/73256919/shall-we-introduce-deletion-protection-attribute-to-important-terraform-resour\r\n  [3]: https://www.terraform.io/language/meta-arguments/lifecycle", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "Context: Implementation a Terraform Provider via TF Provider SDKv2 by following an [official tutorial][1]. ", "keywords": ["provider"]}, {"source": "Text", "text": "> As a result, all of the schema elements in the corresponding Terraform Provider resource aws_launch_configuration are marked as ForceNew: true. ", "keywords": ["provider"]}, {"source": "Text", "text": "This behavior instructs Terraform to first destroy and then recreate the resource if any of the attributes change in the configuration, as opposed to trying to update the existing resource. ", "keywords": ["change"]}, {"source": "Text", "text": "TF tutorial [suggests](https://www.terraform.io/plugin/sdkv2/schemas/schema-behaviors#forcenew) we should add `ForceNew: true` for every non-updatable field like: ``` \"base_image\": { Type: schema.TypeString, Required: true, ForceNew: true, }, resource \"example_instance\" \"ex\" { name = \"bastion host\" base_image = \"ubuntu_17.10\" # base_image updates are not supported } ``` However one might run into the following: Let's consider \"important\" resources `foo_db_instance` (a DB instance that should be deleted / recreated in exceptional scenarios) ([related unanswered question][2]) that has `name` attribute: ``` resource \"foo_db_instance\" \"ex\" { name = \"bar\" # name updates are not supported ... } ``` ", "keywords": ["instance"]}, {"source": "Text", "text": "Following approach of the tutorial, we might add `ForceNew: true` and then, if a user doesn't pay attention to `terraform plan` output it might recreate `foo_db_instance.ex` when updating `name` attribute by accident that will create an outage. ", "keywords": ["pay"]}, {"source": "Text", "text": "I know there's `prevent_destroy = true` [lifecycle attribute][3] but it seems like it won't prevent this specific scenario (it only prevents from accidental `terraform destroy`). [1]: https://learn.hashicorp.com/tutorials/terraform/provider-create?in=terraform/providers [2]: https://stackoverflow.com/questions/73256919/shall-we-introduce-deletion-protection-attribute-to-important-terraform-resour [3]: https://www.terraform.io/language/meta-arguments/lifecycle", "keywords": ["provider"]}]}, {"Id": "276026571", "PostHistoryTypeId": "1", "PostId": "73316539", "RevisionGUID": "92368058-882d-4281-b802-5377e80609b8", "CreationDate": "2022-08-11T07:04:23.833", "UserId": "18509753", "Text": "Shall we include ForceNew or throw an error during \"terraform apply\" for a new TF resource?", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "276026572", "PostHistoryTypeId": "3", "PostId": "73316539", "RevisionGUID": "92368058-882d-4281-b802-5377e80609b8", "CreationDate": "2022-08-11T07:04:23.833", "UserId": "18509753", "Text": "<terraform><terraform-provider-aws><terraform-provider-gcp>", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "answers": [{"Id": "73340697", "PostTypeId": "2", "ParentId": "73316539", "CreationDate": "2022-08-12T23:53:40.160", "Score": "1", "Body": "<p>The most typical answer is to follow your first option, and then allow Terraform to report in its UI that the change requires replacement and allow the user to decide how to proceed.</p>\n<p>It is true that if someone does not read the plan output then they can potentially make a change they did not intend to make, but in that case the user is not making use of the specific mechanism that Terraform provides to help users avoid making undesirable changes.</p>\n<p>You mentioned <code>prevent_destroy = true</code> and indeed that this a setting that's relevant to this situation, and is in fact exactly what that option is for: it will cause Terraform to raise an error if the plan includes a &quot;replace&quot; action for the resource that was annotated with that setting, thereby preventing the user from accepting the plan and thus from destroying the object.</p>\n<p>Some users also wrap Terraform in automation which will perform more complicated custom policy checks on the generated plan, either achieving a similar effect as <code>prevent_destroy</code> (blocking the operation altogether) or alternatively just requiring an additional confirmation to help ensure that the operator is aware that something unusual is happening. For example, in Terraform Cloud a programmatic policy can report a &quot;soft failure&quot; which causes an <em>additional</em> confirmation step that might be approvable only by a smaller subset of operators who are better equipped to understand the impact of what's being proposed.</p>\n<hr />\n<p>It is <em>in principle</em> possible to write logic in either the <code>CustomizeDiff</code> function (which runs during planning) or the <code>Update</code> function (which runs during the apply step) to return an error in this or any other situation you can write logic for in the Go programming language. Of these two options I would say that <code>CustomizeDiff</code> would be preferable since that would then prevent creating a plan at all, rather than allowing the creation of a plan and then failing partway through the apply step, when some other upstream changes may have already been applied.</p>\n<p>However, to do either of these would be inconsistent with the usual behavior users expect for Terraform providers. The intended model is for a Terraform provider to describe the effect of a change as accurately as possible and then allow the operator to make the final decision about whether the proposed change is acceptable, and to cancel the plan and choose another strategy if not.</p>\n", "OwnerUserId": "281848", "LastActivityDate": "2022-08-12T23:53:40.160", "CommentCount": "0", "ContentLicense": "CC BY-SA 4.0", "history": [{"Id": "276154400", "PostHistoryTypeId": "2", "PostId": "73340697", "RevisionGUID": "e056ee2c-90f9-4575-8059-46c33afbc5e2", "CreationDate": "2022-08-12T23:53:40.160", "UserId": "281848", "Text": "The most typical answer is to follow your first option, and then allow Terraform to report in its UI that the change requires replacement and allow the user to decide how to proceed.\r\n\r\nIt is true that if someone does not read the plan output then they can potentially make a change they did not intend to make, but in that case the user is not making use of the specific mechanism that Terraform provides to help users avoid making undesirable changes.\r\n\r\nYou mentioned `prevent_destroy = true` and indeed that this a setting that's relevant to this situation, and is in fact exactly what that option is for: it will cause Terraform to raise an error if the plan includes a \"replace\" action for the resource that was annotated with that setting, thereby preventing the user from accepting the plan and thus from destroying the object.\r\n\r\nSome users also wrap Terraform in automation which will perform more complicated custom policy checks on the generated plan, either achieving a similar effect as `prevent_destroy` (blocking the operation altogether) or alternatively just requiring an additional confirmation to help ensure that the operator is aware that something unusual is happening. For example, in Terraform Cloud a programmatic policy can report a \"soft failure\" which causes an _additional_ confirmation step that might be approvable only by a smaller subset of operators who are better equipped to understand the impact of what's being proposed.\r\n\r\n---\r\n\r\nIt is _in principle_ possible to write logic in either the `CustomizeDiff` function (which runs during planning) or the `Update` function (which runs during the apply step) to return an error in this or any other situation you can write logic for in the Go programming language. Of these two options I would say that `CustomizeDiff` would be preferable since that would then prevent creating a plan at all, rather than allowing the creation of a plan and then failing partway through the apply step, when some other upstream changes may have already been applied.\r\n\r\nHowever, to do either of these would be inconsistent with the usual behavior users expect for Terraform providers. The intended model is for a Terraform provider to describe the effect of a change as accurately as possible and then allow the operator to make the final decision about whether the proposed change is acceptable, and to cancel the plan and choose another strategy if not.\r\n", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "The most typical answer is to follow your first option, and then allow Terraform to report in its UI that the change requires replacement and allow the user to decide how to proceed. ", "keywords": ["change"]}, {"source": "Text", "text": "It is true that if someone does not read the plan output then they can potentially make a change they did not intend to make, but in that case the user is not making use of the specific mechanism that Terraform provides to help users avoid making undesirable changes. ", "keywords": ["change"]}, {"source": "Text", "text": "Some users also wrap Terraform in automation which will perform more complicated custom policy checks on the generated plan, either achieving a similar effect as `prevent_destroy` (blocking the operation altogether) or alternatively just requiring an additional confirmation to help ensure that the operator is aware that something unusual is happening. ", "keywords": ["policy"]}, {"source": "Text", "text": "For example, in Terraform Cloud a programmatic policy can report a \"soft failure\" which causes an _additional_ confirmation step that might be approvable only by a smaller subset of operators who are better equipped to understand the impact of what's being proposed. ", "keywords": ["policy"]}, {"source": "Text", "text": "Of these two options I would say that `CustomizeDiff` would be preferable since that would then prevent creating a plan at all, rather than allowing the creation of a plan and then failing partway through the apply step, when some other upstream changes may have already been applied. ", "keywords": ["change"]}, {"source": "Text", "text": "The intended model is for a Terraform provider to describe the effect of a change as accurately as possible and then allow the operator to make the final decision about whether the proposed change is acceptable, and to cancel the plan and choose another strategy if not.", "keywords": ["provider", "change"]}]}], "filtered-sentences": [{"source": "Body", "text": "The most typical answer is to follow your first option, and then allow Terraform to report in its UI that the change requires replacement and allow the user to decide how to proceed. ", "keywords": ["change"]}, {"source": "Body", "text": "It is true that if someone does not read the plan output then they can potentially make a change they did not intend to make, but in that case the user is not making use of the specific mechanism that Terraform provides to help users avoid making undesirable changes. ", "keywords": ["change"]}, {"source": "Body", "text": "Some users also wrap Terraform in automation which will perform more complicated custom policy checks on the generated plan, either achieving a similar effect as prevent_destroy (blocking the operation altogether) or alternatively just requiring an additional confirmation to help ensure that the operator is aware that something unusual is happening. ", "keywords": ["policy"]}, {"source": "Body", "text": "For example, in Terraform Cloud a programmatic policy can report a \"soft failure\" which causes an additional confirmation step that might be approvable only by a smaller subset of operators who are better equipped to understand the impact of what's being proposed. ", "keywords": ["policy"]}, {"source": "Body", "text": "Of these two options I would say that CustomizeDiff would be preferable since that would then prevent creating a plan at all, rather than allowing the creation of a plan and then failing partway through the apply step, when some other upstream changes may have already been applied. ", "keywords": ["change"]}, {"source": "Body", "text": "The intended model is for a Terraform provider to describe the effect of a change as accurately as possible and then allow the operator to make the final decision about whether the proposed change is acceptable, and to cancel the plan and choose another strategy if not.", "keywords": ["provider", "change"]}]}], "contains-topic": true, "filtered-sentences": [{"source": "Body", "text": "Context: Implementation a Terraform Provider via TF Provider SDKv2 by following an official tutorial. ", "keywords": ["provider"]}, {"source": "Body", "text": "As a result, all of the schema elements in the corresponding Terraform Provider resource aws_launch_configuration are marked as ForceNew: true. ", "keywords": ["provider"]}, {"source": "Body", "text": "This behavior instructs Terraform to first destroy and then recreate the resource if any of the attributes change in the configuration, as opposed to trying to update the existing resource. ", "keywords": ["change"]}, {"source": "Body", "text": "TF tutorial suggests we should add ForceNew: true for every non-updatable field like: However one might run into the following: Let's consider \"important\" resources foo_db_instance (a DB instance that should be deleted / recreated in exceptional scenarios) (related unanswered question) that has name attribute: However its underlying API was written in a weird way and it doesn't support updates for name attribute. ", "keywords": ["instance"]}, {"source": "Body", "text": "There're 2 options: Following approach of the tutorial, we might add ForceNew: true and then, if a user doesn't pay attention to terraform plan output it might recreate foo_db_instance.ex when updating name attribute by accident that will create an outage. ", "keywords": ["pay"]}]}