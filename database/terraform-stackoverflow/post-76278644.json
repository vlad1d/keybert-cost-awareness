{"Id": "76278644", "PostTypeId": "1", "AcceptedAnswerId": "76285539", "CreationDate": "2023-05-18T07:29:48.097", "Score": "1", "ViewCount": "125", "Body": "<p>I have an SNS module that creates an SNS topic.</p>\n<p>I'm calling this with:</p>\n<pre><code>module &quot;sns&quot; {\n  source                                = &quot;git@.../sns&quot;\n}\n</code></pre>\n<p>It outputs a simple string</p>\n<pre><code>output &quot;topic&quot; {\n  value                               = aws_sns_topic.topic.arn\n}\n</code></pre>\n<p>This is then used in my two other modules, the &quot;EC/Redis&quot; and &quot;ECS&quot; modules:</p>\n<pre><code>module &quot;ecs&quot; { # and &quot;redis&quot;\n  sns_topic                             = module.sns.topic\n\n  depends_on                            = [module.sns]\n}\n</code></pre>\n<p>Each of these modules takes a string that can be null:</p>\n<pre><code>variable &quot;sns_topic&quot; {\n  description                           = &quot;ARN of SNS topic&quot;\n  type                                  = string\n  default                               = null\n}\n</code></pre>\n<p>Then in each of these two modules, I create a <code>aws_cloudwatch_metric_alarm</code> within a count, checking for this:</p>\n<pre><code>resource &quot;aws_cloudwatch_metric_alarm&quot; &quot;cpu_high&quot; {\n  count                                 = var.sns_topic != null ? 1 : 0\n\n  [...]\n}\n</code></pre>\n<p>HOWEVER, for some reason I get:</p>\n<pre><code>Error: Invalid count argument\n\n  on .terraform/modules/&lt;redis_module&gt;/alarms.tf line 2, in resource &quot;aws_cloudwatch_metric_alarm&quot; &quot;cpu_high&quot;:\n   2:   count                                   = var.sns_topic != null ? 1 : 0\n\nThe &quot;count&quot; value depends on resource attributes that cannot be determined\nuntil apply, so Terraform cannot predict how many instances will be created.\nTo work around this, use the -target argument to first apply only the\nresources that the count depends on.\n</code></pre>\n<p>Looking at the <code>plan</code>, I see that the <strong>sns</strong> module is (supposed to be) created <em>after</em> both the ECS and REDIS modules. If the order of the plan is anything to go by, that is..</p>\n<p>I've even tried to set a <code>depends_on = [module.sns]</code> in both the ECS and REDIS module, but that didn't help..</p>\n<p>Any ideas? Any workaround? Other than going through the modules, one at a time and do an <code>apply</code> on them? That's currently the only way we can get it all built at this time, but I'd like to fix that..</p>\n<p>NOTE: We have use-cases where we don't want/need the extra cost or complexity of alarms and topics, so I'd like to have this as a null-able variable..</p>\n<p>I've also tried (in the ECS and REDIS modules) to use a <code>local</code>, which have helped in some other similar cases:</p>\n<pre><code>locals {\n  sns                                   = var.sns_topic != null ? true : false\n}\n</code></pre>\n<p>And then check for that instead:</p>\n<pre><code>resource &quot;aws_cloudwatch_metric_alarm&quot; &quot;cpu_high&quot; {\n  count                                 = local.sns ? 1 : 0\n\n  [...]\n}\n</code></pre>\n<p>But that didn't change anything. I'd EXPECT the error to come from the <code>locals</code> part, but it still came from the <code>aws_cloudwatch_metric_alarm</code> resource!</p>\n", "OwnerUserId": "2434397", "LastEditorUserId": "2434397", "LastEditDate": "2023-05-18T07:59:01.000", "LastActivityDate": "2023-05-19T02:00:11.303", "Title": "Can't get Terraform module dependencies to work", "Tags": "<terraform>", "AnswerCount": "1", "CommentCount": "5", "ContentLicense": "CC BY-SA 4.0", "comments": [{"Id": "134512642", "PostId": "76278644", "Score": "0", "Text": "Can you add how you are calling all the modules to the question?", "CreationDate": "2023-05-18T07:45:43.857", "UserId": "8343484", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "134512660", "PostId": "76278644", "Score": "0", "Text": "I did, second snippet..", "CreationDate": "2023-05-18T07:47:39.290", "UserId": "2434397", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "134512672", "PostId": "76278644", "Score": "0", "Text": "You actually haven't, the call to the SNS module is missing.", "CreationDate": "2023-05-18T07:49:04.873", "UserId": "8343484", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "134512701", "PostId": "76278644", "Score": "0", "Text": "Well, since it's hard to follow where all the stuff is coming from, it might make a difference. Also, that should go to the question, not comments.", "CreationDate": "2023-05-18T07:51:46.650", "UserId": "8343484", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "134512826", "PostId": "76278644", "Score": "0", "Text": "Ok, updated with more info and attempts..", "CreationDate": "2023-05-18T08:03:44.267", "UserId": "2434397", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "history": [{"Id": "292962587", "PostHistoryTypeId": "2", "PostId": "76278644", "RevisionGUID": "fce01803-b774-429a-8052-17884f82fbb2", "CreationDate": "2023-05-18T07:29:48.097", "UserId": "2434397", "Text": "I have an SNS module that creates an SNS topic.\r\n\r\nIt outputs a simple string\r\n```\r\noutput \"topic\" {\r\n    value                               = aws_sns_topic.topic.arn\r\n}\r\n```\r\n\r\nThis is then used in my two other modules, the \"EC/Redis\" and \"ECS\" modules:\r\n```\r\nmodule \"ecs\" { # and \"redis\"\r\n  sns_topic                             = module.sns.topic\r\n}\r\n```\r\n\r\nEach of these modules takes a string that can be null:\r\n```\r\nvariable \"sns_topic\" {\r\n  description                           = \"ARN of SNS topic\"\r\n  type                                  = string\r\n  default                               = null\r\n}\r\n```\r\n\r\nThen in each of these two modules, I create a `aws_cloudwatch_metric_alarm` within a count, checking for this:\r\n```\r\nresource \"aws_cloudwatch_metric_alarm\" \"cpu_high\" {\r\n  count                                 = var.sns_topic != null ? 1 : 0\r\n\r\n  [...]\r\n}\r\n```\r\n\r\nHOWEVER, for some reason I get:\r\n```\r\nError: Invalid count argument\r\n\r\n  on .terraform/modules/<redis_module>/alarms.tf line 2, in resource \"aws_cloudwatch_metric_alarm\" \"cpu_high\":\r\n   2:   count                                   = var.sns_topic != null ? 1 : 0\r\n\r\nThe \"count\" value depends on resource attributes that cannot be determined\r\nuntil apply, so Terraform cannot predict how many instances will be created.\r\nTo work around this, use the -target argument to first apply only the\r\nresources that the count depends on.\r\n```\r\n\r\nLooking at the `plan`, I see that the **sns** module is (supposed to be) created *after* both the ECS and REDIS modules. If the order of the plan is anything to go by, that is..\r\n\r\nI've even tried to set a `depends_on = [module.sns]` in both the ECS and REDIS module, but that didn't help..\r\n\r\n\r\nAny ideas? Any workaround? Other than going through the modules, one at a time and do an `apply` on them? That's currently the only way we can get it all built at this time, but I'd like to fix that..\r\n\r\n\r\nNOTE: We have use-cases where we don't want/need the extra cost or complexity of alarms and topics, so I'd like to have this as a null-able variable..", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "NOTE: We have use-cases where we don't want/need the extra cost or complexity of alarms and topics, so I'd like to have this as a null-able variable..", "keywords": ["cost"]}]}, {"Id": "292962589", "PostHistoryTypeId": "1", "PostId": "76278644", "RevisionGUID": "fce01803-b774-429a-8052-17884f82fbb2", "CreationDate": "2023-05-18T07:29:48.097", "UserId": "2434397", "Text": "Can't get Terraform module dependencies to work", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "292962590", "PostHistoryTypeId": "3", "PostId": "76278644", "RevisionGUID": "fce01803-b774-429a-8052-17884f82fbb2", "CreationDate": "2023-05-18T07:29:48.097", "UserId": "2434397", "Text": "<terraform>", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "292963541", "PostHistoryTypeId": "5", "PostId": "76278644", "RevisionGUID": "d0944b86-8659-4ddb-8a35-7a4aba1fefc2", "CreationDate": "2023-05-18T07:53:45.433", "UserId": "2434397", "Comment": "added 110 characters in body", "Text": "I have an SNS module that creates an SNS topic.\r\n\r\nI'm calling this with:\r\n```\r\nmodule \"sns\" {\r\n  source                                = \"git@.../sns\"\r\n}\r\n```\r\n\r\nIt outputs a simple string\r\n```\r\noutput \"topic\" {\r\n  value                               = aws_sns_topic.topic.arn\r\n}\r\n```\r\n\r\nThis is then used in my two other modules, the \"EC/Redis\" and \"ECS\" modules:\r\n```\r\nmodule \"ecs\" { # and \"redis\"\r\n  sns_topic                             = module.sns.topic\r\n}\r\n```\r\n\r\nEach of these modules takes a string that can be null:\r\n```\r\nvariable \"sns_topic\" {\r\n  description                           = \"ARN of SNS topic\"\r\n  type                                  = string\r\n  default                               = null\r\n}\r\n```\r\n\r\nThen in each of these two modules, I create a `aws_cloudwatch_metric_alarm` within a count, checking for this:\r\n```\r\nresource \"aws_cloudwatch_metric_alarm\" \"cpu_high\" {\r\n  count                                 = var.sns_topic != null ? 1 : 0\r\n\r\n  [...]\r\n}\r\n```\r\n\r\nHOWEVER, for some reason I get:\r\n```\r\nError: Invalid count argument\r\n\r\n  on .terraform/modules/<redis_module>/alarms.tf line 2, in resource \"aws_cloudwatch_metric_alarm\" \"cpu_high\":\r\n   2:   count                                   = var.sns_topic != null ? 1 : 0\r\n\r\nThe \"count\" value depends on resource attributes that cannot be determined\r\nuntil apply, so Terraform cannot predict how many instances will be created.\r\nTo work around this, use the -target argument to first apply only the\r\nresources that the count depends on.\r\n```\r\n\r\nLooking at the `plan`, I see that the **sns** module is (supposed to be) created *after* both the ECS and REDIS modules. If the order of the plan is anything to go by, that is..\r\n\r\nI've even tried to set a `depends_on = [module.sns]` in both the ECS and REDIS module, but that didn't help..\r\n\r\n\r\nAny ideas? Any workaround? Other than going through the modules, one at a time and do an `apply` on them? That's currently the only way we can get it all built at this time, but I'd like to fix that..\r\n\r\n\r\nNOTE: We have use-cases where we don't want/need the extra cost or complexity of alarms and topics, so I'd like to have this as a null-able variable..", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "NOTE: We have use-cases where we don't want/need the extra cost or complexity of alarms and topics, so I'd like to have this as a null-able variable..", "keywords": ["cost"]}]}, {"Id": "292963712", "PostHistoryTypeId": "5", "PostId": "76278644", "RevisionGUID": "9e590a9d-e3f9-41b3-b3b2-9fb4fc6c68e6", "CreationDate": "2023-05-18T07:59:01.000", "UserId": "2434397", "Comment": "added 110 characters in body", "Text": "I have an SNS module that creates an SNS topic.\r\n\r\nI'm calling this with:\r\n```\r\nmodule \"sns\" {\r\n  source                                = \"git@.../sns\"\r\n}\r\n```\r\n\r\nIt outputs a simple string\r\n```\r\noutput \"topic\" {\r\n  value                               = aws_sns_topic.topic.arn\r\n}\r\n```\r\n\r\nThis is then used in my two other modules, the \"EC/Redis\" and \"ECS\" modules:\r\n```\r\nmodule \"ecs\" { # and \"redis\"\r\n  sns_topic                             = module.sns.topic\r\n\r\n  depends_on                            = [module.sns]\r\n}\r\n```\r\n\r\nEach of these modules takes a string that can be null:\r\n```\r\nvariable \"sns_topic\" {\r\n  description                           = \"ARN of SNS topic\"\r\n  type                                  = string\r\n  default                               = null\r\n}\r\n```\r\n\r\nThen in each of these two modules, I create a `aws_cloudwatch_metric_alarm` within a count, checking for this:\r\n```\r\nresource \"aws_cloudwatch_metric_alarm\" \"cpu_high\" {\r\n  count                                 = var.sns_topic != null ? 1 : 0\r\n\r\n  [...]\r\n}\r\n```\r\n\r\nHOWEVER, for some reason I get:\r\n```\r\nError: Invalid count argument\r\n\r\n  on .terraform/modules/<redis_module>/alarms.tf line 2, in resource \"aws_cloudwatch_metric_alarm\" \"cpu_high\":\r\n   2:   count                                   = var.sns_topic != null ? 1 : 0\r\n\r\nThe \"count\" value depends on resource attributes that cannot be determined\r\nuntil apply, so Terraform cannot predict how many instances will be created.\r\nTo work around this, use the -target argument to first apply only the\r\nresources that the count depends on.\r\n```\r\n\r\nLooking at the `plan`, I see that the **sns** module is (supposed to be) created *after* both the ECS and REDIS modules. If the order of the plan is anything to go by, that is..\r\n\r\nI've even tried to set a `depends_on = [module.sns]` in both the ECS and REDIS module, but that didn't help..\r\n\r\n\r\nAny ideas? Any workaround? Other than going through the modules, one at a time and do an `apply` on them? That's currently the only way we can get it all built at this time, but I'd like to fix that..\r\n\r\n\r\nNOTE: We have use-cases where we don't want/need the extra cost or complexity of alarms and topics, so I'd like to have this as a null-able variable..\r\n\r\n\r\nI've also tried (in the ECS and REDIS modules) to use a `local`, which have helped in some other similar cases:\r\n```\r\nlocals {\r\n  sns                                   = var.sns_topic != null ? true : false\r\n}\r\n```\r\n\r\nAnd then check for that instead:\r\n```\r\nresource \"aws_cloudwatch_metric_alarm\" \"cpu_high\" {\r\n  count                                 = local.sns ? 1 : 0\r\n\r\n  [...]\r\n}\r\n```\r\n\r\nBut that didn't change anything. I'd EXPECT the error to come from the `locals` part, but it still came from the `aws_cloudwatch_metric_alarm` resource!\r\n", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "NOTE: We have use-cases where we don't want/need the extra cost or complexity of alarms and topics, so I'd like to have this as a null-able variable.. ", "keywords": ["cost"]}, {"source": "Text", "text": "But that didn't change anything. ", "keywords": ["change"]}]}], "answers": [{"Id": "76285539", "PostTypeId": "2", "ParentId": "76278644", "CreationDate": "2023-05-19T02:00:11.303", "Score": "3", "Body": "<p>The problem in this situation is that the <code>hashicorp/aws</code> Terraform provider does not report the final value for <code>arn</code> until the SNS topic has already been applied, and so during initial planning Terraform does not know its value and so it cannot determine whether the value is null, so it therefore cannot decide how many instances of this resource should exist.</p>\n<p>You can avoid this problem by passing in an object representing the SNS topic rather than just its ARN, and then test whether the object as a whole is <code>null</code>, rather than whether the ARN is null.</p>\n<pre><code>variable &quot;sns_topic&quot; {\n  type    = object({\n    arn = string\n    # (you can include other attributes here in future\n    # if you discover new requirements for your module)\n  })\n  default = null\n}\n\nresource &quot;aws_cloudwatch_metric_alarm&quot; &quot;cpu_high&quot; {\n  count = var.sns_topic != null ? 1 : 0\n\n  # ...\n  alarm_actions = [var.sns_topic.arn]\n  # ...\n}\n</code></pre>\n<p>You can make this easier to use by changing your <code>sns</code> module to return an object matching this object type:</p>\n<pre><code>output &quot;topic&quot; {\n  value = {\n    arn = aws_sns_topic.topic.arn\n  }\n}\n</code></pre>\n<p>Then when you pass that to the other module, you'll pass the entire object:</p>\n<pre><code>module &quot;ecs&quot; {\n  # ...\n  sns_topic = module.sns.topic\n  # ...\n}\n</code></pre>\n<p>The reason this can work while your approach did not is that Terraform can see that the <em>whole object</em> is non-null even if the <code>arn</code> attribute inside is not known yet. This separates the information about whether the argument is set from the information about which specific <code>arn</code> to use, and so only the <code>aws_cloudwatch_metric_alarm</code>'s <code>alarm_actions</code> argument (or whichever other actions arguments you are using) needs to deal with the unknown value, which is okay because that resource type can support the action ARNs being unknown during the planning step. (They will show as <code>(known after apply)</code> in the plan.)</p>\n", "OwnerUserId": "281848", "LastActivityDate": "2023-05-19T02:00:11.303", "CommentCount": "1", "ContentLicense": "CC BY-SA 4.0", "comments": [{"Id": "134526846", "PostId": "76285539", "Score": "1", "Text": "BRILLIANT!!! That worked like a charm! AND, I'm more thankful for your explanation to WHY. It explains a lot of other issues I've had in the past, where it eventually \"magically\" \"just worked\", and I never knew why!! :D :D\n\nThank you millions for that!", "CreationDate": "2023-05-19T07:57:08.617", "UserId": "2434397", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "history": [{"Id": "293003130", "PostHistoryTypeId": "2", "PostId": "76285539", "RevisionGUID": "53535587-4f45-4883-bab7-6c27811a2965", "CreationDate": "2023-05-19T02:00:11.303", "UserId": "281848", "Text": "The problem in this situation is that the `hashicorp/aws` Terraform provider does not report the final value for `arn` until the SNS topic has already been applied, and so during initial planning Terraform does not know its value and so it cannot determine whether the value is null, so it therefore cannot decide how many instances of this resource should exist.\r\n\r\nYou can avoid this problem by passing in an object representing the SNS topic rather than just its ARN, and then test whether the object as a whole is `null`, rather than whether the ARN is null.\r\n\r\n```\r\nvariable \"sns_topic\" {\r\n  type    = object({\r\n    arn = string\r\n    # (you can include other attributes here in future\r\n    # if you discover new requirements for your module)\r\n  })\r\n  default = null\r\n}\r\n\r\nresource \"aws_cloudwatch_metric_alarm\" \"cpu_high\" {\r\n  count = var.sns_topic != null ? 1 : 0\r\n\r\n  # ...\r\n  alarm_actions = [var.sns_topic.arn]\r\n  # ...\r\n}\r\n```\r\n\r\nYou can make this easier to use by changing your `sns` module to return an object matching this object type:\r\n\r\n```\r\noutput \"topic\" {\r\n  value = {\r\n    arn = aws_sns_topic.topic.arn\r\n  }\r\n}\r\n```\r\n\r\nThen when you pass that to the other module, you'll pass the entire object:\r\n\r\n```\r\nmodule \"ecs\" {\r\n  # ...\r\n  sns_topic = module.sns.topic\r\n  # ...\r\n}\r\n```\r\n\r\nThe reason this can work while your approach did not is that Terraform can see that the _whole object_ is non-null even if the `arn` attribute inside is not known yet. This separates the information about whether the argument is set from the information about which specific `arn` to use, and so only the `aws_cloudwatch_metric_alarm`'s `alarm_actions` argument (or whichever other actions arguments you are using) needs to deal with the unknown value, which is okay because that resource type can support the action ARNs being unknown during the planning step. (They will show as `(known after apply)` in the plan.)\r\n\r\n", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "Terraform provider does not report the final value for `arn` until the SNS topic has already been applied, and so during initial planning Terraform does not know its value and so it cannot determine whether the value is null, so it therefore cannot decide how many instances of this resource should exist. ", "keywords": ["provider"]}, {"source": "Text", "text": "You can avoid this problem by passing in an object representing the SNS topic rather than just its ARN, and then test whether the object as a whole is `null`, rather than whether the ARN is null. ", "keywords": ["test"]}, {"source": "Text", "text": "``` variable \"sns_topic\" { type = object({ arn = string # (you can include other attributes here in future # if you discover new requirements for your module) }) default = null } resource \"aws_cloudwatch_metric_alarm\" \"cpu_high\" { count = var.sns_topic != null ? 1 : 0 # ... alarm_actions = [var.sns_topic.arn] # ... } ``` You can make this easier to use by changing your `sns` module to return an object matching this object type: ``` output \"topic\" { value = { arn = aws_sns_topic.topic.arn } } ``` Then when you pass that to the other module, you'll pass the entire object: ``` module \"ecs\" { # ... sns_topic = module.sns.topic # ... } ``` The reason this can work while your approach did not is that Terraform can see that the _whole object_ is non-null even if the `arn` attribute inside is not known yet. ", "keywords": ["change"]}]}], "filtered-sentences": [{"source": "Body", "text": "The problem in this situation is that the hashicorp/aws Terraform provider does not report the final value for arn until the SNS topic has already been applied, and so during initial planning Terraform does not know its value and so it cannot determine whether the value is null, so it therefore cannot decide how many instances of this resource should exist. ", "keywords": ["provider"]}, {"source": "Body", "text": "You can avoid this problem by passing in an object representing the SNS topic rather than just its ARN, and then test whether the object as a whole is null, rather than whether the ARN is null. ", "keywords": ["test"]}, {"source": "Body", "text": "You can make this easier to use by changing your sns module to return an object matching this object type: ", "keywords": ["change"]}]}], "contains-topic": true, "filtered-sentences": [{"source": "Body", "text": "NOTE: We have use-cases where we don't want/need the extra cost or complexity of alarms and topics, so I'd like to have this as a null-able variable.. ", "keywords": ["cost"]}, {"source": "Body", "text": "I've also tried (in the ECS and REDIS modules) to use a local, which have helped in some other similar cases: And then check for that instead: But that didn't change anything. ", "keywords": ["change"]}]}