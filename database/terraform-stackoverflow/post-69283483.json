{"Id": "69283483", "PostTypeId": "1", "CreationDate": "2021-09-22T11:39:19.600", "Score": "2", "ViewCount": "1393", "Body": "<p>i am creating a codepipeline for a microservice based application. i want to utilize one single pipeline and codebuild project for this CICD.\nI have a specific case where i am using more then two actions in source stage. every action gets code from different github repo and generate different output artifacts. then in next stage i have created multiple build action which takes input artifacts from respected output artifacts of mapped source action.\nthe problem i am facing is that code change in one of repo triggers every action to start full pipeline that results in new deployment of every microservice.\ni am using terraform for creating all this.</p>\n<p><a href=\"https://i.stack.imgur.com/4Eqhe.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/4Eqhe.png\" alt=\"enter image description here\" /></a></p>\n<p>when code changes in <strong>Source-dm</strong>then only source-dm of Source Stage and DM-Build should run and deployment just happens only in DM microservice.\nplease help me getting a swift fix.\nthanks in advance.</p>\n", "OwnerUserId": "7605455", "LastActivityDate": "2021-09-22T19:59:27.270", "Title": "AWS Codepipeline with multiple source and build actions", "Tags": "<terraform><aws-codepipeline><aws-codebuild><multibranch-pipeline>", "AnswerCount": "1", "CommentCount": "0", "ContentLicense": "CC BY-SA 4.0", "history": [{"Id": "254265879", "PostHistoryTypeId": "2", "PostId": "69283483", "RevisionGUID": "0c7128f7-206c-4a83-9559-d8d0e1cbd8f6", "CreationDate": "2021-09-22T11:39:19.600", "UserId": "7605455", "Text": "i am creating a codepipeline for a microservice based application. i want to utilize one single pipeline and codebuild project for this CICD.\r\nI have a specific case where i am using more then two actions in source stage. every action gets code from different github repo and generate different output artifacts. then in next stage i have created multiple build action which takes input artifacts from respected output artifacts of mapped source action.\r\nthe problem i am facing is that code change in one of repo triggers every action to start full pipeline that results in new deployment of every microservice.\r\ni am using terraform for creating all this.\r\n\r\n[![enter image description here][1]][1]\r\n\r\n\r\n  [1]: https://i.stack.imgur.com/4Eqhe.png\r\nwhen code changes in **Source-dm**then only source-dm of Source Stage and DM-Build should run and deployment just happens only in DM microservice.\r\nplease help me getting a swift fix.\r\nthanks in advance.", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "the problem i am facing is that code change in one of repo triggers every action to start full pipeline that results in new deployment of every microservice. ", "keywords": ["change"]}, {"source": "Text", "text": "[![enter image description here][1]][1] [1]: https://i.stack.imgur.com/4Eqhe.png when code changes in **Source-dm**then only source-dm of Source Stage and DM-Build should run and deployment just happens only in DM microservice. ", "keywords": ["change"]}]}, {"Id": "254265881", "PostHistoryTypeId": "1", "PostId": "69283483", "RevisionGUID": "0c7128f7-206c-4a83-9559-d8d0e1cbd8f6", "CreationDate": "2021-09-22T11:39:19.600", "UserId": "7605455", "Text": "AWS Codepipeline with multiple source and build actions", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "254265882", "PostHistoryTypeId": "3", "PostId": "69283483", "RevisionGUID": "0c7128f7-206c-4a83-9559-d8d0e1cbd8f6", "CreationDate": "2021-09-22T11:39:19.600", "UserId": "7605455", "Text": "<terraform><aws-codepipeline><aws-codebuild><multibranch-pipeline>", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "answers": [{"Id": "69290555", "PostTypeId": "2", "ParentId": "69283483", "CreationDate": "2021-09-22T19:59:27.270", "Score": "2", "Body": "<p>I don't believe that you can pull this out with a single CodePipeline, at least you can't do it natively.</p>\n<p>In general, you either have PollForSourceChanges or webhook enabled or you don't. As you are using Github Version 2 Connection as far I can see from the screenshot, changes in either of the repos will trigger your pipeline as you describe.</p>\n<p>I can think of a few options which could solve your issue and from which you can choose based on your use case.</p>\n<ol>\n<li>The obvious one would be to have one pipeline per repo (one for dm and one for sampling - in that case whenever there is a change in one of them you'll just build and deploy to the respective microservice (you'll need to absorb the cost of 1$ for one additional pipeline in that region)</li>\n<li>You can produce a hash of the build on the second step and then add a check prior the deployment to see whether the checksums are matching and if they are do not deploy the new build for this service.</li>\n<li>You can potentially add a check in the buildspec of the build to see whether the commit id from the current execution matches the previous one and if that's the case silently ignore it and don't produce a build. Then have another check in the one with which you deploy the microservice to see whether there is a new build and in case the answer is no, do not deploy.</li>\n<li>You can still use this pipeline for the builds, but then cascade it to another one (or another job for the deployment process). In that job (could be a lambda) you can check whether the commit id from each repo matches the commit version from the previous exectuon and then only deploy to the one that was actually changed.</li>\n</ol>\n<p>If it was me, and in case there is some context that we are missing, as you havent mentioned it, the best possible approach is Option 1, just create two separate pipelines, as the other options are adding unneeded complexity.</p>\n", "OwnerUserId": "9405602", "LastActivityDate": "2021-09-22T19:59:27.270", "CommentCount": "2", "ContentLicense": "CC BY-SA 4.0", "comments": [{"Id": "122485012", "PostId": "69290555", "Score": "0", "Text": "okay, In this case i am agree to go with your first suggestion. but what would happen when there are 100 microservices, would it be feasible to create 100 codepipeline then ?", "CreationDate": "2021-09-23T12:21:21.243", "UserId": "7605455", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "122486428", "PostId": "69290555", "Score": "0", "Text": "It would depend on a few factors like do you just want to build them and deploy later, or you want to build and deploy right way. And on the way you deploy them, whether you are going to deploy them separately or they have dependencies, etc. It will depend on your repo architecture (having 100 micro-services doesn't necessariy mean that you would 100 repositories, one for each)", "CreationDate": "2021-09-23T13:12:08.180", "UserId": "9405602", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "history": [{"Id": "254302220", "PostHistoryTypeId": "2", "PostId": "69290555", "RevisionGUID": "337b5418-ee3e-43ae-a534-adf95f242d4c", "CreationDate": "2021-09-22T19:59:27.270", "UserId": "9405602", "Text": "I don't believe that you can pull this out with a single CodePipeline, at least you can't do it natively.\r\n\r\nIn general, you either have PollForSourceChanges or webhook enabled or you don't. As you are using Github Version 2 Connection as far I can see from the screenshot, changes in either of the repos will trigger your pipeline as you describe.\r\n\r\nI can think of a few options which could solve your issue and from which you can choose based on your use case.\r\n1. The obvious one would be to have one pipeline per repo (one for dm and one for sampling - in that case whenever there is a change in one of them you'll just build and deploy to the respective microservice (you'll need to absorb the cost of 1$ for one additional pipeline in that region)\r\n2. You can produce a hash of the build on the second step and then add a check prior the deployment to see whether the checksums are matching and if they are do not deploy the new build for this service. \r\n3. You can potentially add a check in the buildspec of the build to see whether the commit id from the current execution matches the previous one and if that's the case silently ignore it and don't produce a build. Then have another check in the one with which you deploy the microservice to see whether there is a new build and in case the answer is no, do not deploy.\r\n3. You can still use this pipeline for the builds, but then cascade it to another one (or another job for the deployment process). In that job (could be a lambda) you can check whether the commit id from each repo matches the commit version from the previous exectuon and then only deploy to the one that was actually changed.\r\n\r\nIf it was me, and in case there is some context that we are missing, as you havent mentioned it, the best possible approach is Option 1, just create two separate pipelines, as the other options are adding unneeded complexity.", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "As you are using Github Version 2 Connection as far I can see from the screenshot, changes in either of the repos will trigger your pipeline as you describe. ", "keywords": ["change"]}, {"source": "Text", "text": "1. The obvious one would be to have one pipeline per repo (one for dm and one for sampling - in that case whenever there is a change in one of them you'll just build and deploy to the respective microservice (you'll need to absorb the cost of 1$ for one additional pipeline in that region) ", "keywords": ["cost", "change"]}, {"source": "Text", "text": "In that job (could be a lambda) you can check whether the commit id from each repo matches the commit version from the previous exectuon and then only deploy to the one that was actually changed. ", "keywords": ["change"]}]}], "filtered-sentences": [{"source": "Body", "text": "As you are using Github Version 2 Connection as far I can see from the screenshot, changes in either of the repos will trigger your pipeline as you describe. ", "keywords": ["change"]}, {"source": "Body", "text": "The obvious one would be to have one pipeline per repo (one for dm and one for sampling - in that case whenever there is a change in one of them you'll just build and deploy to the respective microservice (you'll need to absorb the cost of 1$ for one additional pipeline in that region) ", "keywords": ["cost", "change"]}, {"source": "Body", "text": "In that job (could be a lambda) you can check whether the commit id from each repo matches the commit version from the previous exectuon and then only deploy to the one that was actually changed. ", "keywords": ["change"]}]}], "contains-topic": true, "filtered-sentences": [{"source": "Body", "text": "the problem i am facing is that code change in one of repo triggers every action to start full pipeline that results in new deployment of every microservice. ", "keywords": ["change"]}, {"source": "Body", "text": "when code changes in Source-dmthen only source-dm of Source Stage and DM-Build should run and deployment just happens only in DM microservice. ", "keywords": ["change"]}]}