{"Id": "63621979", "PostTypeId": "1", "AcceptedAnswerId": "63649275", "CreationDate": "2020-08-27T18:14:31.363", "Score": "5", "ViewCount": "3846", "Body": "<p>We want to build an ECS cluster with the following characteristics:</p>\n<ol>\n<li>It must run inside a VPC, then, we need the awsvpc mode</li>\n<li>It must use GPU instances, so we can't use Fargate</li>\n<li>It must provision dynamically the instances, therefore, we need a capacity provider</li>\n<li>It will run tasks (batch jobs) that are going to be triggered directly through the AWS ECS API. For this reason, we don't need a service, only a task definition.</li>\n<li>These tasks must have access to S3 (internet), so according to AWS documentation the instances must be placed inside a private subnet (<a href=\"https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking.html\" rel=\"nofollow noreferrer\">a reference to docs</a>).</li>\n</ol>\n<p>We've already read <a href=\"https://stackoverflow.com/questions/55575476/ecs-cluster-cannot-run-tasks-in-private-subnet-when-using-ec2\">this post</a> in stackoverflow where it says that we need to set up a private subnet with a route table that points to a NAT Gateway configured in a public subnet, and this public subnet should point to an internet gateway. We already have this configuration. We also have an S3 vpc endpoint configured in the route table.</p>\n<p>Bellow, you can see some relevant configurations of the cluster in terraform (for the shake of simplicity I only put the relevant parts):</p>\n<pre><code>\n# Launch template\nresource &quot;aws_launch_template&quot; &quot;train-launch-template&quot; {\n  name_prefix   = &quot;{var.project_name}-launch-template-${var.env}&quot;\n  image_id      = &quot;ami-01f62a207c1d180d2&quot;\n  instance_type = &quot;m5.large&quot;\n  key_name=&quot;XXXXXX&quot;\n  iam_instance_profile {\n    name = aws_iam_instance_profile.ecs-instance-profile.name\n  }\n  user_data = base64encode(data.template_file.user_data.rendered)\n\n  network_interfaces {\n    associate_public_ip_address = false\n    security_groups = [aws_security_group.ecs_service.id]\n  }\n}\n\n\n# Task definition\nresource &quot;aws_ecs_task_definition&quot; &quot;task&quot; {\n  family                   = &quot;${var.project_name}-${var.env}-train-task&quot;\n  execution_role_arn       = data.aws_iam_role.ecs_task_execution_role.arn\n  task_role_arn            = aws_iam_role.ecs_train_task_role.arn\n  requires_compatibilities = [&quot;EC2&quot;]\n  cpu                      = var.ecs_cpu\n  network_mode             = &quot;awsvpc&quot;\n  memory                   = var.ecs_memory\n  container_definitions    = data.template_file.app_definition.rendered\n\n  tags = {\n    Stage   = var.env_tag\n    Project = var.project_name_tag\n  }\n}\n\n\n# Cluster\nresource &quot;aws_ecs_cluster&quot; &quot;cluster&quot; {\n  name = &quot;${var.project_name}-${var.env}-train-ecs-cluster&quot;\n  capacity_providers = [aws_ecs_capacity_provider.train-capacity-provider.name]\n  default_capacity_provider_strategy {\n    capacity_provider = aws_ecs_capacity_provider.train-capacity-provider.name\n  }\n  tags = {\n    Project = var.project_name_tag\n    Stage   = var.env_tag\n  }\n}\n</code></pre>\n<p>We also have configured all the roles needed for the instances and the task to access to the required resources (S3, ECR, ECS).</p>\n<p>The AMI corresponds to an ECS optimized instance (the last version published at this moment in eu-west-1).</p>\n<p>In the launch template we've removed the public IP to the instances due to the explanation in <a href=\"https://aws.amazon.com/es/premiumsupport/knowledge-center/ecs-pull-container-api-error-ecr/\" rel=\"nofollow noreferrer\">this link</a></p>\n<p>We've evolved to this configuration trying to make this work, but once and again we've faced the same problem: when the task is triggered, the capacity provider launches an instance, but the task is never placed in the container instance and remains in the PROVISIONING status indefinitely.</p>\n<p>With the same configuration but placing the instances into a public subnet, the tasks are placed into the container instances, but, as warned in <a href=\"https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking.html\" rel=\"nofollow noreferrer\">the first link</a>, the task has no access to the internet.</p>\n<p>We need some enlightenment or a trace to follow. Thank you in advance.</p>\n<p>UPDATE: As requested I've added the rest part concerning to autoscale</p>\n<pre><code>resource &quot;aws_autoscaling_group&quot; &quot;train-autoscaling&quot; {\n  availability_zones = [&quot;eu-west-1b&quot;]\n  desired_capacity   = 0\n  max_size           = 10\n  min_size           = 0\n  protect_from_scale_in = true\n  \n\n  launch_template {\n    id      = aws_launch_template.train-launch-template.id\n    version = &quot;$Latest&quot;\n  }\n\n  tags = [\n    {\n      key = &quot;Project&quot;,\n      value = var.project_name_tag\n      propagate_at_launch = true\n    },\n    {\n      key = &quot;Stage&quot;,\n      value = var.env_tag\n      propagate_at_launch = true\n    }\n  ]\n}\n\nresource &quot;aws_ecs_capacity_provider&quot; &quot;train-capacity-provider&quot; {\n  name = &quot;${var.project_name}-${var.env}-train-capacity-provider&quot;\n\n  auto_scaling_group_provider {\n    auto_scaling_group_arn         = aws_autoscaling_group.train-autoscaling.arn\n    managed_termination_protection = &quot;ENABLED&quot;\n\n    managed_scaling {\n      status                    = &quot;ENABLED&quot;\n      target_capacity           = 100\n      maximum_scaling_step_size = 1\n      minimum_scaling_step_size = 1\n    }\n  }\n}\n\ndata &quot;template_file&quot; &quot;user_data&quot; {\n  template = &quot;${file(&quot;${path.module}/user_data.sh&quot;)}&quot;\n\n  vars = {\n    cluster_name = &quot;${var.project_name}-${var.env}-train-ecs-cluster&quot;\n  }\n}\n</code></pre>\n<p>Update 2 (AWS Console info):</p>\n<p>Container instances running\n<a href=\"https://i.stack.imgur.com/YoqW1.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/YoqW1.png\" alt=\"Container instances running\" /></a></p>\n<p>Detail container instance:\n<a href=\"https://i.stack.imgur.com/hieCy.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/hieCy.png\" alt=\"enter image description here\" /></a></p>\n<p>Pending Task:\n<a href=\"https://i.stack.imgur.com/kYHaj.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/kYHaj.png\" alt=\"pending task\" /></a></p>\n<p>Pending task details:\n<a href=\"https://i.stack.imgur.com/weEeq.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/weEeq.png\" alt=\"pending task details\" /></a></p>\n<p>Update 3:</p>\n<p>After 30 minutes the task stops and this is the message shown (Task failed to start):\n<a href=\"https://i.stack.imgur.com/A54J0.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/A54J0.png\" alt=\"enter image description here\" /></a></p>\n<p>Update 4:</p>\n<p>logs from container instance.\necs-agent.log</p>\n<pre><code>level=info time=2020-08-28T11:09:21Z msg=&quot;Loading configuration&quot; module=agent.go\nlevel=info time=2020-08-28T11:09:21Z msg=&quot;Amazon ECS agent Version: 1.44.1, Commit: 1f05fbf0&quot; module=agent.go\nlevel=info time=2020-08-28T11:09:21Z msg=&quot;Image excluded from cleanup: amazon/amazon-ecs-pause:0.1.0&quot; module=docker_image_manager.go\nlevel=info time=2020-08-28T11:09:21Z msg=&quot;Image excluded from cleanup: amazon/amazon-ecs-pause:0.1.0&quot; module=docker_image_manager.go\nlevel=info time=2020-08-28T11:09:21Z msg=&quot;Image excluded from cleanup: amazon/amazon-ecs-agent:latest&quot; module=docker_image_manager.go\nlevel=info time=2020-08-28T11:09:21Z msg=&quot;Creating root ecs cgroup: /ecs&quot; module=init_linux.go\nlevel=info time=2020-08-28T11:09:21Z msg=&quot;Creating cgroup /ecs&quot; module=cgroup_controller_linux.go\nlevel=info time=2020-08-28T11:09:21Z msg=&quot;Event stream ContainerChange start listening...&quot; module=eventstream.go\nlevel=info time=2020-08-28T11:09:21Z msg=&quot;Loading state!&quot; module=state_manager.go\nlevel=info time=2020-08-28T11:09:23Z msg=&quot;Registering Instance with ECS&quot; module=agent.go\nlevel=info time=2020-08-28T11:09:23Z msg=&quot;Remaining mem: 7680&quot; module=client.go\nlevel=info time=2020-08-28T11:09:23Z msg=&quot;Registered container instance with cluster!&quot; module=client.go\nlevel=info time=2020-08-28T11:09:23Z msg=&quot;Registration completed successfully. I am running as 'arn:aws:ecs:eu-west-1:XXXXXXXXXXXXXXXX:container-instance/foqum-read-dev-train-ecs-cluster/95559f936f8d44de9373595009fcd588' in cluster 'foqum-read-dev-train-ecs-cluster'&quot; module=agent.go\nlevel=info time=2020-08-28T11:09:23Z msg=&quot;Beginning Polling for updates&quot; module=agent.go\nlevel=info time=2020-08-28T11:09:23Z msg=&quot;Initializing stats engine&quot; module=engine.go\nlevel=info time=2020-08-28T11:09:23Z msg=&quot;Event stream DeregisterContainerInstance start listening...&quot; module=eventstream.go\nlevel=info time=2020-08-28T11:09:23Z msg=&quot;Establishing a Websocket connection to https://ecs-t-X.eu-west-1.amazonaws.com/ws?agentHash=1f05fbf0&amp;agentVersion=1.44.1&amp;cluster=XXXXXXXXX-cluster&amp;containerInstance=arn%3Aaws%3Aecs%3Aeu-west-1%3AXXXXXXXX%3Acontainer-instance%2FXXXXXXXX-cluster%2F95559fXXXXXXde9373595009fcd588&amp;dockerVersion=19.03.6-ce&quot; module=client.go\nlevel=info time=2020-08-28T11:09:23Z msg=&quot;NO_PROXY set:XXX.254.169.XXXX,XXXX.254.XXX.2,/var/run/docker.sock&quot; module=client.go\nlevel=info time=2020-08-28T11:09:23Z msg=&quot;Establishing a Websocket connection to https://ecs-a-X.eu-west-1.amazonaws.com/ws?agentHash=1f05fbf0&amp;agentVersion=1.44.1&amp;clusterArn=XXXXX-ecs-cluster&amp;containerInstanceArn=arn%3Aaws%3Aecs%3Aeu-west-1%XXXXXX%3Acontainer-instance%2FXXXXX-ecs-cluster%2F9XXXXX6f8d44de9373595009fcd588&amp;dockerVersion=DockerVersion%3A+19.03.6-ce&amp;sendCredentials=true&amp;seqNum=1&quot; module=client.go\nlevel=info time=2020-08-28T11:09:23Z msg=&quot;Connected to TCS endpoint&quot; module=handler.go\nlevel=info time=2020-08-28T11:09:23Z msg=&quot;Connected to ACS endpoint&quot; module=acs_handler.go\nlevel=info time=2020-08-28T11:20:04Z msg=&quot;TCS Websocket connection closed for a valid reason&quot; module=handler.go\nlevel=info time=2020-08-28T11:20:04Z msg=&quot;Establishing a Websocket connection to https://ecs-t-X.eu-west-1.amazonaws.com/ws?agentHash=1f05fbf0&amp;agentVersion=1.44.1&amp;cluster=XXXXXXXecs-cluster&amp;containerInstance=arn%3Aaws%3Aecs%3Aeu-west-1%3AXXXXXX3Acontainer-instance%2FZZZXXXXX-ecs-cluster%2F95XXX936f8d44de9373595009fcd588&amp;dockerVersion=19.03.6-ce&quot; module=client.go\nlevel=info time=2020-08-28T11:20:04Z msg=&quot;Connected to TCS endpoint&quot; module=handler.go\n</code></pre>\n<p>ecs-init.log</p>\n<pre><code>2020-08-28T11:09:19Z [INFO] pre-start\n2020-08-28T11:09:20Z [INFO] start\n2020-08-28T11:09:20Z [INFO] No existing agent container to remove.\n2020-08-28T11:09:20Z [INFO] Starting Amazon Elastic Container Service Agent\n</code></pre>\n", "OwnerUserId": "7357621", "LastEditorUserId": "7357621", "LastEditDate": "2020-08-28T11:35:37.713", "LastActivityDate": "2020-08-29T16:25:14.950", "Title": "Running ECS task in a cluster within a private subnet remains in provisioning status", "Tags": "<amazon-web-services><amazon-s3><terraform><amazon-ecs>", "AnswerCount": "1", "CommentCount": "13", "FavoriteCount": "0", "ContentLicense": "CC BY-SA 4.0", "comments": [{"Id": "112505246", "PostId": "63621979", "Score": "0", "Text": "What are you doing with the launch template? You seem to be missing an autoscaling group resource.", "CreationDate": "2020-08-27T19:06:15.160", "UserId": "1032785", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "112505673", "PostId": "63621979", "Score": "0", "Text": "@jordanm I've added the part of autoscaling to the information", "CreationDate": "2020-08-27T19:22:13.167", "UserId": "7357621", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "112505780", "PostId": "63621979", "Score": "0", "Text": "Does the ECS UI show the cluster has members? On the pending task page, if you expand the container details, does it show any errors? Have you inspected the ECS logs on the cluster instances?", "CreationDate": "2020-08-27T19:26:43.857", "UserId": "1032785", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "Does the ECS UI show the cluster has members? ", "keywords": ["cluster"]}, {"source": "Text", "text": "Have you inspected the ECS logs on the cluster instances?", "keywords": ["cluster"]}]}, {"Id": "112506323", "PostId": "63621979", "Score": "0", "Text": "@jordanm I've added screenshots of the container instances and task information shown in the console. Regarding the ECS logs in the cluster instances, pardon my ignorance, but where can I see these logs? Do I have to access the instances through ssh?", "CreationDate": "2020-08-27T19:49:12.817", "UserId": "7357621", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "Regarding the ECS logs in the cluster instances, pardon my ignorance, but where can I see these logs? ", "keywords": ["cluster"]}]}, {"Id": "112506475", "PostId": "63621979", "Score": "1", "Text": "Yeah, you have to access the logs through SSH. I have worked with ECS a lot and nothing you have shown stands out as being wrong. I would recommend contacting AWS support.", "CreationDate": "2020-08-27T19:57:03.447", "UserId": "1032785", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "112506507", "PostId": "63621979", "Score": "0", "Text": "Last thing I can maybe think is if your set CPU and memory higher than can fit on a single node, but from my experience that makes it sit in a PENDING status, not PROVISIONING.", "CreationDate": "2020-08-27T19:58:13.863", "UserId": "1032785", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "Last thing I can maybe think is if your set CPU and memory higher than can fit on a single node, but from my experience that makes it sit in a PENDING status, not PROVISIONING.", "keywords": ["cpu"]}]}, {"Id": "112509787", "PostId": "63621979", "Score": "0", "Text": "Can you clarify. You are using `awsvpc` netwrok mode, without internet access?", "CreationDate": "2020-08-27T22:51:21.930", "UserId": "248823", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "netwrok mode, without internet access?", "keywords": ["billing mode"]}]}, {"Id": "112517410", "PostId": "63621979", "Score": "0", "Text": "@Marcin, I don't know if I completely understand your question. But, to clarify, we are using `awsvpc` mode because we need the instances launched to be inside a VPC. This VPC has three subnets (one private and two public), the public ones have a route table pointing to an internet gateway, while the private has another route table pointing to a nat gateway configure in the public, so, yes, the VPC has internet access. We need to launch the instances in the private network due to this AWS requirement https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking.html", "CreationDate": "2020-08-28T07:41:49.387", "UserId": "7357621", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "But, to clarify, we are using `awsvpc` mode because we need the instances launched to be inside a VPC. ", "keywords": ["billing mode"]}, {"source": "Text", "text": "This VPC has three subnets (one private and two public), the public ones have a route table pointing to an internet gateway, while the private has another route table pointing to a nat gateway configure in the public, so, yes, the VPC has internet access. ", "keywords": ["nat"]}, {"source": "Text", "text": "We need to launch the instances in the private network due to this AWS requirement https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking.html", "keywords": ["networking"]}]}, {"Id": "112518518", "PostId": "63621979", "Score": "0", "Text": "You don't need `awsvpc` mode to be able to use the tasks inside a VPC. `awsvpc` creates a separate ENI for each task, allowing for fine grained security group controls but you can use the default `bridge` networking to use dynamic ports on the host instance (similar to typical Docker bridge networks) or even `host` networking to directly using the host's network interface and static ports. Secondly you say you need GPUs but your instances are `m5.large`? You also don't add a GPU resource requirement to the task definition.", "CreationDate": "2020-08-28T08:29:17.963", "UserId": "2291321", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "You don't need `awsvpc` mode to be able to use the tasks inside a VPC. ", "keywords": ["billing mode"]}, {"source": "Text", "text": "`awsvpc` creates a separate ENI for each task, allowing for fine grained security group controls but you can use the default `bridge` networking to use dynamic ports on the host instance (similar to typical Docker bridge networks) or even `host` networking to directly using the host's network interface and static ports. ", "keywords": ["networking", "instance"]}]}, {"Id": "112518527", "PostId": "63621979", "Score": "0", "Text": "Does the task stay in `PROVISIONING` indefinitely? Or does it eventually fail? If so what does the task status show once it fails? Have you tried running it with different network modes?", "CreationDate": "2020-08-28T08:29:45.653", "UserId": "2291321", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "112518584", "PostId": "63621979", "Score": "0", "Text": "Also can you include the `/etc/ecs/ecs.config` file in your question? You might also need to show how you are starting the ECS agent as well if you're not using an AWS provided ECS AMI (it's hard to tell with you hardcoding the AMI ID instead of using the AMI data source).", "CreationDate": "2020-08-28T08:31:58.137", "UserId": "2291321", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "112519975", "PostId": "63621979", "Score": "0", "Text": "@ydaetskcoR thank you for your comments, I'll try to answer all the questions. First I didn't know that you can place the instances into a VPC in other modes than `awsvpc`, but the fined grained access through a security group is also required. Anyway, I'm going to try to change it to a different mode to see the effect.\n\nRegarding the instance type, I'm using m5.large for debugging purposes, because using GPUs can be expensive.\n\nThe tasks stays in PROVISIONING indefinetely, it does not fail, at least not for a long time, I've usually stopped it after 20 min. I'm going to test it also.", "CreationDate": "2020-08-28T09:26:12.583", "UserId": "7357621", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "Anyway, I'm going to try to change it to a different mode to see the effect. ", "keywords": ["billing mode", "change"]}, {"source": "Text", "text": "Regarding the instance type, I'm using m5.large for debugging purposes, because using GPUs can be expensive. ", "keywords": ["expense", "instance"]}, {"source": "Text", "text": "I'm going to test it also.", "keywords": ["test"]}]}, {"Id": "112520126", "PostId": "63621979", "Score": "0", "Text": "@ydaetskcoR regarding the AMI, it's true that it would be better to use a data source instead of hardcoding, I'll change it, but, as I mentioned in the question, the instance is an ECS Optimized Instance with its agent, but anyway I'm working to connect to the instances via ssh, but it's tricky because I have to make a tunnel through an instance in a public subnet.", "CreationDate": "2020-08-28T09:30:58.170", "UserId": "7357621", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "@ydaetskcoR regarding the AMI, it's true that it would be better to use a data source instead of hardcoding, I'll change it, but, as I mentioned in the question, the instance is an ECS Optimized Instance with its agent, but anyway I'm working to connect to the instances via ssh, but it's tricky because I have to make a tunnel through an instance in a public subnet.", "keywords": ["instance", "change"]}]}], "links": [{"Id": "1772019498", "CreationDate": "2020-08-27T18:14:31.363", "PostId": "63621979", "RelatedPostId": "55575476", "LinkTypeId": "1"}], "history": [{"Id": "229659221", "PostHistoryTypeId": "2", "PostId": "63621979", "RevisionGUID": "4060d6ff-cde2-424f-88d4-f0bc3cf1fdd6", "CreationDate": "2020-08-27T18:14:31.363", "UserId": "7357621", "Text": "We want to build an ECS cluster with the following characteristics:\r\n1. It must run inside a VPC, then, we need the awsvpc mode\r\n2. It must use GPU instances, so we can't use Fargate\r\n3. It must provision dynamically the instances, therefore, we need a capacity provider\r\n4. It will run tasks (batch jobs) that are going to be triggered directly through the AWS ECS API. For this reason, we don't need a service, only a task definition.\r\n5. These tasks must have access to S3 (internet), so according to AWS documentation the instances must be placed inside a private subnet ([a reference to docs][1]).\r\n\r\nWe've already read [this post][2] in stackoverflow where it says that we need to set up a private subnet with a route table that points to a NAT Gateway configured in a public subnet, and this public subnet should point to an internet gateway. We already have this configuration. We also have an S3 vpc endpoint configured in the route table.\r\n\r\nBellow, you can see some relevant configurations of the cluster in terraform (for the shake of simplicity I only put the relevant parts):\r\n\r\n```{terraform}\r\n\r\n# Launch template\r\nresource \"aws_launch_template\" \"train-launch-template\" {\r\n  name_prefix   = \"{var.project_name}-launch-template-${var.env}\"\r\n  image_id      = \"ami-01f62a207c1d180d2\"\r\n  instance_type = \"m5.large\"\r\n  key_name=\"XXXXXX\"\r\n  iam_instance_profile {\r\n    name = aws_iam_instance_profile.ecs-instance-profile.name\r\n  }\r\n  user_data = base64encode(data.template_file.user_data.rendered)\r\n\r\n  network_interfaces {\r\n    associate_public_ip_address = false\r\n    security_groups = [aws_security_group.ecs_service.id]\r\n  }\r\n}\r\n\r\n\r\n# Task definition\r\nresource \"aws_ecs_task_definition\" \"task\" {\r\n  family                   = \"${var.project_name}-${var.env}-train-task\"\r\n  execution_role_arn       = data.aws_iam_role.ecs_task_execution_role.arn\r\n  task_role_arn            = aws_iam_role.ecs_train_task_role.arn\r\n  requires_compatibilities = [\"EC2\"]\r\n  cpu                      = var.ecs_cpu\r\n  network_mode             = \"awsvpc\"\r\n  memory                   = var.ecs_memory\r\n  container_definitions    = data.template_file.app_definition.rendered\r\n\r\n  tags = {\r\n    Stage   = var.env_tag\r\n    Project = var.project_name_tag\r\n  }\r\n}\r\n\r\n\r\n# Cluster\r\nresource \"aws_ecs_cluster\" \"cluster\" {\r\n  name = \"${var.project_name}-${var.env}-train-ecs-cluster\"\r\n  capacity_providers = [aws_ecs_capacity_provider.train-capacity-provider.name]\r\n  default_capacity_provider_strategy {\r\n    capacity_provider = aws_ecs_capacity_provider.train-capacity-provider.name\r\n  }\r\n  tags = {\r\n    Project = var.project_name_tag\r\n    Stage   = var.env_tag\r\n  }\r\n}\r\n```\r\n\r\nWe also have configured all the roles needed for the instances and the task to access to the required resources (S3, ECR, ECS).\r\n\r\nThe AMI corresponds to an ECS optimized instance (the last version published at this moment in eu-west-1).\r\n\r\nIn the launch template we've removed the public IP to the instances due to the explanation in [this link][3]\r\n\r\nWe've evolved to this configuration trying to make this work, but once and again we've faced the same problem: when the task is triggered, the capacity provider launches an instance, but the task is never placed in the container instance and remains in the PROVISIONING status indefinitely.\r\n\r\nWith the same configuration but placing the instances into a public subnet, the tasks are placed into the container instances, but, as warned in [the first link][1], the task has no access to the internet.\r\n\r\nWe need some enlightenment or a trace to follow. Thank you in advance.\r\n\r\n\r\n  [1]: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking.html\r\n  [2]: https://stackoverflow.com/questions/55575476/ecs-cluster-cannot-run-tasks-in-private-subnet-when-using-ec2\r\n  [3]: https://aws.amazon.com/es/premiumsupport/knowledge-center/ecs-pull-container-api-error-ecr/", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "We want to build an ECS cluster with the following characteristics: 1. ", "keywords": ["cluster"]}, {"source": "Text", "text": "It must run inside a VPC, then, we need the awsvpc mode 2. ", "keywords": ["billing mode"]}, {"source": "Text", "text": "It must provision dynamically the instances, therefore, we need a capacity provider 4. ", "keywords": ["provider"]}, {"source": "Text", "text": "We've already read [this post][2] in stackoverflow where it says that we need to set up a private subnet with a route table that points to a NAT Gateway configured in a public subnet, and this public subnet should point to an internet gateway. ", "keywords": ["nat"]}, {"source": "Text", "text": "Bellow, you can see some relevant configurations of the cluster in terraform (for the shake of simplicity I only put the relevant parts): ```{terraform} # Launch template resource \"aws_launch_template\" \"train-launch-template\" { name_prefix = \"{var.project_name}-launch-template-${var.env}\" image_id = \"ami-01f62a207c1d180d2\" instance_type = \"m5.large\" key_name=\"XXXXXX\" iam_instance_profile { name = aws_iam_instance_profile.ecs-instance-profile.name } user_data = base64encode(data.template_file.user_data.rendered) network_interfaces { associate_public_ip_address = false security_groups = [aws_security_group.ecs_service.id] } } # Task definition resource \"aws_ecs_task_definition\" \"task\" { family = \"${var.project_name}-${var.env}-train-task\" execution_role_arn = data.aws_iam_role.ecs_task_execution_role.arn task_role_arn = aws_iam_role.ecs_train_task_role.arn requires_compatibilities = [\"EC2\"] cpu = var.ecs_cpu network_mode = \"awsvpc\" memory = var.ecs_memory container_definitions = data.template_file.app_definition.rendered tags = { Stage = var.env_tag Project = var.project_name_tag } } # Cluster resource \"aws_ecs_cluster\" \"cluster\" { name = \"${var.project_name}-${var.env}-train-ecs-cluster\" capacity_providers = [aws_ecs_capacity_provider.train-capacity-provider.name] default_capacity_provider_strategy { capacity_provider = aws_ecs_capacity_provider.train-capacity-provider.name } tags = { Project = var.project_name_tag Stage = var.env_tag } } ``` ", "keywords": ["instance", "cpu", "provider", "cluster"]}, {"source": "Text", "text": "The AMI corresponds to an ECS optimized instance (the last version published at this moment in eu-west-1). ", "keywords": ["instance"]}, {"source": "Text", "text": "We've evolved to this configuration trying to make this work, but once and again we've faced the same problem: when the task is triggered, the capacity provider launches an instance, but the task is never placed in the container instance and remains in the PROVISIONING status indefinitely. ", "keywords": ["instance", "provider"]}, {"source": "Text", "text": "Thank you in advance. [1]: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking.html [2]: https://stackoverflow.com/questions/55575476/ecs-cluster-cannot-run-tasks-in-private-subnet-when-using-ec2 [3]: https://aws.amazon.com/es/premiumsupport/knowledge-center/ecs-pull-container-api-error-ecr/", "keywords": ["networking", "cluster"]}]}, {"Id": "229659222", "PostHistoryTypeId": "1", "PostId": "63621979", "RevisionGUID": "4060d6ff-cde2-424f-88d4-f0bc3cf1fdd6", "CreationDate": "2020-08-27T18:14:31.363", "UserId": "7357621", "Text": "Running ECS task in a cluster within a private subnets keeps provisioning", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "Running ECS task in a cluster within a private subnets keeps provisioning", "keywords": ["cluster"]}]}, {"Id": "229659223", "PostHistoryTypeId": "3", "PostId": "63621979", "RevisionGUID": "4060d6ff-cde2-424f-88d4-f0bc3cf1fdd6", "CreationDate": "2020-08-27T18:14:31.363", "UserId": "7357621", "Text": "<amazon-web-services><amazon-s3><terraform><amazon-ecs>", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "229659870", "PostHistoryTypeId": "4", "PostId": "63621979", "RevisionGUID": "3e4d0482-8e40-44df-be20-dc084ad053b9", "CreationDate": "2020-08-27T18:25:23.860", "UserId": "7357621", "Comment": "edited title", "Text": "Running ECS task in a cluster within a private subnet remains in provisioning status", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "Running ECS task in a cluster within a private subnet remains in provisioning status", "keywords": ["cluster"]}]}, {"Id": "229662972", "PostHistoryTypeId": "5", "PostId": "63621979", "RevisionGUID": "d48d2175-5495-4b7b-86d2-b3586c566b39", "CreationDate": "2020-08-27T19:21:10.867", "UserId": "7357621", "Comment": "added 1318 characters in body", "Text": "We want to build an ECS cluster with the following characteristics:\r\n1. It must run inside a VPC, then, we need the awsvpc mode\r\n2. It must use GPU instances, so we can't use Fargate\r\n3. It must provision dynamically the instances, therefore, we need a capacity provider\r\n4. It will run tasks (batch jobs) that are going to be triggered directly through the AWS ECS API. For this reason, we don't need a service, only a task definition.\r\n5. These tasks must have access to S3 (internet), so according to AWS documentation the instances must be placed inside a private subnet ([a reference to docs][1]).\r\n\r\nWe've already read [this post][2] in stackoverflow where it says that we need to set up a private subnet with a route table that points to a NAT Gateway configured in a public subnet, and this public subnet should point to an internet gateway. We already have this configuration. We also have an S3 vpc endpoint configured in the route table.\r\n\r\nBellow, you can see some relevant configurations of the cluster in terraform (for the shake of simplicity I only put the relevant parts):\r\n\r\n```{terraform}\r\n\r\n# Launch template\r\nresource \"aws_launch_template\" \"train-launch-template\" {\r\n  name_prefix   = \"{var.project_name}-launch-template-${var.env}\"\r\n  image_id      = \"ami-01f62a207c1d180d2\"\r\n  instance_type = \"m5.large\"\r\n  key_name=\"XXXXXX\"\r\n  iam_instance_profile {\r\n    name = aws_iam_instance_profile.ecs-instance-profile.name\r\n  }\r\n  user_data = base64encode(data.template_file.user_data.rendered)\r\n\r\n  network_interfaces {\r\n    associate_public_ip_address = false\r\n    security_groups = [aws_security_group.ecs_service.id]\r\n  }\r\n}\r\n\r\n\r\n# Task definition\r\nresource \"aws_ecs_task_definition\" \"task\" {\r\n  family                   = \"${var.project_name}-${var.env}-train-task\"\r\n  execution_role_arn       = data.aws_iam_role.ecs_task_execution_role.arn\r\n  task_role_arn            = aws_iam_role.ecs_train_task_role.arn\r\n  requires_compatibilities = [\"EC2\"]\r\n  cpu                      = var.ecs_cpu\r\n  network_mode             = \"awsvpc\"\r\n  memory                   = var.ecs_memory\r\n  container_definitions    = data.template_file.app_definition.rendered\r\n\r\n  tags = {\r\n    Stage   = var.env_tag\r\n    Project = var.project_name_tag\r\n  }\r\n}\r\n\r\n\r\n# Cluster\r\nresource \"aws_ecs_cluster\" \"cluster\" {\r\n  name = \"${var.project_name}-${var.env}-train-ecs-cluster\"\r\n  capacity_providers = [aws_ecs_capacity_provider.train-capacity-provider.name]\r\n  default_capacity_provider_strategy {\r\n    capacity_provider = aws_ecs_capacity_provider.train-capacity-provider.name\r\n  }\r\n  tags = {\r\n    Project = var.project_name_tag\r\n    Stage   = var.env_tag\r\n  }\r\n}\r\n```\r\n\r\nWe also have configured all the roles needed for the instances and the task to access to the required resources (S3, ECR, ECS).\r\n\r\nThe AMI corresponds to an ECS optimized instance (the last version published at this moment in eu-west-1).\r\n\r\nIn the launch template we've removed the public IP to the instances due to the explanation in [this link][3]\r\n\r\nWe've evolved to this configuration trying to make this work, but once and again we've faced the same problem: when the task is triggered, the capacity provider launches an instance, but the task is never placed in the container instance and remains in the PROVISIONING status indefinitely.\r\n\r\nWith the same configuration but placing the instances into a public subnet, the tasks are placed into the container instances, but, as warned in [the first link][1], the task has no access to the internet.\r\n\r\nWe need some enlightenment or a trace to follow. Thank you in advance.\r\n\r\nUPDATE: As requested I've added the rest part concerning to autoscale\r\n\r\n```\r\nresource \"aws_autoscaling_group\" \"train-autoscaling\" {\r\n  availability_zones = [\"eu-west-1b\"]\r\n  desired_capacity   = 0\r\n  max_size           = 10\r\n  min_size           = 0\r\n  protect_from_scale_in = true\r\n  \r\n\r\n  launch_template {\r\n    id      = aws_launch_template.train-launch-template.id\r\n    version = \"$Latest\"\r\n  }\r\n\r\n  tags = [\r\n    {\r\n      key = \"Project\",\r\n      value = var.project_name_tag\r\n      propagate_at_launch = true\r\n    },\r\n    {\r\n      key = \"Stage\",\r\n      value = var.env_tag\r\n      propagate_at_launch = true\r\n    }\r\n  ]\r\n}\r\n\r\nresource \"aws_ecs_capacity_provider\" \"train-capacity-provider\" {\r\n  name = \"${var.project_name}-${var.env}-train-capacity-provider\"\r\n\r\n  auto_scaling_group_provider {\r\n    auto_scaling_group_arn         = aws_autoscaling_group.train-autoscaling.arn\r\n    managed_termination_protection = \"ENABLED\"\r\n\r\n    managed_scaling {\r\n      status                    = \"ENABLED\"\r\n      target_capacity           = 100\r\n      maximum_scaling_step_size = 1\r\n      minimum_scaling_step_size = 1\r\n    }\r\n  }\r\n}\r\n\r\ndata \"template_file\" \"user_data\" {\r\n  template = \"${file(\"${path.module}/user_data.sh\")}\"\r\n\r\n  vars = {\r\n    cluster_name = \"${var.project_name}-${var.env}-train-ecs-cluster\"\r\n  }\r\n}\r\n```\r\n\r\n  [1]: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking.html\r\n  [2]: https://stackoverflow.com/questions/55575476/ecs-cluster-cannot-run-tasks-in-private-subnet-when-using-ec2\r\n  [3]: https://aws.amazon.com/es/premiumsupport/knowledge-center/ecs-pull-container-api-error-ecr/", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "We want to build an ECS cluster with the following characteristics: 1. ", "keywords": ["cluster"]}, {"source": "Text", "text": "It must run inside a VPC, then, we need the awsvpc mode 2. ", "keywords": ["billing mode"]}, {"source": "Text", "text": "It must provision dynamically the instances, therefore, we need a capacity provider 4. ", "keywords": ["provider"]}, {"source": "Text", "text": "We've already read [this post][2] in stackoverflow where it says that we need to set up a private subnet with a route table that points to a NAT Gateway configured in a public subnet, and this public subnet should point to an internet gateway. ", "keywords": ["nat"]}, {"source": "Text", "text": "Bellow, you can see some relevant configurations of the cluster in terraform (for the shake of simplicity I only put the relevant parts): ```{terraform} # Launch template resource \"aws_launch_template\" \"train-launch-template\" { name_prefix = \"{var.project_name}-launch-template-${var.env}\" image_id = \"ami-01f62a207c1d180d2\" instance_type = \"m5.large\" key_name=\"XXXXXX\" iam_instance_profile { name = aws_iam_instance_profile.ecs-instance-profile.name } user_data = base64encode(data.template_file.user_data.rendered) network_interfaces { associate_public_ip_address = false security_groups = [aws_security_group.ecs_service.id] } } # Task definition resource \"aws_ecs_task_definition\" \"task\" { family = \"${var.project_name}-${var.env}-train-task\" execution_role_arn = data.aws_iam_role.ecs_task_execution_role.arn task_role_arn = aws_iam_role.ecs_train_task_role.arn requires_compatibilities = [\"EC2\"] cpu = var.ecs_cpu network_mode = \"awsvpc\" memory = var.ecs_memory container_definitions = data.template_file.app_definition.rendered tags = { Stage = var.env_tag Project = var.project_name_tag } } # Cluster resource \"aws_ecs_cluster\" \"cluster\" { name = \"${var.project_name}-${var.env}-train-ecs-cluster\" capacity_providers = [aws_ecs_capacity_provider.train-capacity-provider.name] default_capacity_provider_strategy { capacity_provider = aws_ecs_capacity_provider.train-capacity-provider.name } tags = { Project = var.project_name_tag Stage = var.env_tag } } ``` ", "keywords": ["instance", "cpu", "provider", "cluster"]}, {"source": "Text", "text": "The AMI corresponds to an ECS optimized instance (the last version published at this moment in eu-west-1). ", "keywords": ["instance"]}, {"source": "Text", "text": "We've evolved to this configuration trying to make this work, but once and again we've faced the same problem: when the task is triggered, the capacity provider launches an instance, but the task is never placed in the container instance and remains in the PROVISIONING status indefinitely. ", "keywords": ["instance", "provider"]}, {"source": "Text", "text": "UPDATE: As requested I've added the rest part concerning to autoscale ``` resource \"aws_autoscaling_group\" \"train-autoscaling\" { availability_zones = [\"eu-west-1b\"] desired_capacity = 0 max_size = 10 min_size = 0 protect_from_scale_in = true launch_template { id = aws_launch_template.train-launch-template.id version = \"$Latest\" } tags = [ { key = \"Project\", value = var.project_name_tag propagate_at_launch = true }, { key = \"Stage\", value = var.env_tag propagate_at_launch = true } ] } resource \"aws_ecs_capacity_provider\" \"train-capacity-provider\" { name = \"${var.project_name}-${var.env}-train-capacity-provider\" auto_scaling_group_provider { auto_scaling_group_arn = aws_autoscaling_group.train-autoscaling.arn managed_termination_protection = \"ENABLED\" managed_scaling { status = \"ENABLED\" target_capacity = 100 maximum_scaling_step_size = 1 minimum_scaling_step_size = 1 } } } data \"template_file\" \"user_data\" { template = \"${file(\"${path.module}/user_data.sh\")}\" vars = { cluster_name = \"${var.project_name}-${var.env}-train-ecs-cluster\" } } ``` [1]: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking.html [2]: https://stackoverflow.com/questions/55575476/ecs-cluster-cannot-run-tasks-in-private-subnet-when-using-ec2 [3]: https://aws.amazon.com/es/premiumsupport/knowledge-center/ecs-pull-container-api-error-ecr/", "keywords": ["networking", "provider", "cluster"]}]}, {"Id": "229664322", "PostHistoryTypeId": "5", "PostId": "63621979", "RevisionGUID": "344f4e76-7322-496a-bfc2-05242c538127", "CreationDate": "2020-08-27T19:47:13.297", "UserId": "7357621", "Comment": "added 452 characters in body", "Text": "We want to build an ECS cluster with the following characteristics:\r\n1. It must run inside a VPC, then, we need the awsvpc mode\r\n2. It must use GPU instances, so we can't use Fargate\r\n3. It must provision dynamically the instances, therefore, we need a capacity provider\r\n4. It will run tasks (batch jobs) that are going to be triggered directly through the AWS ECS API. For this reason, we don't need a service, only a task definition.\r\n5. These tasks must have access to S3 (internet), so according to AWS documentation the instances must be placed inside a private subnet ([a reference to docs][1]).\r\n\r\nWe've already read [this post][2] in stackoverflow where it says that we need to set up a private subnet with a route table that points to a NAT Gateway configured in a public subnet, and this public subnet should point to an internet gateway. We already have this configuration. We also have an S3 vpc endpoint configured in the route table.\r\n\r\nBellow, you can see some relevant configurations of the cluster in terraform (for the shake of simplicity I only put the relevant parts):\r\n\r\n```{terraform}\r\n\r\n# Launch template\r\nresource \"aws_launch_template\" \"train-launch-template\" {\r\n  name_prefix   = \"{var.project_name}-launch-template-${var.env}\"\r\n  image_id      = \"ami-01f62a207c1d180d2\"\r\n  instance_type = \"m5.large\"\r\n  key_name=\"XXXXXX\"\r\n  iam_instance_profile {\r\n    name = aws_iam_instance_profile.ecs-instance-profile.name\r\n  }\r\n  user_data = base64encode(data.template_file.user_data.rendered)\r\n\r\n  network_interfaces {\r\n    associate_public_ip_address = false\r\n    security_groups = [aws_security_group.ecs_service.id]\r\n  }\r\n}\r\n\r\n\r\n# Task definition\r\nresource \"aws_ecs_task_definition\" \"task\" {\r\n  family                   = \"${var.project_name}-${var.env}-train-task\"\r\n  execution_role_arn       = data.aws_iam_role.ecs_task_execution_role.arn\r\n  task_role_arn            = aws_iam_role.ecs_train_task_role.arn\r\n  requires_compatibilities = [\"EC2\"]\r\n  cpu                      = var.ecs_cpu\r\n  network_mode             = \"awsvpc\"\r\n  memory                   = var.ecs_memory\r\n  container_definitions    = data.template_file.app_definition.rendered\r\n\r\n  tags = {\r\n    Stage   = var.env_tag\r\n    Project = var.project_name_tag\r\n  }\r\n}\r\n\r\n\r\n# Cluster\r\nresource \"aws_ecs_cluster\" \"cluster\" {\r\n  name = \"${var.project_name}-${var.env}-train-ecs-cluster\"\r\n  capacity_providers = [aws_ecs_capacity_provider.train-capacity-provider.name]\r\n  default_capacity_provider_strategy {\r\n    capacity_provider = aws_ecs_capacity_provider.train-capacity-provider.name\r\n  }\r\n  tags = {\r\n    Project = var.project_name_tag\r\n    Stage   = var.env_tag\r\n  }\r\n}\r\n```\r\n\r\nWe also have configured all the roles needed for the instances and the task to access to the required resources (S3, ECR, ECS).\r\n\r\nThe AMI corresponds to an ECS optimized instance (the last version published at this moment in eu-west-1).\r\n\r\nIn the launch template we've removed the public IP to the instances due to the explanation in [this link][3]\r\n\r\nWe've evolved to this configuration trying to make this work, but once and again we've faced the same problem: when the task is triggered, the capacity provider launches an instance, but the task is never placed in the container instance and remains in the PROVISIONING status indefinitely.\r\n\r\nWith the same configuration but placing the instances into a public subnet, the tasks are placed into the container instances, but, as warned in [the first link][1], the task has no access to the internet.\r\n\r\nWe need some enlightenment or a trace to follow. Thank you in advance.\r\n\r\nUPDATE: As requested I've added the rest part concerning to autoscale\r\n\r\n```\r\nresource \"aws_autoscaling_group\" \"train-autoscaling\" {\r\n  availability_zones = [\"eu-west-1b\"]\r\n  desired_capacity   = 0\r\n  max_size           = 10\r\n  min_size           = 0\r\n  protect_from_scale_in = true\r\n  \r\n\r\n  launch_template {\r\n    id      = aws_launch_template.train-launch-template.id\r\n    version = \"$Latest\"\r\n  }\r\n\r\n  tags = [\r\n    {\r\n      key = \"Project\",\r\n      value = var.project_name_tag\r\n      propagate_at_launch = true\r\n    },\r\n    {\r\n      key = \"Stage\",\r\n      value = var.env_tag\r\n      propagate_at_launch = true\r\n    }\r\n  ]\r\n}\r\n\r\nresource \"aws_ecs_capacity_provider\" \"train-capacity-provider\" {\r\n  name = \"${var.project_name}-${var.env}-train-capacity-provider\"\r\n\r\n  auto_scaling_group_provider {\r\n    auto_scaling_group_arn         = aws_autoscaling_group.train-autoscaling.arn\r\n    managed_termination_protection = \"ENABLED\"\r\n\r\n    managed_scaling {\r\n      status                    = \"ENABLED\"\r\n      target_capacity           = 100\r\n      maximum_scaling_step_size = 1\r\n      minimum_scaling_step_size = 1\r\n    }\r\n  }\r\n}\r\n\r\ndata \"template_file\" \"user_data\" {\r\n  template = \"${file(\"${path.module}/user_data.sh\")}\"\r\n\r\n  vars = {\r\n    cluster_name = \"${var.project_name}-${var.env}-train-ecs-cluster\"\r\n  }\r\n}\r\n```\r\n\r\nUpdate 2 (AWS Console info):\r\n\r\nContainer instances running\r\n[![Container instances running][4]][4]\r\n\r\nDetail container instance:\r\n[![enter image description here][5]][5]\r\n\r\nPending Task:\r\n[![pending task][6]][6]\r\n\r\nPending task details:\r\n[![pending task details][7]][7]\r\n\r\n\r\n  [1]: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking.html\r\n  [2]: https://stackoverflow.com/questions/55575476/ecs-cluster-cannot-run-tasks-in-private-subnet-when-using-ec2\r\n  [3]: https://aws.amazon.com/es/premiumsupport/knowledge-center/ecs-pull-container-api-error-ecr/\r\n  [4]: https://i.stack.imgur.com/YoqW1.png\r\n  [5]: https://i.stack.imgur.com/hieCy.png\r\n  [6]: https://i.stack.imgur.com/kYHaj.png\r\n  [7]: https://i.stack.imgur.com/weEeq.png", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "We want to build an ECS cluster with the following characteristics: 1. ", "keywords": ["cluster"]}, {"source": "Text", "text": "It must run inside a VPC, then, we need the awsvpc mode 2. ", "keywords": ["billing mode"]}, {"source": "Text", "text": "It must provision dynamically the instances, therefore, we need a capacity provider 4. ", "keywords": ["provider"]}, {"source": "Text", "text": "We've already read [this post][2] in stackoverflow where it says that we need to set up a private subnet with a route table that points to a NAT Gateway configured in a public subnet, and this public subnet should point to an internet gateway. ", "keywords": ["nat"]}, {"source": "Text", "text": "Bellow, you can see some relevant configurations of the cluster in terraform (for the shake of simplicity I only put the relevant parts): ```{terraform} # Launch template resource \"aws_launch_template\" \"train-launch-template\" { name_prefix = \"{var.project_name}-launch-template-${var.env}\" image_id = \"ami-01f62a207c1d180d2\" instance_type = \"m5.large\" key_name=\"XXXXXX\" iam_instance_profile { name = aws_iam_instance_profile.ecs-instance-profile.name } user_data = base64encode(data.template_file.user_data.rendered) network_interfaces { associate_public_ip_address = false security_groups = [aws_security_group.ecs_service.id] } } # Task definition resource \"aws_ecs_task_definition\" \"task\" { family = \"${var.project_name}-${var.env}-train-task\" execution_role_arn = data.aws_iam_role.ecs_task_execution_role.arn task_role_arn = aws_iam_role.ecs_train_task_role.arn requires_compatibilities = [\"EC2\"] cpu = var.ecs_cpu network_mode = \"awsvpc\" memory = var.ecs_memory container_definitions = data.template_file.app_definition.rendered tags = { Stage = var.env_tag Project = var.project_name_tag } } # Cluster resource \"aws_ecs_cluster\" \"cluster\" { name = \"${var.project_name}-${var.env}-train-ecs-cluster\" capacity_providers = [aws_ecs_capacity_provider.train-capacity-provider.name] default_capacity_provider_strategy { capacity_provider = aws_ecs_capacity_provider.train-capacity-provider.name } tags = { Project = var.project_name_tag Stage = var.env_tag } } ``` ", "keywords": ["instance", "cpu", "provider", "cluster"]}, {"source": "Text", "text": "The AMI corresponds to an ECS optimized instance (the last version published at this moment in eu-west-1). ", "keywords": ["instance"]}, {"source": "Text", "text": "We've evolved to this configuration trying to make this work, but once and again we've faced the same problem: when the task is triggered, the capacity provider launches an instance, but the task is never placed in the container instance and remains in the PROVISIONING status indefinitely. ", "keywords": ["instance", "provider"]}, {"source": "Text", "text": "UPDATE: As requested I've added the rest part concerning to autoscale ``` resource \"aws_autoscaling_group\" \"train-autoscaling\" { availability_zones = [\"eu-west-1b\"] desired_capacity = 0 max_size = 10 min_size = 0 protect_from_scale_in = true launch_template { id = aws_launch_template.train-launch-template.id version = \"$Latest\" } tags = [ { key = \"Project\", value = var.project_name_tag propagate_at_launch = true }, { key = \"Stage\", value = var.env_tag propagate_at_launch = true } ] } resource \"aws_ecs_capacity_provider\" \"train-capacity-provider\" { name = \"${var.project_name}-${var.env}-train-capacity-provider\" auto_scaling_group_provider { auto_scaling_group_arn = aws_autoscaling_group.train-autoscaling.arn managed_termination_protection = \"ENABLED\" managed_scaling { status = \"ENABLED\" target_capacity = 100 maximum_scaling_step_size = 1 minimum_scaling_step_size = 1 } } } data \"template_file\" \"user_data\" { template = \"${file(\"${path.module}/user_data.sh\")}\" vars = { cluster_name = \"${var.project_name}-${var.env}-train-ecs-cluster\" } } ``` ", "keywords": ["provider", "cluster"]}, {"source": "Text", "text": "Update 2 (AWS Console info): Container instances running [![Container instances running][4]][4] Detail container instance: [![enter image description here][5]][5] Pending Task: [![pending task][6]][6] Pending task details: [![pending task details][7]][7] [1]: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking.html [2]: https://stackoverflow.com/questions/55575476/ecs-cluster-cannot-run-tasks-in-private-subnet-when-using-ec2 [3]: https://aws.amazon.com/es/premiumsupport/knowledge-center/ecs-pull-container-api-error-ecr/ [4]: https://i.stack.imgur.com/YoqW1.png [5]: https://i.stack.imgur.com/hieCy.png [6]: https://i.stack.imgur.com/kYHaj.png [7]: https://i.stack.imgur.com/weEeq.png", "keywords": ["networking", "instance", "cluster"]}]}, {"Id": "229700166", "PostHistoryTypeId": "5", "PostId": "63621979", "RevisionGUID": "9af8328f-2210-45cd-b750-1c3d94b081f4", "CreationDate": "2020-08-28T10:15:05.183", "UserId": "7357621", "Comment": "added 189 characters in body", "Text": "We want to build an ECS cluster with the following characteristics:\r\n1. It must run inside a VPC, then, we need the awsvpc mode\r\n2. It must use GPU instances, so we can't use Fargate\r\n3. It must provision dynamically the instances, therefore, we need a capacity provider\r\n4. It will run tasks (batch jobs) that are going to be triggered directly through the AWS ECS API. For this reason, we don't need a service, only a task definition.\r\n5. These tasks must have access to S3 (internet), so according to AWS documentation the instances must be placed inside a private subnet ([a reference to docs][1]).\r\n\r\nWe've already read [this post][2] in stackoverflow where it says that we need to set up a private subnet with a route table that points to a NAT Gateway configured in a public subnet, and this public subnet should point to an internet gateway. We already have this configuration. We also have an S3 vpc endpoint configured in the route table.\r\n\r\nBellow, you can see some relevant configurations of the cluster in terraform (for the shake of simplicity I only put the relevant parts):\r\n\r\n```{terraform}\r\n\r\n# Launch template\r\nresource \"aws_launch_template\" \"train-launch-template\" {\r\n  name_prefix   = \"{var.project_name}-launch-template-${var.env}\"\r\n  image_id      = \"ami-01f62a207c1d180d2\"\r\n  instance_type = \"m5.large\"\r\n  key_name=\"XXXXXX\"\r\n  iam_instance_profile {\r\n    name = aws_iam_instance_profile.ecs-instance-profile.name\r\n  }\r\n  user_data = base64encode(data.template_file.user_data.rendered)\r\n\r\n  network_interfaces {\r\n    associate_public_ip_address = false\r\n    security_groups = [aws_security_group.ecs_service.id]\r\n  }\r\n}\r\n\r\n\r\n# Task definition\r\nresource \"aws_ecs_task_definition\" \"task\" {\r\n  family                   = \"${var.project_name}-${var.env}-train-task\"\r\n  execution_role_arn       = data.aws_iam_role.ecs_task_execution_role.arn\r\n  task_role_arn            = aws_iam_role.ecs_train_task_role.arn\r\n  requires_compatibilities = [\"EC2\"]\r\n  cpu                      = var.ecs_cpu\r\n  network_mode             = \"awsvpc\"\r\n  memory                   = var.ecs_memory\r\n  container_definitions    = data.template_file.app_definition.rendered\r\n\r\n  tags = {\r\n    Stage   = var.env_tag\r\n    Project = var.project_name_tag\r\n  }\r\n}\r\n\r\n\r\n# Cluster\r\nresource \"aws_ecs_cluster\" \"cluster\" {\r\n  name = \"${var.project_name}-${var.env}-train-ecs-cluster\"\r\n  capacity_providers = [aws_ecs_capacity_provider.train-capacity-provider.name]\r\n  default_capacity_provider_strategy {\r\n    capacity_provider = aws_ecs_capacity_provider.train-capacity-provider.name\r\n  }\r\n  tags = {\r\n    Project = var.project_name_tag\r\n    Stage   = var.env_tag\r\n  }\r\n}\r\n```\r\n\r\nWe also have configured all the roles needed for the instances and the task to access to the required resources (S3, ECR, ECS).\r\n\r\nThe AMI corresponds to an ECS optimized instance (the last version published at this moment in eu-west-1).\r\n\r\nIn the launch template we've removed the public IP to the instances due to the explanation in [this link][3]\r\n\r\nWe've evolved to this configuration trying to make this work, but once and again we've faced the same problem: when the task is triggered, the capacity provider launches an instance, but the task is never placed in the container instance and remains in the PROVISIONING status indefinitely.\r\n\r\nWith the same configuration but placing the instances into a public subnet, the tasks are placed into the container instances, but, as warned in [the first link][1], the task has no access to the internet.\r\n\r\nWe need some enlightenment or a trace to follow. Thank you in advance.\r\n\r\nUPDATE: As requested I've added the rest part concerning to autoscale\r\n\r\n```\r\nresource \"aws_autoscaling_group\" \"train-autoscaling\" {\r\n  availability_zones = [\"eu-west-1b\"]\r\n  desired_capacity   = 0\r\n  max_size           = 10\r\n  min_size           = 0\r\n  protect_from_scale_in = true\r\n  \r\n\r\n  launch_template {\r\n    id      = aws_launch_template.train-launch-template.id\r\n    version = \"$Latest\"\r\n  }\r\n\r\n  tags = [\r\n    {\r\n      key = \"Project\",\r\n      value = var.project_name_tag\r\n      propagate_at_launch = true\r\n    },\r\n    {\r\n      key = \"Stage\",\r\n      value = var.env_tag\r\n      propagate_at_launch = true\r\n    }\r\n  ]\r\n}\r\n\r\nresource \"aws_ecs_capacity_provider\" \"train-capacity-provider\" {\r\n  name = \"${var.project_name}-${var.env}-train-capacity-provider\"\r\n\r\n  auto_scaling_group_provider {\r\n    auto_scaling_group_arn         = aws_autoscaling_group.train-autoscaling.arn\r\n    managed_termination_protection = \"ENABLED\"\r\n\r\n    managed_scaling {\r\n      status                    = \"ENABLED\"\r\n      target_capacity           = 100\r\n      maximum_scaling_step_size = 1\r\n      minimum_scaling_step_size = 1\r\n    }\r\n  }\r\n}\r\n\r\ndata \"template_file\" \"user_data\" {\r\n  template = \"${file(\"${path.module}/user_data.sh\")}\"\r\n\r\n  vars = {\r\n    cluster_name = \"${var.project_name}-${var.env}-train-ecs-cluster\"\r\n  }\r\n}\r\n```\r\n\r\nUpdate 2 (AWS Console info):\r\n\r\nContainer instances running\r\n[![Container instances running][4]][4]\r\n\r\nDetail container instance:\r\n[![enter image description here][5]][5]\r\n\r\nPending Task:\r\n[![pending task][6]][6]\r\n\r\nPending task details:\r\n[![pending task details][7]][7]\r\n\r\nUpdate 3:\r\n\r\n\r\nAfter 30 minutes the task stops and this is the message shown (Task failed to start):\r\n[![enter image description here][8]][8]\r\n\r\n\r\n  [1]: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking.html\r\n  [2]: https://stackoverflow.com/questions/55575476/ecs-cluster-cannot-run-tasks-in-private-subnet-when-using-ec2\r\n  [3]: https://aws.amazon.com/es/premiumsupport/knowledge-center/ecs-pull-container-api-error-ecr/\r\n  [4]: https://i.stack.imgur.com/YoqW1.png\r\n  [5]: https://i.stack.imgur.com/hieCy.png\r\n  [6]: https://i.stack.imgur.com/kYHaj.png\r\n  [7]: https://i.stack.imgur.com/weEeq.png\r\n  [8]: https://i.stack.imgur.com/A54J0.png", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "We want to build an ECS cluster with the following characteristics: 1. ", "keywords": ["cluster"]}, {"source": "Text", "text": "It must run inside a VPC, then, we need the awsvpc mode 2. ", "keywords": ["billing mode"]}, {"source": "Text", "text": "It must provision dynamically the instances, therefore, we need a capacity provider 4. ", "keywords": ["provider"]}, {"source": "Text", "text": "We've already read [this post][2] in stackoverflow where it says that we need to set up a private subnet with a route table that points to a NAT Gateway configured in a public subnet, and this public subnet should point to an internet gateway. ", "keywords": ["nat"]}, {"source": "Text", "text": "Bellow, you can see some relevant configurations of the cluster in terraform (for the shake of simplicity I only put the relevant parts): ```{terraform} # Launch template resource \"aws_launch_template\" \"train-launch-template\" { name_prefix = \"{var.project_name}-launch-template-${var.env}\" image_id = \"ami-01f62a207c1d180d2\" instance_type = \"m5.large\" key_name=\"XXXXXX\" iam_instance_profile { name = aws_iam_instance_profile.ecs-instance-profile.name } user_data = base64encode(data.template_file.user_data.rendered) network_interfaces { associate_public_ip_address = false security_groups = [aws_security_group.ecs_service.id] } } # Task definition resource \"aws_ecs_task_definition\" \"task\" { family = \"${var.project_name}-${var.env}-train-task\" execution_role_arn = data.aws_iam_role.ecs_task_execution_role.arn task_role_arn = aws_iam_role.ecs_train_task_role.arn requires_compatibilities = [\"EC2\"] cpu = var.ecs_cpu network_mode = \"awsvpc\" memory = var.ecs_memory container_definitions = data.template_file.app_definition.rendered tags = { Stage = var.env_tag Project = var.project_name_tag } } # Cluster resource \"aws_ecs_cluster\" \"cluster\" { name = \"${var.project_name}-${var.env}-train-ecs-cluster\" capacity_providers = [aws_ecs_capacity_provider.train-capacity-provider.name] default_capacity_provider_strategy { capacity_provider = aws_ecs_capacity_provider.train-capacity-provider.name } tags = { Project = var.project_name_tag Stage = var.env_tag } } ``` ", "keywords": ["instance", "cpu", "provider", "cluster"]}, {"source": "Text", "text": "The AMI corresponds to an ECS optimized instance (the last version published at this moment in eu-west-1). ", "keywords": ["instance"]}, {"source": "Text", "text": "We've evolved to this configuration trying to make this work, but once and again we've faced the same problem: when the task is triggered, the capacity provider launches an instance, but the task is never placed in the container instance and remains in the PROVISIONING status indefinitely. ", "keywords": ["instance", "provider"]}, {"source": "Text", "text": "UPDATE: As requested I've added the rest part concerning to autoscale ``` resource \"aws_autoscaling_group\" \"train-autoscaling\" { availability_zones = [\"eu-west-1b\"] desired_capacity = 0 max_size = 10 min_size = 0 protect_from_scale_in = true launch_template { id = aws_launch_template.train-launch-template.id version = \"$Latest\" } tags = [ { key = \"Project\", value = var.project_name_tag propagate_at_launch = true }, { key = \"Stage\", value = var.env_tag propagate_at_launch = true } ] } resource \"aws_ecs_capacity_provider\" \"train-capacity-provider\" { name = \"${var.project_name}-${var.env}-train-capacity-provider\" auto_scaling_group_provider { auto_scaling_group_arn = aws_autoscaling_group.train-autoscaling.arn managed_termination_protection = \"ENABLED\" managed_scaling { status = \"ENABLED\" target_capacity = 100 maximum_scaling_step_size = 1 minimum_scaling_step_size = 1 } } } data \"template_file\" \"user_data\" { template = \"${file(\"${path.module}/user_data.sh\")}\" vars = { cluster_name = \"${var.project_name}-${var.env}-train-ecs-cluster\" } } ``` ", "keywords": ["provider", "cluster"]}, {"source": "Text", "text": "Update 2 (AWS Console info): Container instances running [![Container instances running][4]][4] Detail container instance: [![enter image description here][5]][5] Pending Task: [![pending task][6]][6] Pending task details: [![pending task details][7]][7] Update 3: After 30 minutes the task stops and this is the message shown (Task failed to start): [![enter image description here][8]][8] [1]: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking.html [2]: https://stackoverflow.com/questions/55575476/ecs-cluster-cannot-run-tasks-in-private-subnet-when-using-ec2 [3]: https://aws.amazon.com/es/premiumsupport/knowledge-center/ecs-pull-container-api-error-ecr/ [4]: https://i.stack.imgur.com/YoqW1.png [5]: https://i.stack.imgur.com/hieCy.png [6]: https://i.stack.imgur.com/kYHaj.png [7]: https://i.stack.imgur.com/weEeq.png [8]: https://i.stack.imgur.com/A54J0.png", "keywords": ["networking", "instance", "cluster"]}]}, {"Id": "229705071", "PostHistoryTypeId": "5", "PostId": "63621979", "RevisionGUID": "461c2f2f-bdfa-41b3-ae7d-d6dd593487d8", "CreationDate": "2020-08-28T11:35:37.713", "UserId": "7357621", "Comment": "added 3820 characters in body", "Text": "We want to build an ECS cluster with the following characteristics:\r\n1. It must run inside a VPC, then, we need the awsvpc mode\r\n2. It must use GPU instances, so we can't use Fargate\r\n3. It must provision dynamically the instances, therefore, we need a capacity provider\r\n4. It will run tasks (batch jobs) that are going to be triggered directly through the AWS ECS API. For this reason, we don't need a service, only a task definition.\r\n5. These tasks must have access to S3 (internet), so according to AWS documentation the instances must be placed inside a private subnet ([a reference to docs][1]).\r\n\r\nWe've already read [this post][2] in stackoverflow where it says that we need to set up a private subnet with a route table that points to a NAT Gateway configured in a public subnet, and this public subnet should point to an internet gateway. We already have this configuration. We also have an S3 vpc endpoint configured in the route table.\r\n\r\nBellow, you can see some relevant configurations of the cluster in terraform (for the shake of simplicity I only put the relevant parts):\r\n\r\n```{terraform}\r\n\r\n# Launch template\r\nresource \"aws_launch_template\" \"train-launch-template\" {\r\n  name_prefix   = \"{var.project_name}-launch-template-${var.env}\"\r\n  image_id      = \"ami-01f62a207c1d180d2\"\r\n  instance_type = \"m5.large\"\r\n  key_name=\"XXXXXX\"\r\n  iam_instance_profile {\r\n    name = aws_iam_instance_profile.ecs-instance-profile.name\r\n  }\r\n  user_data = base64encode(data.template_file.user_data.rendered)\r\n\r\n  network_interfaces {\r\n    associate_public_ip_address = false\r\n    security_groups = [aws_security_group.ecs_service.id]\r\n  }\r\n}\r\n\r\n\r\n# Task definition\r\nresource \"aws_ecs_task_definition\" \"task\" {\r\n  family                   = \"${var.project_name}-${var.env}-train-task\"\r\n  execution_role_arn       = data.aws_iam_role.ecs_task_execution_role.arn\r\n  task_role_arn            = aws_iam_role.ecs_train_task_role.arn\r\n  requires_compatibilities = [\"EC2\"]\r\n  cpu                      = var.ecs_cpu\r\n  network_mode             = \"awsvpc\"\r\n  memory                   = var.ecs_memory\r\n  container_definitions    = data.template_file.app_definition.rendered\r\n\r\n  tags = {\r\n    Stage   = var.env_tag\r\n    Project = var.project_name_tag\r\n  }\r\n}\r\n\r\n\r\n# Cluster\r\nresource \"aws_ecs_cluster\" \"cluster\" {\r\n  name = \"${var.project_name}-${var.env}-train-ecs-cluster\"\r\n  capacity_providers = [aws_ecs_capacity_provider.train-capacity-provider.name]\r\n  default_capacity_provider_strategy {\r\n    capacity_provider = aws_ecs_capacity_provider.train-capacity-provider.name\r\n  }\r\n  tags = {\r\n    Project = var.project_name_tag\r\n    Stage   = var.env_tag\r\n  }\r\n}\r\n```\r\n\r\nWe also have configured all the roles needed for the instances and the task to access to the required resources (S3, ECR, ECS).\r\n\r\nThe AMI corresponds to an ECS optimized instance (the last version published at this moment in eu-west-1).\r\n\r\nIn the launch template we've removed the public IP to the instances due to the explanation in [this link][3]\r\n\r\nWe've evolved to this configuration trying to make this work, but once and again we've faced the same problem: when the task is triggered, the capacity provider launches an instance, but the task is never placed in the container instance and remains in the PROVISIONING status indefinitely.\r\n\r\nWith the same configuration but placing the instances into a public subnet, the tasks are placed into the container instances, but, as warned in [the first link][1], the task has no access to the internet.\r\n\r\nWe need some enlightenment or a trace to follow. Thank you in advance.\r\n\r\nUPDATE: As requested I've added the rest part concerning to autoscale\r\n\r\n```\r\nresource \"aws_autoscaling_group\" \"train-autoscaling\" {\r\n  availability_zones = [\"eu-west-1b\"]\r\n  desired_capacity   = 0\r\n  max_size           = 10\r\n  min_size           = 0\r\n  protect_from_scale_in = true\r\n  \r\n\r\n  launch_template {\r\n    id      = aws_launch_template.train-launch-template.id\r\n    version = \"$Latest\"\r\n  }\r\n\r\n  tags = [\r\n    {\r\n      key = \"Project\",\r\n      value = var.project_name_tag\r\n      propagate_at_launch = true\r\n    },\r\n    {\r\n      key = \"Stage\",\r\n      value = var.env_tag\r\n      propagate_at_launch = true\r\n    }\r\n  ]\r\n}\r\n\r\nresource \"aws_ecs_capacity_provider\" \"train-capacity-provider\" {\r\n  name = \"${var.project_name}-${var.env}-train-capacity-provider\"\r\n\r\n  auto_scaling_group_provider {\r\n    auto_scaling_group_arn         = aws_autoscaling_group.train-autoscaling.arn\r\n    managed_termination_protection = \"ENABLED\"\r\n\r\n    managed_scaling {\r\n      status                    = \"ENABLED\"\r\n      target_capacity           = 100\r\n      maximum_scaling_step_size = 1\r\n      minimum_scaling_step_size = 1\r\n    }\r\n  }\r\n}\r\n\r\ndata \"template_file\" \"user_data\" {\r\n  template = \"${file(\"${path.module}/user_data.sh\")}\"\r\n\r\n  vars = {\r\n    cluster_name = \"${var.project_name}-${var.env}-train-ecs-cluster\"\r\n  }\r\n}\r\n```\r\n\r\nUpdate 2 (AWS Console info):\r\n\r\nContainer instances running\r\n[![Container instances running][4]][4]\r\n\r\nDetail container instance:\r\n[![enter image description here][5]][5]\r\n\r\nPending Task:\r\n[![pending task][6]][6]\r\n\r\nPending task details:\r\n[![pending task details][7]][7]\r\n\r\nUpdate 3:\r\n\r\n\r\nAfter 30 minutes the task stops and this is the message shown (Task failed to start):\r\n[![enter image description here][8]][8]\r\n\r\nUpdate 4:\r\n\r\nlogs from container instance.\r\necs-agent.log\r\n\r\n```\r\nlevel=info time=2020-08-28T11:09:21Z msg=\"Loading configuration\" module=agent.go\r\nlevel=info time=2020-08-28T11:09:21Z msg=\"Amazon ECS agent Version: 1.44.1, Commit: 1f05fbf0\" module=agent.go\r\nlevel=info time=2020-08-28T11:09:21Z msg=\"Image excluded from cleanup: amazon/amazon-ecs-pause:0.1.0\" module=docker_image_manager.go\r\nlevel=info time=2020-08-28T11:09:21Z msg=\"Image excluded from cleanup: amazon/amazon-ecs-pause:0.1.0\" module=docker_image_manager.go\r\nlevel=info time=2020-08-28T11:09:21Z msg=\"Image excluded from cleanup: amazon/amazon-ecs-agent:latest\" module=docker_image_manager.go\r\nlevel=info time=2020-08-28T11:09:21Z msg=\"Creating root ecs cgroup: /ecs\" module=init_linux.go\r\nlevel=info time=2020-08-28T11:09:21Z msg=\"Creating cgroup /ecs\" module=cgroup_controller_linux.go\r\nlevel=info time=2020-08-28T11:09:21Z msg=\"Event stream ContainerChange start listening...\" module=eventstream.go\r\nlevel=info time=2020-08-28T11:09:21Z msg=\"Loading state!\" module=state_manager.go\r\nlevel=info time=2020-08-28T11:09:23Z msg=\"Registering Instance with ECS\" module=agent.go\r\nlevel=info time=2020-08-28T11:09:23Z msg=\"Remaining mem: 7680\" module=client.go\r\nlevel=info time=2020-08-28T11:09:23Z msg=\"Registered container instance with cluster!\" module=client.go\r\nlevel=info time=2020-08-28T11:09:23Z msg=\"Registration completed successfully. I am running as 'arn:aws:ecs:eu-west-1:XXXXXXXXXXXXXXXX:container-instance/foqum-read-dev-train-ecs-cluster/95559f936f8d44de9373595009fcd588' in cluster 'foqum-read-dev-train-ecs-cluster'\" module=agent.go\r\nlevel=info time=2020-08-28T11:09:23Z msg=\"Beginning Polling for updates\" module=agent.go\r\nlevel=info time=2020-08-28T11:09:23Z msg=\"Initializing stats engine\" module=engine.go\r\nlevel=info time=2020-08-28T11:09:23Z msg=\"Event stream DeregisterContainerInstance start listening...\" module=eventstream.go\r\nlevel=info time=2020-08-28T11:09:23Z msg=\"Establishing a Websocket connection to https://ecs-t-X.eu-west-1.amazonaws.com/ws?agentHash=1f05fbf0&agentVersion=1.44.1&cluster=XXXXXXXXX-cluster&containerInstance=arn%3Aaws%3Aecs%3Aeu-west-1%3AXXXXXXXX%3Acontainer-instance%2FXXXXXXXX-cluster%2F95559fXXXXXXde9373595009fcd588&dockerVersion=19.03.6-ce\" module=client.go\r\nlevel=info time=2020-08-28T11:09:23Z msg=\"NO_PROXY set:XXX.254.169.XXXX,XXXX.254.XXX.2,/var/run/docker.sock\" module=client.go\r\nlevel=info time=2020-08-28T11:09:23Z msg=\"Establishing a Websocket connection to https://ecs-a-X.eu-west-1.amazonaws.com/ws?agentHash=1f05fbf0&agentVersion=1.44.1&clusterArn=XXXXX-ecs-cluster&containerInstanceArn=arn%3Aaws%3Aecs%3Aeu-west-1%XXXXXX%3Acontainer-instance%2FXXXXX-ecs-cluster%2F9XXXXX6f8d44de9373595009fcd588&dockerVersion=DockerVersion%3A+19.03.6-ce&sendCredentials=true&seqNum=1\" module=client.go\r\nlevel=info time=2020-08-28T11:09:23Z msg=\"Connected to TCS endpoint\" module=handler.go\r\nlevel=info time=2020-08-28T11:09:23Z msg=\"Connected to ACS endpoint\" module=acs_handler.go\r\nlevel=info time=2020-08-28T11:20:04Z msg=\"TCS Websocket connection closed for a valid reason\" module=handler.go\r\nlevel=info time=2020-08-28T11:20:04Z msg=\"Establishing a Websocket connection to https://ecs-t-X.eu-west-1.amazonaws.com/ws?agentHash=1f05fbf0&agentVersion=1.44.1&cluster=XXXXXXXecs-cluster&containerInstance=arn%3Aaws%3Aecs%3Aeu-west-1%3AXXXXXX3Acontainer-instance%2FZZZXXXXX-ecs-cluster%2F95XXX936f8d44de9373595009fcd588&dockerVersion=19.03.6-ce\" module=client.go\r\nlevel=info time=2020-08-28T11:20:04Z msg=\"Connected to TCS endpoint\" module=handler.go\r\n```\r\n\r\necs-init.log\r\n\r\n```\r\n2020-08-28T11:09:19Z [INFO] pre-start\r\n2020-08-28T11:09:20Z [INFO] start\r\n2020-08-28T11:09:20Z [INFO] No existing agent container to remove.\r\n2020-08-28T11:09:20Z [INFO] Starting Amazon Elastic Container Service Agent\r\n```\r\n\r\n  [1]: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking.html\r\n  [2]: https://stackoverflow.com/questions/55575476/ecs-cluster-cannot-run-tasks-in-private-subnet-when-using-ec2\r\n  [3]: https://aws.amazon.com/es/premiumsupport/knowledge-center/ecs-pull-container-api-error-ecr/\r\n  [4]: https://i.stack.imgur.com/YoqW1.png\r\n  [5]: https://i.stack.imgur.com/hieCy.png\r\n  [6]: https://i.stack.imgur.com/kYHaj.png\r\n  [7]: https://i.stack.imgur.com/weEeq.png\r\n  [8]: https://i.stack.imgur.com/A54J0.png", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "We want to build an ECS cluster with the following characteristics: 1. ", "keywords": ["cluster"]}, {"source": "Text", "text": "It must run inside a VPC, then, we need the awsvpc mode 2. ", "keywords": ["billing mode"]}, {"source": "Text", "text": "It must provision dynamically the instances, therefore, we need a capacity provider 4. ", "keywords": ["provider"]}, {"source": "Text", "text": "We've already read [this post][2] in stackoverflow where it says that we need to set up a private subnet with a route table that points to a NAT Gateway configured in a public subnet, and this public subnet should point to an internet gateway. ", "keywords": ["nat"]}, {"source": "Text", "text": "Bellow, you can see some relevant configurations of the cluster in terraform (for the shake of simplicity I only put the relevant parts): ```{terraform} # Launch template resource \"aws_launch_template\" \"train-launch-template\" { name_prefix = \"{var.project_name}-launch-template-${var.env}\" image_id = \"ami-01f62a207c1d180d2\" instance_type = \"m5.large\" key_name=\"XXXXXX\" iam_instance_profile { name = aws_iam_instance_profile.ecs-instance-profile.name } user_data = base64encode(data.template_file.user_data.rendered) network_interfaces { associate_public_ip_address = false security_groups = [aws_security_group.ecs_service.id] } } # Task definition resource \"aws_ecs_task_definition\" \"task\" { family = \"${var.project_name}-${var.env}-train-task\" execution_role_arn = data.aws_iam_role.ecs_task_execution_role.arn task_role_arn = aws_iam_role.ecs_train_task_role.arn requires_compatibilities = [\"EC2\"] cpu = var.ecs_cpu network_mode = \"awsvpc\" memory = var.ecs_memory container_definitions = data.template_file.app_definition.rendered tags = { Stage = var.env_tag Project = var.project_name_tag } } # Cluster resource \"aws_ecs_cluster\" \"cluster\" { name = \"${var.project_name}-${var.env}-train-ecs-cluster\" capacity_providers = [aws_ecs_capacity_provider.train-capacity-provider.name] default_capacity_provider_strategy { capacity_provider = aws_ecs_capacity_provider.train-capacity-provider.name } tags = { Project = var.project_name_tag Stage = var.env_tag } } ``` ", "keywords": ["instance", "cpu", "provider", "cluster"]}, {"source": "Text", "text": "The AMI corresponds to an ECS optimized instance (the last version published at this moment in eu-west-1). ", "keywords": ["instance"]}, {"source": "Text", "text": "We've evolved to this configuration trying to make this work, but once and again we've faced the same problem: when the task is triggered, the capacity provider launches an instance, but the task is never placed in the container instance and remains in the PROVISIONING status indefinitely. ", "keywords": ["instance", "provider"]}, {"source": "Text", "text": "UPDATE: As requested I've added the rest part concerning to autoscale ``` resource \"aws_autoscaling_group\" \"train-autoscaling\" { availability_zones = [\"eu-west-1b\"] desired_capacity = 0 max_size = 10 min_size = 0 protect_from_scale_in = true launch_template { id = aws_launch_template.train-launch-template.id version = \"$Latest\" } tags = [ { key = \"Project\", value = var.project_name_tag propagate_at_launch = true }, { key = \"Stage\", value = var.env_tag propagate_at_launch = true } ] } resource \"aws_ecs_capacity_provider\" \"train-capacity-provider\" { name = \"${var.project_name}-${var.env}-train-capacity-provider\" auto_scaling_group_provider { auto_scaling_group_arn = aws_autoscaling_group.train-autoscaling.arn managed_termination_protection = \"ENABLED\" managed_scaling { status = \"ENABLED\" target_capacity = 100 maximum_scaling_step_size = 1 minimum_scaling_step_size = 1 } } } data \"template_file\" \"user_data\" { template = \"${file(\"${path.module}/user_data.sh\")}\" vars = { cluster_name = \"${var.project_name}-${var.env}-train-ecs-cluster\" } } ``` ", "keywords": ["provider", "cluster"]}, {"source": "Text", "text": "Update 2 (AWS Console info): Container instances running [![Container instances running][4]][4] Detail container instance: [![enter image description here][5]][5] Pending Task: [![pending task][6]][6] Pending task details: [![pending task details][7]][7] Update 3: After 30 minutes the task stops and this is the message shown (Task failed to start): [![enter image description here][8]][8] Update 4: logs from container instance. ecs-agent.log ``` level=info time=2020-08-28T11:09:21Z msg=\"Loading configuration\" module=agent.go level=info time=2020-08-28T11:09:21Z msg=\"Amazon ECS agent Version: 1.44.1, Commit: 1f05fbf0\" module=agent.go level=info time=2020-08-28T11:09:21Z msg=\"Image excluded from cleanup: amazon/amazon-ecs-pause:0.1.0\" module=docker_image_manager.go level=info time=2020-08-28T11:09:21Z msg=\"Image excluded from cleanup: amazon/amazon-ecs-pause:0.1.0\" module=docker_image_manager.go level=info time=2020-08-28T11:09:21Z msg=\"Image excluded from cleanup: amazon/amazon-ecs-agent:latest\" module=docker_image_manager.go level=info time=2020-08-28T11:09:21Z msg=\"Creating root ecs cgroup: /ecs\" module=init_linux.go level=info time=2020-08-28T11:09:21Z msg=\"Creating cgroup /ecs\" module=cgroup_controller_linux.go level=info time=2020-08-28T11:09:21Z msg=\"Event stream ContainerChange start listening...\" module=eventstream.go level=info time=2020-08-28T11:09:21Z msg=\"Loading state!\" module=state_manager.go level=info time=2020-08-28T11:09:23Z msg=\"Registering Instance with ECS\" module=agent.go level=info time=2020-08-28T11:09:23Z msg=\"Remaining mem: 7680\" module=client.go level=info time=2020-08-28T11:09:23Z msg=\"Registered container instance with cluster!\" module=client.go level=info time=2020-08-28T11:09:23Z msg=\"Registration completed successfully. ", "keywords": ["instance", "cluster"]}, {"source": "Text", "text": "I am running as 'arn:aws:ecs:eu-west-1:XXXXXXXXXXXXXXXX:container-instance/foqum-read-dev-train-ecs-cluster/95559f936f8d44de9373595009fcd588' in cluster 'foqum-read-dev-train-ecs-cluster'\" module=agent.go level=info time=2020-08-28T11:09:23Z msg=\"Beginning Polling for updates\" module=agent.go level=info time=2020-08-28T11:09:23Z msg=\"Initializing stats engine\" module=engine.go level=info time=2020-08-28T11:09:23Z msg=\"Event stream DeregisterContainerInstance start listening...\" module=eventstream.go level=info time=2020-08-28T11:09:23Z msg=\"Establishing a Websocket connection to https://ecs-t-X.eu-west-1.amazonaws.com/ws?agentHash=1f05fbf0&agentVersion=1.44.1&cluster=XXXXXXXXX-cluster&containerInstance=arn%3Aaws%3Aecs%3Aeu-west-1%3AXXXXXXXX%3Acontainer-instance%2FXXXXXXXX-cluster%2F95559fXXXXXXde9373595009fcd588&dockerVersion=19.03.6-ce\" module=client.go level=info time=2020-08-28T11:09:23Z msg=\"NO_PROXY set:XXX.254.169.XXXX,XXXX.254.XXX.2,/var/run/docker.sock\" module=client.go level=info time=2020-08-28T11:09:23Z msg=\"Establishing a Websocket connection to https://ecs-a-X.eu-west-1.amazonaws.com/ws?agentHash=1f05fbf0&agentVersion=1.44.1&clusterArn=XXXXX-ecs-cluster&containerInstanceArn=arn%3Aaws%3Aecs%3Aeu-west-1%XXXXXX%3Acontainer-instance%2FXXXXX-ecs-cluster%2F9XXXXX6f8d44de9373595009fcd588&dockerVersion=DockerVersion%3A+19.03.6-ce&sendCredentials=true&seqNum=1\" module=client.go level=info time=2020-08-28T11:09:23Z msg=\"Connected to TCS endpoint\" module=handler.go level=info time=2020-08-28T11:09:23Z msg=\"Connected to ACS endpoint\" module=acs_handler.go level=info time=2020-08-28T11:20:04Z msg=\"TCS Websocket connection closed for a valid reason\" module=handler.go level=info time=2020-08-28T11:20:04Z msg=\"Establishing a Websocket connection to https://ecs-t-X.eu-west-1.amazonaws.com/ws?agentHash=1f05fbf0&agentVersion=1.44.1&cluster=XXXXXXXecs-cluster&containerInstance=arn%3Aaws%3Aecs%3Aeu-west-1%3AXXXXXX3Acontainer-instance%2FZZZXXXXX-ecs-cluster%2F95XXX936f8d44de9373595009fcd588&dockerVersion=19.03.6-ce\" module=client.go level=info time=2020-08-28T11:20:04Z msg=\"Connected to TCS endpoint\" module=handler.go ``` ecs-init.log ``` 2020-08-28T11:09:19Z [INFO] pre-start 2020-08-28T11:09:20Z [INFO] start 2020-08-28T11:09:20Z [INFO] No existing agent container to remove. ", "keywords": ["instance", "cluster"]}, {"source": "Text", "text": "2020-08-28T11:09:20Z [INFO] Starting Amazon Elastic Container Service Agent ``` [1]: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking.html [2]: https://stackoverflow.com/questions/55575476/ecs-cluster-cannot-run-tasks-in-private-subnet-when-using-ec2 [3]: https://aws.amazon.com/es/premiumsupport/knowledge-center/ecs-pull-container-api-error-ecr/ [4]: https://i.stack.imgur.com/YoqW1.png [5]: https://i.stack.imgur.com/hieCy.png [6]: https://i.stack.imgur.com/kYHaj.png [7]: https://i.stack.imgur.com/weEeq.png [8]: https://i.stack.imgur.com/A54J0.png", "keywords": ["networking", "cluster"]}]}], "answers": [{"Id": "63649275", "PostTypeId": "2", "ParentId": "63621979", "CreationDate": "2020-08-29T16:25:14.950", "Score": "3", "Body": "<p>Finally!! Solved the mystery!</p>\n<p>The problem wasn't in the cluster configuration. When calling through the ECS API to run_task you need to specify the subnet the task should run into.</p>\n<p>Our code was setting in this field the value of one of the public subnets. For that reason, when we changed the container instances to the availability zone corresponding to this public subnet the task was placed.</p>\n<p>Changing this call from the code the task is placed correctly and it has access to the internet.</p>\n", "OwnerUserId": "7357621", "LastActivityDate": "2020-08-29T16:25:14.950", "CommentCount": "0", "ContentLicense": "CC BY-SA 4.0", "history": [{"Id": "229779950", "PostHistoryTypeId": "2", "PostId": "63649275", "RevisionGUID": "38019732-2104-4faa-837a-7fdc5135c85c", "CreationDate": "2020-08-29T16:25:14.950", "UserId": "7357621", "Text": "Finally!! Solved the mystery!\r\n\r\nThe problem wasn't in the cluster configuration. When calling through the ECS API to run_task you need to specify the subnet the task should run into.\r\n\r\nOur code was setting in this field the value of one of the public subnets. For that reason, when we changed the container instances to the availability zone corresponding to this public subnet the task was placed.\r\n\r\nChanging this call from the code the task is placed correctly and it has access to the internet.", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "The problem wasn't in the cluster configuration. ", "keywords": ["cluster"]}, {"source": "Text", "text": "For that reason, when we changed the container instances to the availability zone corresponding to this public subnet the task was placed. ", "keywords": ["change"]}, {"source": "Text", "text": "Changing this call from the code the task is placed correctly and it has access to the internet.", "keywords": ["change"]}]}], "filtered-sentences": [{"source": "Body", "text": "The problem wasn't in the cluster configuration. ", "keywords": ["cluster"]}, {"source": "Body", "text": "For that reason, when we changed the container instances to the availability zone corresponding to this public subnet the task was placed. ", "keywords": ["change"]}, {"source": "Body", "text": "Changing this call from the code the task is placed correctly and it has access to the internet.", "keywords": ["change"]}]}], "contains-topic": true, "filtered-sentences": [{"source": "Title", "text": "Running ECS task in a cluster within a private subnet remains in provisioning status", "keywords": ["cluster"]}, {"source": "Body", "text": "We want to build an ECS cluster with the following characteristics: It must run inside a VPC, then, we need the awsvpc mode ", "keywords": ["billing mode", "cluster"]}, {"source": "Body", "text": "It must use GPU instances, so we can't use Fargate It must provision dynamically the instances, therefore, we need a capacity provider It will run tasks (batch jobs) that are going to be triggered directly through the AWS ECS API. ", "keywords": ["provider"]}, {"source": "Body", "text": "We've already read this post in stackoverflow where it says that we need to set up a private subnet with a route table that points to a NAT Gateway configured in a public subnet, and this public subnet should point to an internet gateway. ", "keywords": ["nat"]}, {"source": "Body", "text": "Bellow, you can see some relevant configurations of the cluster in terraform (for the shake of simplicity I only put the relevant parts): We also have configured all the roles needed for the instances and the task to access to the required resources (S3, ECR, ECS). ", "keywords": ["cluster"]}, {"source": "Body", "text": "The AMI corresponds to an ECS optimized instance (the last version published at this moment in eu-west-1). ", "keywords": ["instance"]}, {"source": "Body", "text": "In the launch template we've removed the public IP to the instances due to the explanation in this link We've evolved to this configuration trying to make this work, but once and again we've faced the same problem: when the task is triggered, the capacity provider launches an instance, but the task is never placed in the container instance and remains in the PROVISIONING status indefinitely. ", "keywords": ["instance", "provider"]}, {"source": "Body", "text": "UPDATE: As requested I've added the rest part concerning to autoscale Update 2 (AWS Console info): Container instances running Detail container instance: Pending Task: Pending task details: Update 3: After 30 minutes the task stops and this is the message shown (Task failed to start): Update 4: logs from container instance. ecs-agent.log ecs-init.log", "keywords": ["instance"]}]}