{"Id": "76307555", "PostTypeId": "1", "AcceptedAnswerId": "76308376", "CreationDate": "2023-05-22T15:08:12.787", "Score": "0", "ViewCount": "151", "Body": "<p>I have a terraform config that creates 4 EC2 instances and gives them static public IP addresses:</p>\n<pre><code>resource &quot;aws_instance&quot; &quot;kit-prod-api&quot; {\n  subnet_id                   = element(module.vpc.public_subnets, count.index)\n  ami                         = data.aws_ami.kit_prod_api_ami.id\n  instance_type               = &quot;c5.large&quot;\n  associate_public_ip_address = true\n  vpc_security_group_ids      = [module.vpc.default_security_group_id, aws_security_group.prod_ssh_security_group.id, aws_security_group.prod_lb_instances_security_group.id]\n  count                       = 4\n  lifecycle {\n    create_before_destroy = &quot;true&quot;\n    ignore_changes = [\n      ami,\n      instance_type,\n    ]\n  }\n  # there are tags and provisioner blocks here too\n}\n</code></pre>\n<p>When I want to update the instances to use a new AMI, I terminate one at a time and run <code>terraform apply</code> to replace them. This works, but they get new public IP addresses. I can see that their old IP addresses show up in the EIP section of the AWS console, but they weren't there beforehand. Is there a way to modify this script/workflow so that the same IP addresses get associated with the new instances?</p>\n", "OwnerUserId": "135346", "LastActivityDate": "2023-05-22T16:52:14.190", "Title": "How to keep the same public IP addresses for a set of AWS EC2 instances with Terraform", "Tags": "<terraform><terraform-provider-aws>", "AnswerCount": "1", "CommentCount": "2", "ContentLicense": "CC BY-SA 4.0", "comments": [{"Id": "134561716", "PostId": "76307555", "Score": "0", "Text": "\"When I want to update the instances to use a new AMI, I terminate one at a time and run terraform apply to replace them.\" That can be dangerous. Why not just update the specified AMI to automatically re-create them as Terraform managed instances? \"I can see that their old IP addresses show up in the EIP section of the AWS console, but they weren't there beforehand.\" Please elaborate on what exactly you mean by this and how the EIP are being associated with the instances.", "CreationDate": "2023-05-22T15:39:49.807", "UserId": "5343387", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "134565520", "PostId": "76307555", "Score": "0", "Text": "@MattSchuchard Thanks for the advice. Regarding the EIP, the `associate_public_ip_address` setting gives each instance a public IP address, but it doesn't appear to create an EIP resource. In the console it says \"No Elastic IP addresses found in this Region\". Except when I manually terminate an instance that has public IP address X, then an EIP for address X shows up in the console. It seems like AWS is automatically reserving that address for my org, but my terraform config isn't making use of that.", "CreationDate": "2023-05-22T20:59:49.400", "UserId": "135346", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "Regarding the EIP, the `associate_public_ip_address` setting gives each instance a public IP address, but it doesn't appear to create an EIP resource. ", "keywords": ["instance"]}, {"source": "Text", "text": "Except when I manually terminate an instance that has public IP address X, then an EIP for address X shows up in the console. ", "keywords": ["instance"]}]}], "history": [{"Id": "293144839", "PostHistoryTypeId": "2", "PostId": "76307555", "RevisionGUID": "1707ee93-1966-495f-b43e-990622ed5ae1", "CreationDate": "2023-05-22T15:08:12.787", "UserId": "135346", "Text": "I have a terraform config that creates 4 EC2 instances and gives them static public IP addresses:\r\n\r\n```\r\nresource \"aws_instance\" \"kit-prod-api\" {\r\n  subnet_id                   = element(module.vpc.public_subnets, count.index)\r\n  ami                         = data.aws_ami.kit_prod_api_ami.id\r\n  instance_type               = \"c5.large\"\r\n  associate_public_ip_address = true\r\n  vpc_security_group_ids      = [module.vpc.default_security_group_id, aws_security_group.prod_ssh_security_group.id, aws_security_group.prod_lb_instances_security_group.id]\r\n  count                       = 4\r\n  lifecycle {\r\n    create_before_destroy = \"true\"\r\n    ignore_changes = [\r\n      ami,\r\n      instance_type,\r\n    ]\r\n  }\r\n  # there are tags and provisioner blocks here too\r\n}\r\n```\r\n\r\nWhen I want to update the instances to use a new AMI, I terminate one at a time and run `terraform apply` to replace them. This works, but they get new public IP addresses. I can see that their old IP addresses show up in the EIP section of the AWS console, but they weren't there beforehand. Is there a way to modify this script/workflow so that the same IP addresses get associated with the new instances?", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "293144841", "PostHistoryTypeId": "1", "PostId": "76307555", "RevisionGUID": "1707ee93-1966-495f-b43e-990622ed5ae1", "CreationDate": "2023-05-22T15:08:12.787", "UserId": "135346", "Text": "How to keep the same public IP addresses for a set of AWS EC2 instances with Terraform", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "293144842", "PostHistoryTypeId": "3", "PostId": "76307555", "RevisionGUID": "1707ee93-1966-495f-b43e-990622ed5ae1", "CreationDate": "2023-05-22T15:08:12.787", "UserId": "135346", "Text": "<terraform><terraform-provider-aws>", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "answers": [{"Id": "76308376", "PostTypeId": "2", "ParentId": "76307555", "CreationDate": "2023-05-22T16:52:14.190", "Score": "1", "Body": "<p>IP addresses in EC2 belong to network interfaces rather than to EC2 instances, but the EC2 API allows implicitly creating a network interface as a side-effect of creating an EC2 instance and so it often <em>appears</em> as though network interface attributes like IP addresses belong directly to EC2 instances, even though that isn't strictly true.</p>\n<p>You can make a network interface outlive the EC2 instance it's attached to by declaring the network interface as a separate resource:</p>\n<pre><code>resource &quot;aws_network_interface&quot; &quot;example&quot; {\n  count = 4\n\n  subnet_id = element(module.vpc.public_subnets, count.index)\n}\n\nresource &quot;aws_instance&quot; &quot;example&quot; {\n  count = length(aws_network_interface.example)\n\n  # ...\n\n  network_interface {\n    network_interface_id = aws_network_interface.example[count.index].id\n  }\n}\n</code></pre>\n<p>The separation above allows the <em>private</em> IPv4 address associated with the network interface to survive even if the associated EC2 instances are replaced. However, note that only one EC2 instance can be attached to each network interface at a particular time, so you won't be able to use <code>create_before_destroy</code> in this case -- that would cause two instances to try to attach to the same network interface at the same time -- and so you'll need to find a different strategy to ensure continuity in situations where you're replacing all of the instances.</p>\n<p>The above only causes the <em>private</em> IP address to be preserved. To associate a consistent <em>public</em> IP address with each network interface you'll need to additionally declare an <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html\" rel=\"nofollow noreferrer\">Elastic IP address</a>, which allows you to allocate a public IP address whose lifetime is independent of any particular network interface or EC2 instance. The Elastic IP address will be associated with the network interface so it can also survive any particular instance being replaced:</p>\n<pre><code># (this is in addition to the example above)\n\nresource &quot;aws_eip&quot; &quot;example&quot; {\n  count = length(aws_network_interface.example)\n\n  network_interface = aws_network_interface.example[count.index].id\n}\n</code></pre>\n<p>To avoid the public IP address of the EC2 instance changing after it's already started booting, you should also tell Terraform about the hidden dependency between the EC2 instance resource and the elastic IP address resource, since Terraform cannot infer it automatically from references:</p>\n<pre><code>resource &quot;aws_instance&quot; &quot;example&quot; {\n  # everything as before, plus:\n  depends_on = [aws_eip.example]\n}\n</code></pre>\n<p>Note that an Elastic IP address has additional cost when it is allocated but not attached to a running EC2 instance.</p>\n<hr />\n<p>More information on these resource types:</p>\n<ul>\n<li><a href=\"https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/network_interface\" rel=\"nofollow noreferrer\"><code>aws_network_interface</code></a></li>\n<li><a href=\"https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/eip\" rel=\"nofollow noreferrer\"><code>aws_eip</code></a></li>\n<li><a href=\"https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/instance#network-interfaces\" rel=\"nofollow noreferrer\">the <code>network_interface</code> block of <code>aws_instance</code></a></li>\n</ul>\n", "OwnerUserId": "281848", "LastActivityDate": "2023-05-22T16:52:14.190", "CommentCount": "4", "ContentLicense": "CC BY-SA 4.0", "comments": [{"Id": "134565433", "PostId": "76308376", "Score": "0", "Text": "It looks like the `aws_eip` resource can be associated directly with an EC2 instance. If I don't care about preserving the other aspects of the network interface, can I just declare the EIPs with the instance specified with `[count.index]` like you show for the network interface?", "CreationDate": "2023-05-22T20:50:46.543", "UserId": "135346", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "It looks like the `aws_eip` resource can be associated directly with an EC2 instance. ", "keywords": ["instance"]}, {"source": "Text", "text": "If I don't care about preserving the other aspects of the network interface, can I just declare the EIPs with the instance specified with `[count.index]` like you show for the network interface?", "keywords": ["instance"]}]}, {"Id": "134597672", "PostId": "76308376", "Score": "0", "Text": "If I recall correctly, directly associating an elastic IP address with an EC2 instance is a shorthand for associating the IP address with the EC2 instance's dynamically-allocated network interface. If that's true then indeed I expect you could cut out the separate network interface declaration if you only need the _public_ IP address to remain constant, and not also the private IP address.", "CreationDate": "2023-05-25T01:08:04.367", "UserId": "281848", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "If I recall correctly, directly associating an elastic IP address with an EC2 instance is a shorthand for associating the IP address with the EC2 instance's dynamically-allocated network interface. ", "keywords": ["instance"]}]}, {"Id": "134597680", "PostId": "76308376", "Score": "0", "Text": "One small hazard with that is that if the elastic IP gets attached to the instance after it's initially booted then the `public_ip` for the instance known to Terraform will be incorrect: it'll track the IP address that was allocated immediately when the instance started, and won't \"see\" the change caused by attaching the elastic IP. To deal with that problem you should make sure to always refer to the `aws_eip` resource when you need the public IP address, and ignore the `public_ip` attribute of `aws_instance`.", "CreationDate": "2023-05-25T01:09:33.583", "UserId": "281848", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "One small hazard with that is that if the elastic IP gets attached to the instance after it's initially booted then the `public_ip` for the instance known to Terraform will be incorrect: it'll track the IP address that was allocated immediately when the instance started, and won't \"see\" the change caused by attaching the elastic IP. ", "keywords": ["instance", "change"]}]}, {"Id": "134661070", "PostId": "76308376", "Score": "0", "Text": "I tried directly associating it with the instance, but the reference to the `aws_eip.public_ip` in the provisioner block caused a circular reference between the instance and eip. So I ended up doing it as you originally suggested rather than splitting the provisoner out of the instance resource. Thank you for your help.", "CreationDate": "2023-05-30T14:55:22.693", "UserId": "135346", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "I tried directly associating it with the instance, but the reference to the `aws_eip.public_ip` in the provisioner block caused a circular reference between the instance and eip. ", "keywords": ["instance"]}, {"source": "Text", "text": "So I ended up doing it as you originally suggested rather than splitting the provisoner out of the instance resource. ", "keywords": ["instance"]}]}], "history": [{"Id": "293149497", "PostHistoryTypeId": "2", "PostId": "76308376", "RevisionGUID": "c47c1aee-a8b1-4471-8ff9-fb43b8ac0c99", "CreationDate": "2023-05-22T16:52:14.190", "UserId": "281848", "Text": "IP addresses in EC2 belong to network interfaces rather than to EC2 instances, but the EC2 API allows implicitly creating a network interface as a side-effect of creating an EC2 instance and so it often _appears_ as though network interface attributes like IP addresses belong directly to EC2 instances, even though that isn't strictly true.\r\n\r\nYou can make a network interface outlive the EC2 instance it's attached to by declaring the network interface as a separate resource:\r\n\r\n```\r\nresource \"aws_network_interface\" \"example\" {\r\n  count = 4\r\n\r\n  subnet_id = element(module.vpc.public_subnets, count.index)\r\n}\r\n\r\nresource \"aws_instance\" \"example\" {\r\n  count = length(aws_network_interface.example)\r\n\r\n  # ...\r\n\r\n  network_interface {\r\n    network_interface_id = aws_network_interface.example[count.index].id\r\n  }\r\n}\r\n```\r\n\r\nThe separation above allows the _private_ IPv4 address associated with the network interface to survive even if the associated EC2 instances are replaced. However, note that only one EC2 instance can be attached to each network interface at a particular time, so you won't be able to use `create_before_destroy` in this case -- that would cause two instances to try to attach to the same network interface at the same time -- and so you'll need to find a different strategy to ensure continuity in situations where you're replacing all of the instances.\r\n\r\nThe above only causes the _private_ IP address to be preserved. To associate a consistent _public_ IP address with each network interface you'll need to additionally declare an [Elastic IP address](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html), which allows you to allocate a public IP address whose lifetime is independent of any particular network interface or EC2 instance. The Elastic IP address will be associated with the network interface so it can also survive any particular instance being replaced:\r\n\r\n```\r\n# (this is in addition to the example above)\r\n\r\nresource \"aws_eip\" \"example\" {\r\n  count = length(aws_network_interface.example)\r\n\r\n  network_interface = aws_network_interface.example[count.index].id\r\n}\r\n```\r\n\r\nTo avoid the public IP address of the EC2 instance changing after it's already started booting, you should also tell Terraform about the hidden dependency between the EC2 instance resource and the elastic IP address resource, since Terraform cannot infer it automatically from references:\r\n\r\n```\r\nresource \"aws_instance\" \"example\" {\r\n  # everything as before, plus:\r\n  depends_on = [aws_eip.example]\r\n}\r\n```\r\n\r\n\r\nNote that an Elastic IP address has additional cost when it is allocated but not attached to a running EC2 instance.\r\n\r\n---\r\n\r\nMore information on these resource types:\r\n* [`aws_network_interface`](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/network_interface)\r\n* [`aws_eip`](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/eip)\r\n* [the `network_interface` block of `aws_instance`](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/instance#network-interfaces)\r\n\r\n", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "IP addresses in EC2 belong to network interfaces rather than to EC2 instances, but the EC2 API allows implicitly creating a network interface as a side-effect of creating an EC2 instance and so it often _appears_ as though network interface attributes like IP addresses belong directly to EC2 instances, even though that isn't strictly true. ", "keywords": ["instance"]}, {"source": "Text", "text": "You can make a network interface outlive the EC2 instance it's attached to by declaring the network interface as a separate resource: ``` resource \"aws_network_interface\" \"example\" { count = 4 subnet_id = element(module.vpc.public_subnets, count.index) } resource \"aws_instance\" \"example\" { count = length(aws_network_interface.example) # ... network_interface { network_interface_id = aws_network_interface.example[count.index].id } } ``` ", "keywords": ["instance"]}, {"source": "Text", "text": "However, note that only one EC2 instance can be attached to each network interface at a particular time, so you won't be able to use `create_before_destroy` in this case -- that would cause two instances to try to attach to the same network interface at the same time -- and so you'll need to find a different strategy to ensure continuity in situations where you're replacing all of the instances. ", "keywords": ["instance"]}, {"source": "Text", "text": "To associate a consistent _public_ IP address with each network interface you'll need to additionally declare an [Elastic IP address](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html), which allows you to allocate a public IP address whose lifetime is independent of any particular network interface or EC2 instance. ", "keywords": ["instance"]}, {"source": "Text", "text": "The Elastic IP address will be associated with the network interface so it can also survive any particular instance being replaced: ``` # (this is in addition to the example above) resource \"aws_eip\" \"example\" { count = length(aws_network_interface.example) network_interface = aws_network_interface.example[count.index].id } ``` ", "keywords": ["instance"]}, {"source": "Text", "text": "To avoid the public IP address of the EC2 instance changing after it's already started booting, you should also tell Terraform about the hidden dependency between the EC2 instance resource and the elastic IP address resource, since Terraform cannot infer it automatically from references: ``` resource \"aws_instance\" \"example\" { # everything as before, plus: depends_on = [aws_eip.example] } ``` ", "keywords": ["instance", "change"]}, {"source": "Text", "text": "Note that an Elastic IP address has additional cost when it is allocated but not attached to a running EC2 instance. ", "keywords": ["cost", "instance"]}, {"source": "Text", "text": "--- More information on these resource types: * [`aws_network_interface`](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/network_interface) * [`aws_eip`](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/eip) * [the `network_interface` block of `aws_instance`](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/instance#network-interfaces)", "keywords": ["instance"]}]}], "filtered-sentences": [{"source": "Body", "text": "IP addresses in EC2 belong to network interfaces rather than to EC2 instances, but the EC2 API allows implicitly creating a network interface as a side-effect of creating an EC2 instance and so it often appears as though network interface attributes like IP addresses belong directly to EC2 instances, even though that isn't strictly true. ", "keywords": ["instance"]}, {"source": "Body", "text": "You can make a network interface outlive the EC2 instance it's attached to by declaring the network interface as a separate resource: ", "keywords": ["instance"]}, {"source": "Body", "text": "However, note that only one EC2 instance can be attached to each network interface at a particular time, so you won't be able to use create_before_destroy in this case -- that would cause two instances to try to attach to the same network interface at the same time -- and so you'll need to find a different strategy to ensure continuity in situations where you're replacing all of the instances. ", "keywords": ["instance"]}, {"source": "Body", "text": "To associate a consistent public IP address with each network interface you'll need to additionally declare an Elastic IP address, which allows you to allocate a public IP address whose lifetime is independent of any particular network interface or EC2 instance. ", "keywords": ["instance"]}, {"source": "Body", "text": "The Elastic IP address will be associated with the network interface so it can also survive any particular instance being replaced: ", "keywords": ["instance"]}, {"source": "Body", "text": "To avoid the public IP address of the EC2 instance changing after it's already started booting, you should also tell Terraform about the hidden dependency between the EC2 instance resource and the elastic IP address resource, since Terraform cannot infer it automatically from references: ", "keywords": ["instance", "change"]}, {"source": "Body", "text": "Note that an Elastic IP address has additional cost when it is allocated but not attached to a running EC2 instance. ", "keywords": ["cost", "instance"]}]}], "contains-topic": true, "filtered-sentences": []}