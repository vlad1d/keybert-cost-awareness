{"Id": "58135618", "PostTypeId": "1", "AcceptedAnswerId": "58140965", "CreationDate": "2019-09-27T13:33:16.573", "Score": "0", "ViewCount": "572", "Body": "<p>In our case we are doing the following:<br>\n1.  Infra Agent<br>\na.  We create a KV<br>\nb.  We create a SQL Database in the tf script, including assigning an admin username and password  (randomly generated value).<br>\nc.  We store the username and password as secrets in the newly created KV<br>\n2.  Data Agent<br>\na.  We want to deploy the DDL from the repos onto the SQL Database we created in Infra Agent. We need to use the SQL database username and password stored in the KV to do so<br>\nb.  In order to read the secrets from the KV our current thinking is to insert the username and password to pipeline parameters in step 1 (i.e. setting them at runtime) so we can reuse the values across other Agents.  </p>\n\n<p>A couple of questions:<br>\n-   Is that the right approach? Should KV be created in the Infra Agent tf scripts? Should we randomly generate passwords (as secrets)?<br>\n-   What is best practice to access the Database username and password in other Agents, given that:<br>\no   We can\u2019t use variable groups because the KV and values won\u2019t be known until runtime<br>\no   We can\u2019t use the Key Vault Task (<a href=\"https://learn.microsoft.com/en-us/azure/devops/pipelines/tasks/deploy/azure-key-vault?view=azure-devops\" rel=\"nofollow noreferrer\">https://learn.microsoft.com/en-us/azure/devops/pipelines/tasks/deploy/azure-key-vault?view=azure-devops</a>) to read from the KV because the KV name is only known at runtime (via the tf vars file)</p>\n", "OwnerUserId": "7462678", "LastActivityDate": "2019-09-28T10:38:07.147", "Title": "Azure DevOps terraform and AKV", "Tags": "<azure><azure-devops><terraform><devops>", "AnswerCount": "1", "CommentCount": "0", "ContentLicense": "CC BY-SA 4.0", "history": [{"Id": "206176524", "PostHistoryTypeId": "2", "PostId": "58135618", "RevisionGUID": "2d83080f-4569-45ba-a73d-429ae4d1d200", "CreationDate": "2019-09-27T13:33:16.573", "UserId": "7462678", "Text": "In our case we are doing the following:  \r\n1. Infra Agent   \r\na. We create a KV  \r\nb. We create a SQL Database in the tf script, including assigning an admin username and password  (randomly generated value).   \r\nc. We store the username and password as secrets in the newly created KV  \r\n2. Data Agent   \r\na. We want to deploy the DDL from the repos onto the SQL Database we created in Infra Agent. We need to use the SQL database username and password stored in the KV to do so  \r\nb. In order to read the secrets from the KV our current thinking is to insert the username and password to pipeline parameters in step 1 (i.e. setting them at runtime) so we can reuse the values across other Agents.  \r\n\r\nA couple of questions:  \r\n- Is that the right approach? Should KV be created in the Infra Agent tf scripts? Should we randomly generate passwords (as secrets)?  \r\n- What is best practice to access the Database username and password in other Agents, given that:   \r\no We can\u2019t use variable groups because the KV and values won\u2019t be known until runtime  \r\no We can\u2019t use the Key Vault Task (https://learn.microsoft.com/en-us/azure/devops/pipelines/tasks/deploy/azure-key-vault?view=azure-devops) to read from the KV because the KV name is only known at runtime (via the tf vars file)\r\n\r\n", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "206176525", "PostHistoryTypeId": "1", "PostId": "58135618", "RevisionGUID": "2d83080f-4569-45ba-a73d-429ae4d1d200", "CreationDate": "2019-09-27T13:33:16.573", "UserId": "7462678", "Text": "Azure DevOps terraform and AKV", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "206176526", "PostHistoryTypeId": "3", "PostId": "58135618", "RevisionGUID": "2d83080f-4569-45ba-a73d-429ae4d1d200", "CreationDate": "2019-09-27T13:33:16.573", "UserId": "7462678", "Text": "<azure><azure-devops><terraform><devops>", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "answers": [{"Id": "58140965", "PostTypeId": "2", "ParentId": "58135618", "CreationDate": "2019-09-27T20:24:45.277", "Score": "1", "Body": "<blockquote>\n  <p>b. We create a SQL Database in the tf script, including assigning an admin username and password (randomly generated value).</p>\n</blockquote>\n\n<p>If you're using Key Vault, then I assume you're talking about Azure SQL Databases. However at the moment Terraform only supports assigning a administrator username and password for the <a href=\"https://www.terraform.io/docs/providers/azurerm/r/sql_server.html\" rel=\"nofollow noreferrer\"><em>SQL Server instance</em></a>, not <a href=\"https://www.terraform.io/docs/providers/azurerm/r/sql_database.html\" rel=\"nofollow noreferrer\"><em>SQL databases</em></a>.</p>\n\n<p>In this case, I recommend using <a href=\"https://www.terraform.io/docs/providers/random/r/password.html\" rel=\"nofollow noreferrer\">random_password</a> resources to assign values to <a href=\"https://www.terraform.io/docs/providers/azurerm/r/key_vault_secret.html\" rel=\"nofollow noreferrer\">azurerm_key_vault_secret</a> which can then be assigned as the <code>azurerm_sql_server</code> administrator password.</p>\n\n<p>With this setup you know for certain that the password in Key Vault is always in sync, and can be treated as the source of truth for your SQL server passwords (unless someone goes and resets the administrator password manually of course).</p>\n\n<p>Now if you ever want to reset an SQL server password, simply taint the <code>random_password</code>, forcing it to be recreated with a new value, which in turn updates the <code>azurerm_key_vault_secret</code> value and then the <code>azurerm_sql_server</code> password.</p>\n\n<p>Here's some quick HCL as an example</p>\n\n<pre><code>resource \"random_password\" \"password\" {\n    length = 16\n    special = false\n}\n\nresource \"azurerm_key_vault_secret\" \"password_secret\" {\n    depends_on = [&lt;the Key Vault access policy for your infra agent which runs terraform apply&gt;]\n    ...\n    value = random_password.password.result\n    ...\n}\n\nresource \"azurerm_sql_server\" \"sql_server\" {\n    ...\n    administrator_login_password = azurerm_key_vault_secret.password_secret.value\n    ...\n}\n</code></pre>\n\n<blockquote>\n  <p>Is that the right approach? Should KV be created in the Infra Agent tf scripts? Should we randomly generate passwords (as secrets)?</p>\n</blockquote>\n\n<p>This is a sensible approach, but remember that billing is <strong>per secret, key or cert</strong> and Key Vaults themselves are free. It's recommended to create a Key Vault <strong>for each application</strong> because access policies can only be applied per Key Vault and not per secret/key/cert.</p>\n\n<blockquote>\n  <p>We can\u2019t use the Key Vault Task (<a href=\"https://learn.microsoft.com/en-us/azure/devops/pipelines/tasks/deploy/azure-key-vault?view=azure-devops\" rel=\"nofollow noreferrer\">https://learn.microsoft.com/en-us/azure/devops/pipelines/tasks/deploy/azure-key-vault?view=azure-devops</a>) to read from the KV because the KV name is only known at runtime (via the tf vars file)</p>\n</blockquote>\n\n<p>Why is this only known at runtime? This sounds like a limitation of your own process since Terraform allows you to specify a name for each Key Vault when you create it. Reconsider if this is really a requirement and why you are doign this. If it definitely is a requirement and your Key Vault names are dynamically generated, then you can use <a href=\"https://www.terraform.io/docs/commands/output.html\" rel=\"nofollow noreferrer\"><code>terraform output</code></a> to get the Key Vault name during the pipeline and <a href=\"https://learn.microsoft.com/en-us/azure/devops/pipelines/process/variables?view=azure-devops&amp;tabs=yaml%2Cbatch#set-in-script\" rel=\"nofollow noreferrer\">set it as a variable during the build</a>.</p>\n\n<p>To fetch the Key Vault name as an output just use the following HCL</p>\n\n<pre><code>output \"key_vault_name\" {\n    value = \"${azurerm_key_vault.demo_key_vault.name}\"\n}\n</code></pre>\n\n<p>and run `terraform output key_vault_name\" to write the value to stdout.</p>\n", "OwnerUserId": "7095194", "LastEditorUserId": "7095194", "LastEditDate": "2019-09-28T10:38:07.147", "LastActivityDate": "2019-09-28T10:38:07.147", "CommentCount": "0", "ContentLicense": "CC BY-SA 4.0", "history": [{"Id": "206198275", "PostHistoryTypeId": "2", "PostId": "58140965", "RevisionGUID": "e327bd19-c107-4fa8-a9e1-119c93fe00d8", "CreationDate": "2019-09-27T20:24:45.277", "UserId": "7095194", "Text": "There\r\n\r\n> b. We create a SQL Database in the tf script, including assigning an admin username and password (randomly generated value).\r\n\r\nIf you're using Key Vault, then I assume you're talking about Azure SQL Databases. However at the moment Terraform only supports assigning a administrator username and password for the [*SQL Server instance*](https://www.terraform.io/docs/providers/azurerm/r/sql_server.html), not [*SQL databases*](https://www.terraform.io/docs/providers/azurerm/r/sql_database.html).\r\n\r\nIn this case, I recommend using [random_password](https://www.terraform.io/docs/providers/random/r/password.html) resources to assign values to [azurerm_key_vault_secret](https://www.terraform.io/docs/providers/azurerm/r/key_vault_secret.html) which can then be assigned as the `azurerm_sql_server` administrator password.\r\n\r\nWith this setup you know for certain that the password in Key Vault is always in sync, and can be treated as the source of truth for your SQL server passwords (unless someone goes and resets the administrator password manually of course).\r\n\r\nNow if you ever want to reset an SQL server password, simply taint the `random_password`, forcing it to be recreated with a new value, which in turn updates the `azurerm_key_vault_secret` value and then the `azurerm_sql_server` password.\r\n\r\nHere's some quick HCL as an example\r\n\r\n```hcl\r\nresource \"random_password\" \"password\" {\r\n    length = 16\r\n    special = false\r\n}\r\n\r\nresource \"azurerm_key_vault_secret\" \"password_secret\" {\r\n    depends_on = [<the Key Vault access policy for your infra agent which runs terraform apply>]\r\n    ...\r\n    value = random_password.password.result\r\n    ...\r\n}\r\n\r\nresource \"azurerm_sql_server\" \"sql_server\" {\r\n    ...\r\n    administrator_login_password = azurerm_key_vault_secret.password_secret.value\r\n    ...\r\n}\r\n```\r\n\r\n> Is that the right approach? Should KV be created in the Infra Agent tf scripts? Should we randomly generate passwords (as secrets)?\r\n\r\nThis is a sensible approach, but remember that billing is **per secret, key or cert** and Key Vaults themselves are free. It's recommended to create a Key Vault **for each application** because access policies can only be applied per Key Vault and not per secret/key/cert.\r\n\r\n> We can\u2019t use the Key Vault Task (https://learn.microsoft.com/en-us/azure/devops/pipelines/tasks/deploy/azure-key-vault?view=azure-devops) to read from the KV because the KV name is only known at runtime (via the tf vars file)\r\n\r\nWhy is this only known at runtime? This sounds like a limitation of your own process since Terraform allows you to specify a name for each Key Vault when you create it. Reconsider if this is really a requirement and why you are doign this. If it definitely is a requirement and your Key Vault names are dynamically generated, then you can use [`terraform output`](https://www.terraform.io/docs/commands/output.html) to get the Key Vault name during the pipeline and [set it as a variable during the build](https://learn.microsoft.com/en-us/azure/devops/pipelines/process/variables?view=azure-devops&tabs=yaml%2Cbatch#set-in-script).\r\n\r\nTo fetch the Key Vault name as an output just use the following HCL\r\n\r\n```hcl\r\noutput \"key_vault_name\" {\r\n    value = \"${azurerm_key_vault.demo_key_vault.name}\"\r\n}\r\n```\r\n\r\nand run `terraform output key_vault_name\" to write the value to stdout.", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "However at the moment Terraform only supports assigning a administrator username and password for the [*SQL Server instance*](https://www.terraform.io/docs/providers/azurerm/r/sql_server.html), not [*SQL databases*](https://www.terraform.io/docs/providers/azurerm/r/sql_database.html). ", "keywords": ["instance"]}, {"source": "Text", "text": "This is a sensible approach, but remember that billing is **per secret, key or cert** and Key Vaults themselves are free. ", "keywords": ["bill"]}]}, {"Id": "206225931", "PostHistoryTypeId": "5", "PostId": "58140965", "RevisionGUID": "95e23023-79fa-42d3-a00b-de8b407da4f0", "CreationDate": "2019-09-28T10:38:07.147", "UserId": "7095194", "Comment": "deleted 9 characters in body", "Text": "> b. We create a SQL Database in the tf script, including assigning an admin username and password (randomly generated value).\r\n\r\nIf you're using Key Vault, then I assume you're talking about Azure SQL Databases. However at the moment Terraform only supports assigning a administrator username and password for the [*SQL Server instance*](https://www.terraform.io/docs/providers/azurerm/r/sql_server.html), not [*SQL databases*](https://www.terraform.io/docs/providers/azurerm/r/sql_database.html).\r\n\r\nIn this case, I recommend using [random_password](https://www.terraform.io/docs/providers/random/r/password.html) resources to assign values to [azurerm_key_vault_secret](https://www.terraform.io/docs/providers/azurerm/r/key_vault_secret.html) which can then be assigned as the `azurerm_sql_server` administrator password.\r\n\r\nWith this setup you know for certain that the password in Key Vault is always in sync, and can be treated as the source of truth for your SQL server passwords (unless someone goes and resets the administrator password manually of course).\r\n\r\nNow if you ever want to reset an SQL server password, simply taint the `random_password`, forcing it to be recreated with a new value, which in turn updates the `azurerm_key_vault_secret` value and then the `azurerm_sql_server` password.\r\n\r\nHere's some quick HCL as an example\r\n\r\n```hcl\r\nresource \"random_password\" \"password\" {\r\n    length = 16\r\n    special = false\r\n}\r\n\r\nresource \"azurerm_key_vault_secret\" \"password_secret\" {\r\n    depends_on = [<the Key Vault access policy for your infra agent which runs terraform apply>]\r\n    ...\r\n    value = random_password.password.result\r\n    ...\r\n}\r\n\r\nresource \"azurerm_sql_server\" \"sql_server\" {\r\n    ...\r\n    administrator_login_password = azurerm_key_vault_secret.password_secret.value\r\n    ...\r\n}\r\n```\r\n\r\n> Is that the right approach? Should KV be created in the Infra Agent tf scripts? Should we randomly generate passwords (as secrets)?\r\n\r\nThis is a sensible approach, but remember that billing is **per secret, key or cert** and Key Vaults themselves are free. It's recommended to create a Key Vault **for each application** because access policies can only be applied per Key Vault and not per secret/key/cert.\r\n\r\n> We can\u2019t use the Key Vault Task (https://learn.microsoft.com/en-us/azure/devops/pipelines/tasks/deploy/azure-key-vault?view=azure-devops) to read from the KV because the KV name is only known at runtime (via the tf vars file)\r\n\r\nWhy is this only known at runtime? This sounds like a limitation of your own process since Terraform allows you to specify a name for each Key Vault when you create it. Reconsider if this is really a requirement and why you are doign this. If it definitely is a requirement and your Key Vault names are dynamically generated, then you can use [`terraform output`](https://www.terraform.io/docs/commands/output.html) to get the Key Vault name during the pipeline and [set it as a variable during the build](https://learn.microsoft.com/en-us/azure/devops/pipelines/process/variables?view=azure-devops&tabs=yaml%2Cbatch#set-in-script).\r\n\r\nTo fetch the Key Vault name as an output just use the following HCL\r\n\r\n```hcl\r\noutput \"key_vault_name\" {\r\n    value = \"${azurerm_key_vault.demo_key_vault.name}\"\r\n}\r\n```\r\n\r\nand run `terraform output key_vault_name\" to write the value to stdout.", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "However at the moment Terraform only supports assigning a administrator username and password for the [*SQL Server instance*](https://www.terraform.io/docs/providers/azurerm/r/sql_server.html), not [*SQL databases*](https://www.terraform.io/docs/providers/azurerm/r/sql_database.html). ", "keywords": ["instance"]}, {"source": "Text", "text": "This is a sensible approach, but remember that billing is **per secret, key or cert** and Key Vaults themselves are free. ", "keywords": ["bill"]}]}], "filtered-sentences": [{"source": "Body", "text": "However at the moment Terraform only supports assigning a administrator username and password for the SQL Server instance, not SQL databases. ", "keywords": ["instance"]}, {"source": "Body", "text": "This is a sensible approach, but remember that billing is per secret, key or cert and Key Vaults themselves are free. ", "keywords": ["bill"]}]}], "contains-topic": true, "filtered-sentences": []}