{"Id": "65826698", "PostTypeId": "1", "AcceptedAnswerId": "65826760", "CreationDate": "2021-01-21T11:43:07.713", "Score": "1", "ViewCount": "1331", "Body": "<p>We want Bitbucket webhooks to trigger our CI tool which runs on an AWS EC2 instance, protected with ingress rules from general access.</p>\n<p>Bitbucket provides a page listing their IP addresses at <a href=\"https://support.atlassian.com/bitbucket-cloud/docs/what-are-the-bitbucket-cloud-ip-addresses-i-should-use-to-configure-my-corporate-firewall/\" rel=\"nofollow noreferrer\">https://support.atlassian.com/bitbucket-cloud/docs/what-are-the-bitbucket-cloud-ip-addresses-i-should-use-to-configure-my-corporate-firewall/</a></p>\n<p>They also have a machine-consumable version at <a href=\"https://ip-ranges.atlassian.com/\" rel=\"nofollow noreferrer\">https://ip-ranges.atlassian.com/</a> for Atlassian IPs in general.</p>\n<p>I wonder, what is an efficient approach to add and maintain this list in AWS EC2 security groups, e.g. via terraform.</p>\n", "OwnerUserId": "1242922", "LastActivityDate": "2021-01-29T13:54:59.200", "Title": "How to whitelist Atlassian/Bitbucket IPs in AWS EC2 security group?", "Tags": "<amazon-ec2><terraform><bitbucket>", "AnswerCount": "2", "CommentCount": "0", "ContentLicense": "CC BY-SA 4.0", "links": [{"Id": "1791852785", "CreationDate": "2021-01-21T11:47:10.337", "PostId": "65826698", "RelatedPostId": "47243474", "LinkTypeId": "1"}], "history": [{"Id": "239202047", "PostHistoryTypeId": "2", "PostId": "65826698", "RevisionGUID": "360f996d-e73d-4513-9ad3-88efe624e2a2", "CreationDate": "2021-01-21T11:43:07.713", "UserId": "1242922", "Text": "We want Bitbucket webhooks to trigger our CI tool which runs on an AWS EC2 instance, protected with ingress rules from general access.\r\n\r\nBitbucket provides a page listing their IP addresses at https://support.atlassian.com/bitbucket-cloud/docs/what-are-the-bitbucket-cloud-ip-addresses-i-should-use-to-configure-my-corporate-firewall/\r\n\r\nThey also have a machine-consumable version at https://ip-ranges.atlassian.com/ for Atlassian IPs in general.\r\n\r\nI wonder, what is an efficient approach to add and maintain this list in AWS EC2 security groups, e.g. via terraform.", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "We want Bitbucket webhooks to trigger our CI tool which runs on an AWS EC2 instance, protected with ingress rules from general access. ", "keywords": ["instance"]}, {"source": "Text", "text": "I wonder, what is an efficient approach to add and maintain this list in AWS EC2 security groups, e.g. via terraform.", "keywords": ["efficient"]}]}, {"Id": "239202048", "PostHistoryTypeId": "1", "PostId": "65826698", "RevisionGUID": "360f996d-e73d-4513-9ad3-88efe624e2a2", "CreationDate": "2021-01-21T11:43:07.713", "UserId": "1242922", "Text": "How to whitelist Atlassian/Bitbucket IPs in AWS EC2 security group?", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "239202049", "PostHistoryTypeId": "3", "PostId": "65826698", "RevisionGUID": "360f996d-e73d-4513-9ad3-88efe624e2a2", "CreationDate": "2021-01-21T11:43:07.713", "UserId": "1242922", "Text": "<amazon-ec2><terraform><bitbucket>", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "answers": [{"Id": "65826760", "PostTypeId": "2", "ParentId": "65826698", "CreationDate": "2021-01-21T11:47:10.337", "Score": "2", "Body": "<p>I ended up scraping the machine-consumable json from their page, and let terraform manage the rest. The step of getting the json is left as a manual task.</p>\n<pre><code>resource &quot;aws_security_group_rule&quot; &quot;bitbucket-ips-sgr&quot; {\n  security_group_id = &quot;your-security-group-id&quot;\n  type = &quot;ingress&quot;\n\n  from_port = 443\n  to_port = 443\n  protocol = &quot;TCP&quot;\n  cidr_blocks = local.bitbucket_cidrs_ipv4\n  ipv6_cidr_blocks = local.bitbucket_cidrs_ipv6\n}\n\nlocals {\n  bitbucket_cidrs_ipv4 = [for item in local.bitbucket_ip_ranges_source.items:\n  # see https://stackoverflow.com/q/47243474/1242922\n  item.cidr if length(regexall(&quot;:&quot;, item.cidr)) == 0\n  ]\n  bitbucket_cidrs_ipv6 = [for item in local.bitbucket_ip_ranges_source.items:\n  # see https://stackoverflow.com/q/47243474/1242922\n  item.cidr if length(regexall(&quot;:&quot;, item.cidr)) &gt; 0\n  ]\n  # the list originates from https://ip-ranges.atlassian.com/\n  bitbucket_ip_ranges_source = jsondecode(\n&lt;&lt;JSON\nthe json output from the above URL\nJSON\n          )\n}\n</code></pre>\n", "OwnerUserId": "1242922", "LastActivityDate": "2021-01-21T11:47:10.337", "CommentCount": "0", "ContentLicense": "CC BY-SA 4.0", "history": [{"Id": "239202285", "PostHistoryTypeId": "2", "PostId": "65826760", "RevisionGUID": "82edee90-b0a8-4640-b33c-204a089f3c66", "CreationDate": "2021-01-21T11:47:10.337", "UserId": "1242922", "Text": "I ended up scraping the machine-consumable json from their page, and let terraform manage the rest. The step of getting the json is left as a manual task.\r\n\r\n    resource \"aws_security_group_rule\" \"bitbucket-ips-sgr\" {\r\n      security_group_id = \"your-security-group-id\"\r\n      type = \"ingress\"\r\n    \r\n      from_port = 443\r\n      to_port = 443\r\n      protocol = \"TCP\"\r\n      cidr_blocks = local.bitbucket_cidrs_ipv4\r\n      ipv6_cidr_blocks = local.bitbucket_cidrs_ipv6\r\n    }\r\n    \r\n    locals {\r\n      bitbucket_cidrs_ipv4 = [for item in local.bitbucket_ip_ranges_source.items:\r\n      # see https://stackoverflow.com/q/47243474/1242922\r\n      item.cidr if length(regexall(\":\", item.cidr)) == 0\r\n      ]\r\n      bitbucket_cidrs_ipv6 = [for item in local.bitbucket_ip_ranges_source.items:\r\n      # see https://stackoverflow.com/q/47243474/1242922\r\n      item.cidr if length(regexall(\":\", item.cidr)) > 0\r\n      ]\r\n      # the list originates from https://ip-ranges.atlassian.com/\r\n      bitbucket_ip_ranges_source = jsondecode(\r\n    <<JSON\r\n    the json output from the above URL\r\n    JSON\r\n              )\r\n    }", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "filtered-sentences": []}, {"Id": "65926851", "PostTypeId": "2", "ParentId": "65826698", "CreationDate": "2021-01-27T20:26:10.983", "Score": "2", "Body": "<p>I improved on Richard's answer and wanted to add that TF's http provider can fetch the JSON for you, and, with a slight tweak to the <code>jsondecode()</code> call, that same <code>for</code> loop still plays.</p>\n<pre><code>provider &quot;http&quot; {}\n\ndata &quot;http&quot; &quot;bitbucket_ips&quot; {\n  url = &quot;https://ip-ranges.atlassian.com/&quot;\n\n  request_headers = {\n    Accept = &quot;application/json&quot;\n  }\n}\n\nlocals {\n  bitbucket_ipv4_cidrs = [for c in jsondecode(data.http.bitbucket_ips.body).items : c.cidr if length(regexall(&quot;:&quot;, c.cidr)) == 0]\n  bitbucket_ipv6_cidrs = [for c in jsondecode(data.http.bitbucket_ips.body).items : c.cidr if length(regexall(&quot;:&quot;, c.cidr)) &gt; 0]\n}\n\noutput &quot;ipv4_cidrs&quot; {\n  value = local.bitbucket_ipv4_cidrs\n}\n\noutput &quot;ipv6_cidrs&quot; {\n  value = local.bitbucket_ipv6_cidrs\n}\n</code></pre>\n", "OwnerUserId": "12000049", "LastEditorUserId": "1242922", "LastEditDate": "2021-01-29T13:54:59.200", "LastActivityDate": "2021-01-29T13:54:59.200", "CommentCount": "3", "ContentLicense": "CC BY-SA 4.0", "comments": [{"Id": "116579935", "PostId": "65926851", "Score": "1", "Text": "Happy to hear :) Amazing, thanks for the improvement, very clear. Is it possible to control when to fetch the list anew? I assume it will do so on every tf apply.", "CreationDate": "2021-01-28T11:28:06.633", "UserId": "1242922", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "116606983", "PostId": "65926851", "Score": "1", "Text": "I took the liberty to edit your post to give it more a standalone-answer feeling than a thread-discussion. :)", "CreationDate": "2021-01-29T09:03:24.290", "UserId": "1242922", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "116614973", "PostId": "65926851", "Score": "1", "Text": "You assume correctly! The data lookup would run every time in this implementation. Skipping it (i.e. with a control variable and a ternary `count` on the `data` lookup) would result in an empty value when the referring resource calls it, and Terraform would see \n all of the Bitbucket CIDRs as drift to be removed. If your use case calls for strict control over when changes are introduced, then the manual scrape/hard-coded JSON method would be a better choice.", "CreationDate": "2021-01-29T14:11:37.063", "UserId": "12000049", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "If your use case calls for strict control over when changes are introduced, then the manual scrape/hard-coded JSON method would be a better choice.", "keywords": ["change"]}]}], "history": [{"Id": "239629503", "PostHistoryTypeId": "2", "PostId": "65926851", "RevisionGUID": "2b0eda76-4d66-4f7e-9efb-a53a755bbb5a", "CreationDate": "2021-01-27T20:26:10.983", "UserId": "12000049", "Text": "Wanted to leave this as a comment, but it was too long. Totally used your answer to deal with this issue today (thanks, by the way. You saved me a ton of time!), and wanted to add that TF's http provider can fetch the JSON for you, and, with a slight tweak to the `jsondecode()` call, that same `for` loop still plays.\r\n\r\n```hcl\r\nprovider \"http\" {}\r\n\r\ndata \"http\" \"bitbucket_ips\" {\r\n  url = \"https://ip-ranges.atlassian.com/\"\r\n\r\n  request_headers = {\r\n    Accept = \"application/json\"\r\n  }\r\n}\r\n\r\nlocals {\r\n  bitbucket_ipv4_cidrs = [for c in jsondecode(data.http.bitbucket_ips.body).items : c.cidr if length(regexall(\":\", c.cidr)) == 0]\r\n  bitbucket_ipv6_cidrs = [for c in jsondecode(data.http.bitbucket_ips.body).items : c.cidr if length(regexall(\":\", c.cidr)) > 0]\r\n}\r\n\r\noutput \"ipv4_cidrs\" {\r\n  value = local.bitbucket_ipv4_cidrs\r\n}\r\n\r\noutput \"ipv6_cidrs\" {\r\n  value = local.bitbucket_ipv6_cidrs\r\n}\r\n```\r\n\r\n", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "You saved me a ton of time!), and wanted to add that TF's http provider can fetch the JSON for you, and, with a slight tweak to the `jsondecode()` call, that same `for` loop still plays. ", "keywords": ["provider"]}, {"source": "Text", "text": "```hcl provider \"http\" {} data \"http\" \"bitbucket_ips\" { url = \"https://ip-ranges.atlassian.com/\" request_headers = { Accept = \"application/json\" } } locals { bitbucket_ipv4_cidrs = [for c in jsondecode(data.http.bitbucket_ips.body).items : c.cidr if length(regexall(\":\", c.cidr)) == 0] bitbucket_ipv6_cidrs = [for c in jsondecode(data.http.bitbucket_ips.body).items : c.cidr if length(regexall(\":\", c.cidr)) > 0] } output \"ipv4_cidrs\" { value = local.bitbucket_ipv4_cidrs } output \"ipv6_cidrs\" { value = local.bitbucket_ipv6_cidrs ", "keywords": ["provider"]}]}, {"Id": "239749570", "PostHistoryTypeId": "5", "PostId": "65926851", "RevisionGUID": "fde45680-b9f0-46aa-95e4-e2af7719cae5", "CreationDate": "2021-01-29T13:54:59.200", "UserId": "1242922", "Comment": "Changed text to give it more of a stand-alone characteristic instead of a thread discussion, so I can accept it as the solution. I am the author the 'Thanks' was directed to.", "Text": "I improved on Richard's answer and wanted to add that TF's http provider can fetch the JSON for you, and, with a slight tweak to the `jsondecode()` call, that same `for` loop still plays.\r\n\r\n```hcl\r\nprovider \"http\" {}\r\n\r\ndata \"http\" \"bitbucket_ips\" {\r\n  url = \"https://ip-ranges.atlassian.com/\"\r\n\r\n  request_headers = {\r\n    Accept = \"application/json\"\r\n  }\r\n}\r\n\r\nlocals {\r\n  bitbucket_ipv4_cidrs = [for c in jsondecode(data.http.bitbucket_ips.body).items : c.cidr if length(regexall(\":\", c.cidr)) == 0]\r\n  bitbucket_ipv6_cidrs = [for c in jsondecode(data.http.bitbucket_ips.body).items : c.cidr if length(regexall(\":\", c.cidr)) > 0]\r\n}\r\n\r\noutput \"ipv4_cidrs\" {\r\n  value = local.bitbucket_ipv4_cidrs\r\n}\r\n\r\noutput \"ipv6_cidrs\" {\r\n  value = local.bitbucket_ipv6_cidrs\r\n}\r\n```\r\n\r\n", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "I improved on Richard's answer and wanted to add that TF's http provider can fetch the JSON for you, and, with a slight tweak to the `jsondecode()` call, that same `for` loop still plays. ", "keywords": ["provider"]}, {"source": "Text", "text": "```hcl provider \"http\" {} data \"http\" \"bitbucket_ips\" { url = \"https://ip-ranges.atlassian.com/\" request_headers = { Accept = \"application/json\" } } locals { bitbucket_ipv4_cidrs = [for c in jsondecode(data.http.bitbucket_ips.body).items : c.cidr if length(regexall(\":\", c.cidr)) == 0] bitbucket_ipv6_cidrs = [for c in jsondecode(data.http.bitbucket_ips.body).items : c.cidr if length(regexall(\":\", c.cidr)) > 0] } output \"ipv4_cidrs\" { value = local.bitbucket_ipv4_cidrs } output \"ipv6_cidrs\" { value = local.bitbucket_ipv6_cidrs ", "keywords": ["provider"]}, {"source": "Comment", "text": "Changed text to give it more of a stand-alone characteristic instead of a thread discussion, so I can accept it as the solution. ", "keywords": ["change"]}]}, {"Id": "239749571", "PostHistoryTypeId": "24", "PostId": "65926851", "RevisionGUID": "fde45680-b9f0-46aa-95e4-e2af7719cae5", "CreationDate": "2021-01-29T13:54:59.200", "Comment": "Proposed by 1242922 approved by 1364007, 12000049 edit id of 5076765", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "filtered-sentences": [{"source": "Body", "text": "I improved on Richard's answer and wanted to add that TF's http provider can fetch the JSON for you, and, with a slight tweak to the jsondecode() call, that same for loop still plays.", "keywords": ["provider"]}]}], "contains-topic": true, "filtered-sentences": [{"source": "Body", "text": "We want Bitbucket webhooks to trigger our CI tool which runs on an AWS EC2 instance, protected with ingress rules from general access. ", "keywords": ["instance"]}, {"source": "Body", "text": "I wonder, what is an efficient approach to add and maintain this list in AWS EC2 security groups, e.g. via terraform.", "keywords": ["efficient"]}]}