{"Id": "55645831", "PostTypeId": "1", "AcceptedAnswerId": "55646887", "CreationDate": "2019-04-12T06:38:06.070", "Score": "3", "ViewCount": "5082", "Body": "<p>My team uses AWS for our infrastructure, across 3 <a href=\"https://aws.amazon.com/answers/account-management/aws-multi-account-billing-strategy/\" rel=\"nofollow noreferrer\">different AWS accounts</a>. We'll call them simply <code>sandbox</code>, <code>staging</code>, and <code>production</code>.</p>\n\n<p>I recently set up Terraform against our AWS infrastructure, and its hierarchy maps against our accounts, then by either application, or AWS service itself. The repo structure looks something like this:</p>\n\n<pre><code>staging\n  iam\n    groups\n      main.tf\n    users\n      main.tf\n  s3\n    main.tf\nsandbox\n  iam\n    ...\nproduction\n  applications\n    gitlab\n      main.tf\n  route53\n    main.tf\n  ...\n</code></pre>\n\n<p>We're using separate configurations per AWS service (e.g., IAM or S3) or application (e.g., GitLab) so we don't end up with huge <code>.tf</code> files per account that would take a long time to apply updates for any one change. Ideally, we'd like to move away from the service-based configuration approach and move towards more application-based configurations, but the problem at hand remains the same either way.</p>\n\n<p>This approach has been working fine when applying updates manually from the command line, but I'd love to move it to GitLab CI/CD to better automate our workflow, and that's where things have broken down.</p>\n\n<p>In my existing setup, if I make an single change to, say, <code>staging/s3/main.tf</code>, GitLab doesn't seem to have a good way out of the box to only run <code>terraform plan</code> or <code>terraform apply</code> for that specific configuration.</p>\n\n<p>If I instead moved everything into a single <code>main.tf</code> file for an entire AWS account (or multiple files but tied to a single state file), I could simply have GitLab trigger a job to do <code>plan</code> or <code>apply</code> to just that configuration. It might take 15 minutes to run based on the number of AWS resources we have in each account, but it's a potential option I suppose.</p>\n\n<p>It seems like my issue might be ultimately related to how GitLab handles \"monorepos\" than how Terraform handles its workflow (after all, Terraform will happily plan/apply my changes if I simply tell it <em>what</em> has changed), although I'd also be interested in hearing about how people structure their Terraform environments given -- or in order to avoid entirely -- these limitations.</p>\n\n<p>Has anyone solved an issue like this in their environment?</p>\n", "OwnerUserId": "672039", "LastActivityDate": "2019-04-12T07:50:56.913", "Title": "Effective GitLab CI/CD workflow with multiple Terraform configurations?", "Tags": "<continuous-integration><gitlab><terraform>", "AnswerCount": "1", "CommentCount": "0", "FavoriteCount": "0", "ContentLicense": "CC BY-SA 4.0", "history": [{"Id": "195644157", "PostHistoryTypeId": "2", "PostId": "55645831", "RevisionGUID": "819c3a61-733e-4f00-831e-016e7226d0b6", "CreationDate": "2019-04-12T06:38:06.070", "UserId": "672039", "Text": "My team uses AWS for our infrastructure, across 3 [different AWS accounts](https://aws.amazon.com/answers/account-management/aws-multi-account-billing-strategy/). We'll call them simply `sandbox`, `staging`, and `production`.\r\n\r\nI recently set up Terraform against our AWS infrastructure, and its hierarchy maps against our accounts, then by either application, or AWS service itself. The repo structure looks something like this:\r\n\r\n```\r\nstaging\r\n  iam\r\n    groups\r\n      main.tf\r\n    users\r\n      main.tf\r\n  s3\r\n    main.tf\r\nsandbox\r\n  iam\r\n    ...\r\nproduction\r\n  applications\r\n    gitlab\r\n      main.tf\r\n  route53\r\n    main.tf\r\n  ...\r\n```\r\n\r\nWe're using separate configurations per AWS service (e.g., IAM or S3) or application (e.g., GitLab) so we don't end up with huge `.tf` files per account that would take a long time to apply updates for any one change. Ideally, we'd like to move away from the service-based configuration approach and move towards more application-based configurations, but the problem at hand remains the same either way.\r\n\r\nThis approach has been working fine when applying updates manually from the command line, but I'd love to move it to GitLab CI/CD to better automate our workflow, and that's where things have broken down.\r\n\r\nIn my existing setup, if I make an single change to, say, `staging/s3/main.tf`, GitLab doesn't seem to have a good way out of the box to only run `terraform plan` or `terraform apply` for that specific configuration.\r\n\r\nIf I instead moved everything into a single `main.tf` file for an entire AWS account (or multiple files but tied to a single state file), I could simply have GitLab trigger a job to do `plan` or `apply` to just that configuration. It might take 15 minutes to run based on the number of AWS resources we have in each account, but it's a potential option I suppose.\r\n\r\nIt seems like my issue might be ultimately related to how GitLab handles \"monorepos\" than how Terraform handles its workflow (after all, Terraform will happily plan/apply my changes if I simply tell it _what_ has changed), although I'd also be interested in hearing about how people structure their Terraform environments given -- or in order to avoid entirely -- these limitations.\r\n\r\nHas anyone solved an issue like this in their environment?", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "My team uses AWS for our infrastructure, across 3 [different AWS accounts](https://aws.amazon.com/answers/account-management/aws-multi-account-billing-strategy/). ", "keywords": ["bill"]}, {"source": "Text", "text": "We're using separate configurations per AWS service (e.g., IAM or S3) or application (e.g., GitLab) so we don't end up with huge `.tf` files per account that would take a long time to apply updates for any one change. ", "keywords": ["change"]}, {"source": "Text", "text": "In my existing setup, if I make an single change to, say, `staging/s3/main.tf`, GitLab doesn't seem to have a good way out of the box to only run `terraform plan` or `terraform apply` for that specific configuration. ", "keywords": ["change"]}, {"source": "Text", "text": "It seems like my issue might be ultimately related to how GitLab handles \"monorepos\" than how Terraform handles its workflow (after all, Terraform will happily plan/apply my changes if I simply tell it _what_ has changed), although I'd also be interested in hearing about how people structure their Terraform environments given -- or in order to avoid entirely -- these limitations. ", "keywords": ["change"]}]}, {"Id": "195644158", "PostHistoryTypeId": "1", "PostId": "55645831", "RevisionGUID": "819c3a61-733e-4f00-831e-016e7226d0b6", "CreationDate": "2019-04-12T06:38:06.070", "UserId": "672039", "Text": "Effective GitLab CI/CD workflow with multiple Terraform configurations?", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "195644159", "PostHistoryTypeId": "3", "PostId": "55645831", "RevisionGUID": "819c3a61-733e-4f00-831e-016e7226d0b6", "CreationDate": "2019-04-12T06:38:06.070", "UserId": "672039", "Text": "<continuous-integration><gitlab><terraform>", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "answers": [{"Id": "55646887", "PostTypeId": "2", "ParentId": "55645831", "CreationDate": "2019-04-12T07:50:56.913", "Score": "8", "Body": "<p>The nice thing about Terraform is that it's idempotent so you can just apply even if nothing has changed and it will be a no-op action anyway.</p>\n\n<p>If for some reason you really only want to run a plan/apply on a specific directory when things change then you can achieve this by using <a href=\"https://docs.gitlab.com/ee/ci/yaml/#onlychangesexceptchanges\" rel=\"noreferrer\"><code>only.changes</code></a> so that Gitlab will only run the job if the specified files have changed.</p>\n\n<p>So if you have your existing structure then it's as simple as doing something like this:</p>\n\n<pre><code>stages:\n  - terraform plan\n  - terraform apply\n\n.terraform_template:\n  image: hashicorp/terraform:latest\n  before_script:\n    - LOCATION=$(echo ${CI_JOB_NAME} | cut -d\":\" -f2)\n    - cd ${LOCATION}\n    - terraform init\n\n.terraform_plan_template:\n  stage: terraform plan\n  extends: .terraform_template\n  script:\n    - terraform plan -input=false -refresh=true -module-depth=-1 .\n\n.terraform_apply_template:\n  stage: terraform apply\n  extends: .terraform_template\n  script:\n    - terraform apply -input=false -refresh=true -auto-approve=true .\n\nterraform-plan:production/applications/gitlab:\n  extends: .terraform_plan_template\n  only:\n    refs:\n      - master\n    changes:\n      - production/applications/gitlab/*\n      - modules/gitlab/*\n\nterraform-apply:production/applications/gitlab:\n  extends: .terraform_apply_template\n  only:\n    refs:\n      - master\n    changes:\n      - production/applications/gitlab/*\n      - modules/gitlab/*\n</code></pre>\n\n<p>I've also assumed the existence of modules that are in a shared location to indicate how this pattern can also look for changes elsewhere in the repo than just the directory you are running Terraform against.</p>\n\n<p>If this isn't the case and you have a flatter structure and you're happy to have a single apply job then you can simplify this to something like:</p>\n\n<pre><code>stages:\n  - terraform\n\n.terraform_template:\n  image: hashicorp/terraform:latest\n  stage: terraform\n  before_script:\n    - LOCATION=$(echo ${CI_JOB_NAME} | cut -d\":\" -f2)\n    - cd ${LOCATION}\n    - terraform init\n  script:\n    - terraform apply -input=false -refresh=true -auto-approve=true .\n  only:\n    refs:\n      - master\n    changes:\n      - ${CI_JOB_NAME}/*\n\nproduction/applications/gitlab:\n  extends: .terraform_template\n</code></pre>\n\n<p>In general though this can just be avoided by allowing Terraform to run against all of the appropriate directories on every push (probably only applying on push to master or other appropriate branch) because, as mentioned, Terraform is idempotent so it won't do anything if nothing has changed. This also has the benefit that if your automation code hasn't changed but something has changed in your provider (such as someone opening up a security group) then Terraform will go put it back to how it should be the next time it is triggered.</p>\n", "OwnerUserId": "2291321", "LastActivityDate": "2019-04-12T07:50:56.913", "CommentCount": "3", "ContentLicense": "CC BY-SA 4.0", "comments": [{"Id": "97984131", "PostId": "55646887", "Score": "0", "Text": "Great call! I totally forgot about the idempotent nature, but that makes sense. Having said that, how would you accomplish a single `plan` or `apply` across the entirety of my many configs? Since there's no \"base\" config at the root of the repo, would you just propose a simple `for` loop looking for `.tf` files? It looks like there's a way to do this by recursively including `module`s, but that might be a lot of work.", "CreationDate": "2019-04-12T08:32:12.247", "UserId": "672039", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "97985227", "PostId": "55646887", "Score": "0", "Text": "I wouldn't ever apply things in a single go. The entire point of splitting things into different locations is because you want to limit blast radius or you want to focus on a specific application/environment. Bundling it all into a single CI job seems like a very bad idea to me. If you're worried about having lots of CI jobs to define because you have lots of different directories you'd like to run Terraform against then you could look at generating your `.gitlab-ci.yml` file instead of writing out the CI jobs by hand.", "CreationDate": "2019-04-12T09:07:30.033", "UserId": "2291321", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "97990010", "PostId": "55646887", "Score": "0", "Text": "My apologies, I think I see what you're saying: define one CI job per Terraform config and -- ideally -- have GitLab automatically run all of them on push to `master` (since unchanged configs should be a no-op). Or scope each job using `only.changes`, but with the downside that it adds complexity and loses the ability to sync changes made outside of Terraform to non-committed configs. Even if I'm misinterpreting things, your answer provides a wealth of information to go off of. Thanks!", "CreationDate": "2019-04-12T11:34:23.080", "UserId": "672039", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "Or scope each job using `only.changes`, but with the downside that it adds complexity and loses the ability to sync changes made outside of Terraform to non-committed configs. ", "keywords": ["change"]}]}], "history": [{"Id": "195648537", "PostHistoryTypeId": "2", "PostId": "55646887", "RevisionGUID": "abbbc5fd-f269-47ba-bd05-c1985cba5179", "CreationDate": "2019-04-12T07:50:56.913", "UserId": "2291321", "Text": "The nice thing about Terraform is that it's idempotent so you can just apply even if nothing has changed and it will be a no-op action anyway.\r\n\r\nIf for some reason you really only want to run a plan/apply on a specific directory when things change then you can achieve this by using [`only.changes`][1] so that Gitlab will only run the job if the specified files have changed.\r\n\r\nSo if you have your existing structure then it's as simple as doing something like this:\r\n\r\n```yaml\r\nstages:\r\n  - terraform plan\r\n  - terraform apply\r\n\r\n.terraform_template:\r\n  image: hashicorp/terraform:latest\r\n  before_script:\r\n    - LOCATION=$(echo ${CI_JOB_NAME} | cut -d\":\" -f2)\r\n    - cd ${LOCATION}\r\n    - terraform init\r\n\r\n.terraform_plan_template:\r\n  stage: terraform plan\r\n  extends: .terraform_template\r\n  script:\r\n    - terraform plan -input=false -refresh=true -module-depth=-1 .\r\n\r\n.terraform_apply_template:\r\n  stage: terraform apply\r\n  extends: .terraform_template\r\n  script:\r\n    - terraform apply -input=false -refresh=true -auto-approve=true .\r\n\r\nterraform-plan:production/applications/gitlab:\r\n  extends: .terraform_plan_template\r\n  only:\r\n    refs:\r\n      - master\r\n    changes:\r\n      - production/applications/gitlab/*\r\n      - modules/gitlab/*\r\n\r\nterraform-apply:production/applications/gitlab:\r\n  extends: .terraform_apply_template\r\n  only:\r\n    refs:\r\n      - master\r\n    changes:\r\n      - production/applications/gitlab/*\r\n      - modules/gitlab/*\r\n```\r\n\r\nI've also assumed the existence of modules that are in a shared location to indicate how this pattern can also look for changes elsewhere in the repo than just the directory you are running Terraform against.\r\n\r\nIf this isn't the case and you have a flatter structure and you're happy to have a single apply job then you can simplify this to something like:\r\n\r\n```yaml\r\nstages:\r\n  - terraform\r\n\r\n.terraform_template:\r\n  image: hashicorp/terraform:latest\r\n  stage: terraform\r\n  before_script:\r\n    - LOCATION=$(echo ${CI_JOB_NAME} | cut -d\":\" -f2)\r\n    - cd ${LOCATION}\r\n    - terraform init\r\n  script:\r\n    - terraform apply -input=false -refresh=true -auto-approve=true .\r\n  only:\r\n    refs:\r\n      - master\r\n    changes:\r\n      - ${CI_JOB_NAME}/*\r\n\r\nproduction/applications/gitlab:\r\n  extends: .terraform_template\r\n```\r\n\r\nIn general though this can just be avoided by allowing Terraform to run against all of the appropriate directories on every push (probably only applying on push to master or other appropriate branch) because, as mentioned, Terraform is idempotent so it won't do anything if nothing has changed. This also has the benefit that if your automation code hasn't changed but something has changed in your provider (such as someone opening up a security group) then Terraform will go put it back to how it should be the next time it is triggered.\r\n\r\n  [1]: https://docs.gitlab.com/ee/ci/yaml/#onlychangesexceptchanges", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "The nice thing about Terraform is that it's idempotent so you can just apply even if nothing has changed and it will be a no-op action anyway. ", "keywords": ["change"]}, {"source": "Text", "text": "If for some reason you really only want to run a plan/apply on a specific directory when things change then you can achieve this by using [`only.changes`][1] so that Gitlab will only run the job if the specified files have changed. ", "keywords": ["change"]}, {"source": "Text", "text": "So if you have your existing structure then it's as simple as doing something like this: ```yaml stages: - terraform plan - terraform apply .terraform_template: image: hashicorp/terraform:latest before_script: - LOCATION=$(echo ${CI_JOB_NAME} | cut -d\":\" -f2) - cd ${LOCATION} - terraform init .terraform_plan_template: stage: terraform plan extends: .terraform_template script: - terraform plan -input=false -refresh=true -module-depth=-1 . .terraform_apply_template: stage: terraform apply extends: .terraform_template script: - terraform apply -input=false -refresh=true -auto-approve=true . terraform-plan:production/applications/gitlab: extends: .terraform_plan_template only: refs: - master changes: - production/applications/gitlab/* - modules/gitlab/* terraform-apply:production/applications/gitlab: extends: .terraform_apply_template only: refs: - master changes: - production/applications/gitlab/* - modules/gitlab/* ``` ", "keywords": ["change"]}, {"source": "Text", "text": "I've also assumed the existence of modules that are in a shared location to indicate how this pattern can also look for changes elsewhere in the repo than just the directory you are running Terraform against. ", "keywords": ["change"]}, {"source": "Text", "text": "If this isn't the case and you have a flatter structure and you're happy to have a single apply job then you can simplify this to something like: ```yaml stages: - terraform .terraform_template: image: hashicorp/terraform:latest stage: terraform before_script: - LOCATION=$(echo ${CI_JOB_NAME} | cut -d\":\" -f2) - cd ${LOCATION} - terraform init script: - terraform apply -input=false -refresh=true -auto-approve=true . only: refs: - master changes: - ${CI_JOB_NAME}/* production/applications/gitlab: extends: .terraform_template ``` ", "keywords": ["change"]}, {"source": "Text", "text": "In general though this can just be avoided by allowing Terraform to run against all of the appropriate directories on every push (probably only applying on push to master or other appropriate branch) because, as mentioned, Terraform is idempotent so it won't do anything if nothing has changed. ", "keywords": ["change"]}, {"source": "Text", "text": "This also has the benefit that if your automation code hasn't changed but something has changed in your provider (such as someone opening up a security group) then Terraform will go put it back to how it should be the next time it is triggered. ", "keywords": ["provider", "change"]}]}], "filtered-sentences": [{"source": "Body", "text": "The nice thing about Terraform is that it's idempotent so you can just apply even if nothing has changed and it will be a no-op action anyway. ", "keywords": ["change"]}, {"source": "Body", "text": "If for some reason you really only want to run a plan/apply on a specific directory when things change then you can achieve this by using only.changes so that Gitlab will only run the job if the specified files have changed. ", "keywords": ["change"]}, {"source": "Body", "text": "So if you have your existing structure then it's as simple as doing something like this: I've also assumed the existence of modules that are in a shared location to indicate how this pattern can also look for changes elsewhere in the repo than just the directory you are running Terraform against. ", "keywords": ["change"]}, {"source": "Body", "text": "In general though this can just be avoided by allowing Terraform to run against all of the appropriate directories on every push (probably only applying on push to master or other appropriate branch) because, as mentioned, Terraform is idempotent so it won't do anything if nothing has changed. ", "keywords": ["change"]}, {"source": "Body", "text": "This also has the benefit that if your automation code hasn't changed but something has changed in your provider (such as someone opening up a security group) then Terraform will go put it back to how it should be the next time it is triggered.", "keywords": ["provider", "change"]}]}], "contains-topic": true, "filtered-sentences": [{"source": "Body", "text": "The repo structure looks something like this: We're using separate configurations per AWS service (e.g., IAM or S3) or application (e.g., GitLab) so we don't end up with huge .tf files per account that would take a long time to apply updates for any one change. ", "keywords": ["change"]}, {"source": "Body", "text": "In my existing setup, if I make an single change to, say, staging/s3/main.tf, GitLab doesn't seem to have a good way out of the box to only run terraform plan or terraform apply for that specific configuration. ", "keywords": ["change"]}, {"source": "Body", "text": "It seems like my issue might be ultimately related to how GitLab handles \"monorepos\" than how Terraform handles its workflow (after all, Terraform will happily plan/apply my changes if I simply tell it what has changed), although I'd also be interested in hearing about how people structure their Terraform environments given -- or in order to avoid entirely -- these limitations. ", "keywords": ["change"]}]}