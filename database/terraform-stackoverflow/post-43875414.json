{"Id": "43875414", "PostTypeId": "1", "AcceptedAnswerId": "43882252", "CreationDate": "2017-05-09T16:39:09.977", "Score": "4", "ViewCount": "7189", "Body": "<p>I'm creating cloud resources using Terraform. Each resource is expected to be in a particular desired state after provisioning. For example, when I create a Google Cloud Bucket, I would like certain permissions to be applied automatically. So, my plan contains necessary code for this but I wanted to make sure that this works all the time regardless before I apply. Is there any testing tool/library that can help here?</p>\n", "OwnerUserId": "1339422", "LastActivityDate": "2018-05-03T11:31:29.217", "Title": "How to test terraform templates other than trial and error", "Tags": "<terraform>", "AnswerCount": "3", "CommentCount": "1", "FavoriteCount": "0", "ContentLicense": "CC BY-SA 3.0", "comments": [{"Id": "74796934", "PostId": "43875414", "Score": "1", "Text": "`terraform plan` is not enough?", "CreationDate": "2017-05-09T22:47:30.593", "UserId": "1502378", "ContentLicense": "CC BY-SA 3.0", "filtered-sentences": []}], "history": [{"Id": "144993423", "PostHistoryTypeId": "2", "PostId": "43875414", "RevisionGUID": "41845d9d-2b8a-4a34-8614-05c9079882d8", "CreationDate": "2017-05-09T16:39:09.977", "UserId": "1339422", "Text": "I'm creating cloud resources using Terraform. Each resource is expected to be in a particular desired state after provisioning. For example, when I create a Google Cloud Bucket, I would like certain permissions to be applied automatically. So, my plan contains necessary code for this but I wanted to make sure that this works all the time regardless before I apply. Is there any testing tool/library that can help here?\r\n", "ContentLicense": "CC BY-SA 3.0", "filtered-sentences": [{"source": "Text", "text": "Is there any testing tool/library that can help here?", "keywords": ["test"]}]}, {"Id": "144993424", "PostHistoryTypeId": "1", "PostId": "43875414", "RevisionGUID": "41845d9d-2b8a-4a34-8614-05c9079882d8", "CreationDate": "2017-05-09T16:39:09.977", "UserId": "1339422", "Text": "How to test terraform templates other than trial and error", "ContentLicense": "CC BY-SA 3.0", "filtered-sentences": [{"source": "Text", "text": "How to test terraform templates other than trial and error", "keywords": ["test"]}]}, {"Id": "144993425", "PostHistoryTypeId": "3", "PostId": "43875414", "RevisionGUID": "41845d9d-2b8a-4a34-8614-05c9079882d8", "CreationDate": "2017-05-09T16:39:09.977", "UserId": "1339422", "Text": "<terraform>", "ContentLicense": "CC BY-SA 3.0", "filtered-sentences": []}], "answers": [{"Id": "43882252", "PostTypeId": "2", "ParentId": "43875414", "CreationDate": "2017-05-10T01:34:26.703", "Score": "6", "Body": "<p>Yes, I had the same thinking before. Currently, I use several ways to reduce the risk when I apply a new terraform change.</p>\n\n<p>They can't guarantee a 100% successful <code>terraform apply</code>, but will fix the most issues before you apply it. </p>\n\n<ol>\n<li>Validate terraform configuration files.</li>\n</ol>\n\n<p>Terraform has the <a href=\"https://www.terraform.io/docs/commands/validate.html\" rel=\"noreferrer\">validate function</a> for starting. But it is not smart enough to go through subfolders. I create a small shell function and add in CI/CD pipeline to run it automatically before <code>terraform apply</code>.</p>\n\n<pre><code>validate() {\n  modules=$(find . -type f -name \"*.tf\" -exec dirname {} \\;|sort -u)\n  for m in ${modules}\n  do\n    (terraform validate \"$m\" &amp;&amp; echo \"\u221a $m\") || exit 1\n  done\n}\n</code></pre>\n\n<p>Of course, do <code>terraform fmt</code> before you submit your change is not bad idea.</p>\n\n<ol start=\"2\">\n<li><a href=\"https://www.terraform.io/docs/commands/plan.html\" rel=\"noreferrer\">terraform plan</a></li>\n</ol>\n\n<p>@Martin Atkins explained it already, and <a href=\"https://www.terraform.io/\" rel=\"noreferrer\">terraform.io</a> has details about this command.</p>\n\n<ol start=\"3\">\n<li>run automation test kitchen.</li>\n</ol>\n\n<p>That's a test Kitchen plugin for testing Terraform configurations</p>\n\n<p><a href=\"https://github.com/newcontext-oss/kitchen-terraform\" rel=\"noreferrer\">https://github.com/newcontext-oss/kitchen-terraform</a></p>\n\n<p>That's an integration test. The test will run in separate VPC with as more as test cases you added. Add the automation test in CI/CD pipeline as well to trigger an automation test every time when you raise merge request to master branch. Apply the change only after getting the test passed.</p>\n", "OwnerUserId": "498256", "LastEditorUserId": "498256", "LastEditDate": "2017-05-10T01:39:35.240", "LastActivityDate": "2017-05-10T01:39:35.240", "CommentCount": "0", "ContentLicense": "CC BY-SA 3.0", "history": [{"Id": "145019317", "PostHistoryTypeId": "2", "PostId": "43882252", "RevisionGUID": "2efa3e12-a164-4897-b354-3ded660f1c7b", "CreationDate": "2017-05-10T01:34:26.703", "UserId": "498256", "Text": "Yes, I had the same thinking before. Currently, I use several ways to reduce the risk when I apply a new terraform change.\r\n\r\nThey can't guarantee a 100% successful `terraform apply`, but will fix the most issues before you apply it. \r\n\r\n1. Validate terraform configuration files.\r\n\r\nTerraform has the [validate function][1] for starting. I create a small shell function and add in CI/CD pipeline to run it automatically before `terraform apply`.\r\n\r\n    validate() {\r\n      modules=$(find . -type f -name \"*.tf\" -exec dirname {} \\;|sort -u)\r\n      for m in ${modules}\r\n      do\r\n        (terraform validate \"$m\" && echo \"\u221a $m\") || exit 1\r\n      done\r\n    }\r\n\r\n2. [terraform plan][2]\r\n\r\n@Martin Atkins explained it already, and [terraform.io][3] has details about this command.\r\n\r\n3. run automation test kitchen.\r\n\r\nThat's a test Kitchen plugin for testing Terraform configurations\r\n\r\nhttps://github.com/newcontext-oss/kitchen-terraform\r\n\r\nThe test will run in separate VPC with as more as test cases you added. Add it in CI/CD pipeline as well to trigger an automation test. Apply the change only get the test passed.\r\n\r\n\r\n  [1]: https://www.terraform.io/docs/commands/validate.html\r\n  [2]: https://www.terraform.io/docs/commands/plan.html\r\n  [3]: https://www.terraform.io/", "ContentLicense": "CC BY-SA 3.0", "filtered-sentences": [{"source": "Text", "text": "Currently, I use several ways to reduce the risk when I apply a new terraform change. ", "keywords": ["change"]}, {"source": "Text", "text": "3. run automation test kitchen. ", "keywords": ["test"]}, {"source": "Text", "text": "That's a test Kitchen plugin for testing Terraform configurations https://github.com/newcontext-oss/kitchen-terraform ", "keywords": ["test"]}, {"source": "Text", "text": "The test will run in separate VPC with as more as test cases you added. ", "keywords": ["test"]}, {"source": "Text", "text": "Add it in CI/CD pipeline as well to trigger an automation test. ", "keywords": ["test"]}, {"source": "Text", "text": "Apply the change only get the test passed. [1]: https://www.terraform.io/docs/commands/validate.html [2]: https://www.terraform.io/docs/commands/plan.html [3]: https://www.terraform.io/", "keywords": ["change", "test"]}]}, {"Id": "145019460", "PostHistoryTypeId": "5", "PostId": "43882252", "RevisionGUID": "d23a3ec4-83cf-4d93-8eae-34406f3247b6", "CreationDate": "2017-05-10T01:39:35.240", "UserId": "498256", "Comment": "added 82 characters in body", "Text": "Yes, I had the same thinking before. Currently, I use several ways to reduce the risk when I apply a new terraform change.\r\n\r\nThey can't guarantee a 100% successful `terraform apply`, but will fix the most issues before you apply it. \r\n\r\n1. Validate terraform configuration files.\r\n\r\nTerraform has the [validate function][1] for starting. But it is not smart enough to go through subfolders. I create a small shell function and add in CI/CD pipeline to run it automatically before `terraform apply`.\r\n\r\n    validate() {\r\n      modules=$(find . -type f -name \"*.tf\" -exec dirname {} \\;|sort -u)\r\n      for m in ${modules}\r\n      do\r\n        (terraform validate \"$m\" && echo \"\u221a $m\") || exit 1\r\n      done\r\n    }\r\n\r\nOf course, do `terraform fmt` before you submit your change is not bad idea.\r\n\r\n2. [terraform plan][2]\r\n\r\n@Martin Atkins explained it already, and [terraform.io][3] has details about this command.\r\n\r\n3. run automation test kitchen.\r\n\r\nThat's a test Kitchen plugin for testing Terraform configurations\r\n\r\nhttps://github.com/newcontext-oss/kitchen-terraform\r\n\r\nThat's an integration test. The test will run in separate VPC with as more as test cases you added. Add the automation test in CI/CD pipeline as well to trigger an automation test every time when you raise merge request to master branch. Apply the change only after getting the test passed.\r\n\r\n\r\n  [1]: https://www.terraform.io/docs/commands/validate.html\r\n  [2]: https://www.terraform.io/docs/commands/plan.html\r\n  [3]: https://www.terraform.io/", "ContentLicense": "CC BY-SA 3.0", "filtered-sentences": [{"source": "Text", "text": "Currently, I use several ways to reduce the risk when I apply a new terraform change. ", "keywords": ["change"]}, {"source": "Text", "text": "Of course, do `terraform fmt` before you submit your change is not bad idea. ", "keywords": ["change"]}, {"source": "Text", "text": "3. run automation test kitchen. ", "keywords": ["test"]}, {"source": "Text", "text": "That's a test Kitchen plugin for testing Terraform configurations https://github.com/newcontext-oss/kitchen-terraform That's an integration test. ", "keywords": ["test"]}, {"source": "Text", "text": "The test will run in separate VPC with as more as test cases you added. ", "keywords": ["test"]}, {"source": "Text", "text": "Add the automation test in CI/CD pipeline as well to trigger an automation test every time when you raise merge request to master branch. ", "keywords": ["test"]}, {"source": "Text", "text": "Apply the change only after getting the test passed. [1]: https://www.terraform.io/docs/commands/validate.html [2]: https://www.terraform.io/docs/commands/plan.html [3]: https://www.terraform.io/", "keywords": ["change", "test"]}]}], "filtered-sentences": [{"source": "Body", "text": "Currently, I use several ways to reduce the risk when I apply a new terraform change. ", "keywords": ["change"]}, {"source": "Body", "text": "Of course, do terraform fmt before you submit your change is not bad idea. ", "keywords": ["change"]}, {"source": "Body", "text": "run automation test kitchen. ", "keywords": ["test"]}, {"source": "Body", "text": "That's a test Kitchen plugin for testing Terraform configurations https://github.com/newcontext-oss/kitchen-terraform That's an integration test. ", "keywords": ["test"]}, {"source": "Body", "text": "The test will run in separate VPC with as more as test cases you added. ", "keywords": ["test"]}, {"source": "Body", "text": "Add the automation test in CI/CD pipeline as well to trigger an automation test every time when you raise merge request to master branch. ", "keywords": ["test"]}, {"source": "Body", "text": "Apply the change only after getting the test passed.", "keywords": ["change", "test"]}]}, {"Id": "43881262", "PostTypeId": "2", "ParentId": "43875414", "CreationDate": "2017-05-09T23:18:24.137", "Score": "3", "Body": "<p>The <code>terraform plan</code> command is intended to give a preview of what changes Terraform will make when the plan is applied, which is the closest we can get to testing a Terraform configuration without touching the \"real\" API.</p>\n\n<p>For situations where that isn't enough, it's common to deploy the same config multiple times with different states, thus allowing one to be used as a \"staging\" environment to test changes without affecting the primary environment. The <a href=\"https://www.terraform.io/docs/state/environments.html\" rel=\"nofollow noreferrer\">State Environments</a> feature added in Terraform 0.9 can make this easier, since the multiple environment states can be managed directly with Terraform CLI commands.</p>\n\n<p>When it comes to automated testing of the result, there is currently no full solution to this integrated into Terraform, but there are some building blocks that could be useful to assist in writing tests in a separate programming language.</p>\n\n<p>Terraform produces state files in JSON format that can, in principle, be used by external programs to extract certain data about what Terraform created. While this format is not yet considered officially stable, in practice it changes infrequently enough that people have successfully integrated with it, accepting that they might need to make adjustments as they upgrade Terraform.</p>\n\n<p>What strategy is appropriate here will depend a lot on what exactly you want to test. For example:</p>\n\n<ul>\n<li><p>In an environment that's spinning up virtual servers, tools like <a href=\"http://serverspec.org/\" rel=\"nofollow noreferrer\">Serverspec</a> can be used to run tests from the perspective of these servers. This can either be run separately from Terraform using some out-of-band process, or as part of the Terraform apply using the <a href=\"https://www.terraform.io/docs/provisioners/remote-exec.html\" rel=\"nofollow noreferrer\"><code>remote-exec</code> provisioner</a>. This allows verification of questions like \"can the server reach the database?\", but is not suitable for questions such as \"is the instance's security group restrictive enough?\", since robustly checking that requires accessing data from outside of the instance itself.</p></li>\n<li><p>It's possible to write tests using an existing test framework (such as RSpec for Ruby, <code>unittest</code> for Python, etc) which gather relevant resource ids or addresses from the Terraform state file and then use the relevant platform's SDK to retrieve data about the resources and assert that they are set up as expected. This is a more general form of the previous idea, running the tests from the perspective of a host <em>outside</em> of the infrastructure under test, and can thus collect a broader set of data to make assertions on.</p></li>\n<li><p>For more modest needs, one can choose to trust that the Terraform state is an accurate representation of reality (a valid assumption in many cases) and simply assert directly on that. This is most appropriate for simple \"lint-like\" cases, such as verifying that the correct resource tagging scheme is being followed for cost-allocation purposes.</p></li>\n</ul>\n\n<p>There is some more discussion about this in <a href=\"https://github.com/hashicorp/terraform/issues/5059\" rel=\"nofollow noreferrer\">a relevant Terraform Github issue</a>.</p>\n\n<p>In the latest versions of Terraform it is strongly recommended to use a remote backend for any non-toy application, but that means that the state data is not directly available on local disk. However, a snapshot of it can be retrieved from the remote backend using the <code>terraform state pull</code> command, which prints the JSON-formatted state data to stdout so it can be captured and parsed by a calling program.</p>\n", "OwnerUserId": "281848", "LastActivityDate": "2017-05-09T23:18:24.137", "CommentCount": "0", "ContentLicense": "CC BY-SA 3.0", "history": [{"Id": "145015423", "PostHistoryTypeId": "2", "PostId": "43881262", "RevisionGUID": "904504a9-bea7-4568-8825-5d2743e9a7bf", "CreationDate": "2017-05-09T23:18:24.137", "UserId": "281848", "Text": "The `terraform plan` command is intended to give a preview of what changes Terraform will make when the plan is applied, which is the closest we can get to testing a Terraform configuration without touching the \"real\" API.\r\n\r\nFor situations where that isn't enough, it's common to deploy the same config multiple times with different states, thus allowing one to be used as a \"staging\" environment to test changes without affecting the primary environment. The [State Environments](https://www.terraform.io/docs/state/environments.html) feature added in Terraform 0.9 can make this easier, since the multiple environment states can be managed directly with Terraform CLI commands.\r\n\r\nWhen it comes to automated testing of the result, there is currently no full solution to this integrated into Terraform, but there are some building blocks that could be useful to assist in writing tests in a separate programming language.\r\n\r\nTerraform produces state files in JSON format that can, in principle, be used by external programs to extract certain data about what Terraform created. While this format is not yet considered officially stable, in practice it changes infrequently enough that people have successfully integrated with it, accepting that they might need to make adjustments as they upgrade Terraform.\r\n\r\nWhat strategy is appropriate here will depend a lot on what exactly you want to test. For example:\r\n\r\n* In an environment that's spinning up virtual servers, tools like [Serverspec](http://serverspec.org/) can be used to run tests from the perspective of these servers. This can either be run separately from Terraform using some out-of-band process, or as part of the Terraform apply using the [`remote-exec` provisioner](https://www.terraform.io/docs/provisioners/remote-exec.html). This allows verification of questions like \"can the server reach the database?\", but is not suitable for questions such as \"is the instance's security group restrictive enough?\", since robustly checking that requires accessing data from outside of the instance itself.\r\n\r\n* It's possible to write tests using an existing test framework (such as RSpec for Ruby, `unittest` for Python, etc) which gather relevant resource ids or addresses from the Terraform state file and then use the relevant platform's SDK to retrieve data about the resources and assert that they are set up as expected. This is a more general form of the previous idea, running the tests from the perspective of a host *outside* of the infrastructure under test, and can thus collect a broader set of data to make assertions on.\r\n\r\n* For more modest needs, one can choose to trust that the Terraform state is an accurate representation of reality (a valid assumption in many cases) and simply assert directly on that. This is most appropriate for simple \"lint-like\" cases, such as verifying that the correct resource tagging scheme is being followed for cost-allocation purposes.\r\n\r\nThere is some more discussion about this in [a relevant Terraform Github issue](https://github.com/hashicorp/terraform/issues/5059).\r\n\r\nIn the latest versions of Terraform it is strongly recommended to use a remote backend for any non-toy application, but that means that the state data is not directly available on local disk. However, a snapshot of it can be retrieved from the remote backend using the `terraform state pull` command, which prints the JSON-formatted state data to stdout so it can be captured and parsed by a calling program.\r\n", "ContentLicense": "CC BY-SA 3.0", "filtered-sentences": [{"source": "Text", "text": "The `terraform plan` command is intended to give a preview of what changes Terraform will make when the plan is applied, which is the closest we can get to testing a Terraform configuration without touching the \"real\" API. ", "keywords": ["change", "test"]}, {"source": "Text", "text": "For situations where that isn't enough, it's common to deploy the same config multiple times with different states, thus allowing one to be used as a \"staging\" environment to test changes without affecting the primary environment. ", "keywords": ["change", "test"]}, {"source": "Text", "text": "The [State Environments](https://www.terraform.io/docs/state/environments.html) feature added in Terraform 0.9 can make this easier, since the multiple environment states can be managed directly with Terraform CLI commands. ", "keywords": ["feature"]}, {"source": "Text", "text": "When it comes to automated testing of the result, there is currently no full solution to this integrated into Terraform, but there are some building blocks that could be useful to assist in writing tests in a separate programming language. ", "keywords": ["test"]}, {"source": "Text", "text": "While this format is not yet considered officially stable, in practice it changes infrequently enough that people have successfully integrated with it, accepting that they might need to make adjustments as they upgrade Terraform. ", "keywords": ["change"]}, {"source": "Text", "text": "What strategy is appropriate here will depend a lot on what exactly you want to test. ", "keywords": ["test"]}, {"source": "Text", "text": "In an environment that's spinning up virtual servers, tools like [Serverspec](http://serverspec.org/) can be used to run tests from the perspective of these servers. ", "keywords": ["test"]}, {"source": "Text", "text": "This allows verification of questions like \"can the server reach the database?\", but is not suitable for questions such as \"is the instance's security group restrictive enough?\", since robustly checking that requires accessing data from outside of the instance itself. ", "keywords": ["instance"]}, {"source": "Text", "text": "* It's possible to write tests using an existing test framework (such as RSpec for Ruby, `unittest` for Python, etc) which gather relevant resource ids or addresses from the Terraform state file and then use the relevant platform's SDK to retrieve data about the resources and assert that they are set up as expected. ", "keywords": ["test"]}, {"source": "Text", "text": "This is a more general form of the previous idea, running the tests from the perspective of a host *outside* of the infrastructure under test, and can thus collect a broader set of data to make assertions on. ", "keywords": ["test"]}, {"source": "Text", "text": "This is most appropriate for simple \"lint-like\" cases, such as verifying that the correct resource tagging scheme is being followed for cost-allocation purposes. ", "keywords": ["cost"]}]}], "filtered-sentences": [{"source": "Body", "text": "The terraform plan command is intended to give a preview of what changes Terraform will make when the plan is applied, which is the closest we can get to testing a Terraform configuration without touching the \"real\" API. ", "keywords": ["change", "test"]}, {"source": "Body", "text": "For situations where that isn't enough, it's common to deploy the same config multiple times with different states, thus allowing one to be used as a \"staging\" environment to test changes without affecting the primary environment. ", "keywords": ["change", "test"]}, {"source": "Body", "text": "The State Environments feature added in Terraform 0.9 can make this easier, since the multiple environment states can be managed directly with Terraform CLI commands. ", "keywords": ["feature"]}, {"source": "Body", "text": "When it comes to automated testing of the result, there is currently no full solution to this integrated into Terraform, but there are some building blocks that could be useful to assist in writing tests in a separate programming language. ", "keywords": ["test"]}, {"source": "Body", "text": "While this format is not yet considered officially stable, in practice it changes infrequently enough that people have successfully integrated with it, accepting that they might need to make adjustments as they upgrade Terraform. ", "keywords": ["change"]}, {"source": "Body", "text": "What strategy is appropriate here will depend a lot on what exactly you want to test. ", "keywords": ["test"]}, {"source": "Body", "text": "For example: In an environment that's spinning up virtual servers, tools like Serverspec can be used to run tests from the perspective of these servers. ", "keywords": ["test"]}, {"source": "Body", "text": "This allows verification of questions like \"can the server reach the database?\", but is not suitable for questions such as \"is the instance's security group restrictive enough?\", since robustly checking that requires accessing data from outside of the instance itself. ", "keywords": ["instance"]}, {"source": "Body", "text": "It's possible to write tests using an existing test framework (such as RSpec for Ruby, unittest for Python, etc) which gather relevant resource ids or addresses from the Terraform state file and then use the relevant platform's SDK to retrieve data about the resources and assert that they are set up as expected. ", "keywords": ["test"]}, {"source": "Body", "text": "This is a more general form of the previous idea, running the tests from the perspective of a host outside of the infrastructure under test, and can thus collect a broader set of data to make assertions on. ", "keywords": ["test"]}, {"source": "Body", "text": "This is most appropriate for simple \"lint-like\" cases, such as verifying that the correct resource tagging scheme is being followed for cost-allocation purposes. ", "keywords": ["cost"]}]}, {"Id": "50154034", "PostTypeId": "2", "ParentId": "43875414", "CreationDate": "2018-05-03T11:31:29.217", "Score": "3", "Body": "<p>We recently open sourced <a href=\"https://blog.gruntwork.io/open-sourcing-terratest-a-swiss-army-knife-for-testing-infrastructure-code-5d883336fcd5\" rel=\"nofollow noreferrer\">Terratest</a>, our swiss army knife for testing infrastructure code. </p>\n\n<p>Today, you're probably testing all your infrastructure code manually by deploying, validating, and undeploying. Terratest helps you automate this process:</p>\n\n<ol>\n<li>Write tests in Go.</li>\n<li>Use helpers in Terratest to execute your real IaC tools (e.g., Terraform, Packer, etc.) to deploy real infrastructure (e.g., servers) in a real environment (e.g., AWS). Note that this environment would be a separate \"sandbox\" account and not prod! </li>\n<li>Use helpers in Terratest to validate that the infrastructure works correctly in that environment by making HTTP requests, API calls, SSH connections, etc.</li>\n<li>Use helpers in Terratest to undeploy everything at the end of the test.</li>\n</ol>\n\n<p>Here's an example test for some Terraform code:</p>\n\n<pre><code>terraformOptions := &amp;terraform.Options {\n  // The path to where your Terraform code is located\n  TerraformDir: \"../examples/terraform-basic-example\",\n}\n\n// This will run `terraform init` and `terraform apply` and fail the test if there are any errors\nterraform.InitAndApply(t, terraformOptions)\n\n// At the end of the test, run `terraform destroy` to clean up any resources that were created\ndefer terraform.Destroy(t, terraformOptions)\n\n// Run `terraform output` to get the value of an output variable\ninstanceUrl := terraform.Output(t, terraformOptions, \"instance_url\")\n\n// Verify that we get back a 200 OK with the expected text\n// It can take a minute or so for the Instance to boot up, so retry a few times\nexpected := \"Hello, World\"\nmaxRetries := 15\ntimeBetweenRetries := 5 * time.Second\nhttp_helper.HttpGetWithRetry(t, instanceUrl, 200, expected, maxRetries, timeBetweenRetries)\n</code></pre>\n\n<p>These are integration tests, and depending on what you're testing, can take 5 - 50 minutes. It's not fast (though using <a href=\"https://github.com/gruntwork-io/terratest#iterating-locally-using-docker\" rel=\"nofollow noreferrer\">Docker</a> and <a href=\"https://github.com/gruntwork-io/terratest#iterating-locally-using-test-stages\" rel=\"nofollow noreferrer\">test stages</a>, you can speed <em>some</em> things up), and you'll have to work to make the tests reliable, but it is well worth the time.</p>\n\n<p>Check out the <a href=\"https://github.com/gruntwork-io/terratest#iterating-locally-using-test-stages\" rel=\"nofollow noreferrer\">Terratest repo</a> for docs and lots of examples of various types of infrastructure code and the corresponding tests for them.</p>\n", "OwnerUserId": "483528", "LastActivityDate": "2018-05-03T11:31:29.217", "CommentCount": "0", "ContentLicense": "CC BY-SA 4.0", "history": [{"Id": "172624456", "PostHistoryTypeId": "2", "PostId": "50154034", "RevisionGUID": "9d2b2185-6c5c-41f3-9d8c-130cc107a85a", "CreationDate": "2018-05-03T11:31:29.217", "UserId": "483528", "Text": "We recently open sourced [Terratest](https://blog.gruntwork.io/open-sourcing-terratest-a-swiss-army-knife-for-testing-infrastructure-code-5d883336fcd5), our swiss army knife for testing infrastructure code. \r\n\r\nToday, you're probably testing all your infrastructure code manually by deploying, validating, and undeploying. Terratest helps you automate this process:\r\n\r\n1. Write tests in Go.\r\n1. Use helpers in Terratest to execute your real IaC tools (e.g., Terraform, Packer, etc.) to deploy real infrastructure (e.g., servers) in a real environment (e.g., AWS). Note that this environment would be a separate \"sandbox\" account and not prod! \r\n1. Use helpers in Terratest to validate that the infrastructure works correctly in that environment by making HTTP requests, API calls, SSH connections, etc.\r\n1. Use helpers in Terratest to undeploy everything at the end of the test.\r\n\r\nHere's an example test for some Terraform code:\r\n\r\n    terraformOptions := &terraform.Options {\r\n      // The path to where your Terraform code is located\r\n      TerraformDir: \"../examples/terraform-basic-example\",\r\n    }\r\n\r\n    // This will run `terraform init` and `terraform apply` and fail the test if there are any errors\r\n    terraform.InitAndApply(t, terraformOptions)\r\n\r\n    // At the end of the test, run `terraform destroy` to clean up any resources that were created\r\n    defer terraform.Destroy(t, terraformOptions)\r\n\r\n    // Run `terraform output` to get the value of an output variable\r\n    instanceUrl := terraform.Output(t, terraformOptions, \"instance_url\")\r\n\r\n    // Verify that we get back a 200 OK with the expected text\r\n    // It can take a minute or so for the Instance to boot up, so retry a few times\r\n    expected := \"Hello, World\"\r\n    maxRetries := 15\r\n    timeBetweenRetries := 5 * time.Second\r\n    http_helper.HttpGetWithRetry(t, instanceUrl, 200, expected, maxRetries, timeBetweenRetries)\r\n\r\nThese are integration tests, and depending on what you're testing, can take 5 - 50 minutes. It's not fast (though using [Docker](https://github.com/gruntwork-io/terratest#iterating-locally-using-docker) and [test stages](https://github.com/gruntwork-io/terratest#iterating-locally-using-test-stages), you can speed *some* things up), and you'll have to work to make the tests reliable, but it is well worth the time.\r\n\r\nCheck out the [Terratest repo](https://github.com/gruntwork-io/terratest#iterating-locally-using-test-stages) for docs and lots of examples of various types of infrastructure code and the corresponding tests for them.", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "We recently open sourced [Terratest](https://blog.gruntwork.io/open-sourcing-terratest-a-swiss-army-knife-for-testing-infrastructure-code-5d883336fcd5), our swiss army knife for testing infrastructure code. ", "keywords": ["test"]}, {"source": "Text", "text": "Today, you're probably testing all your infrastructure code manually by deploying, validating, and undeploying. ", "keywords": ["test"]}, {"source": "Text", "text": "Write tests in Go. 1. Use helpers in Terratest to execute your real IaC tools (e.g., Terraform, Packer, etc.) to deploy real infrastructure (e.g., servers) in a real environment (e.g., AWS). ", "keywords": ["test"]}, {"source": "Text", "text": "Use helpers in Terratest to undeploy everything at the end of the test. ", "keywords": ["test"]}, {"source": "Text", "text": "Here's an example test for some Terraform code: terraformOptions := &terraform.Options { // The path to where your Terraform code is located TerraformDir: \"../examples/terraform-basic-example\", } // This will run `terraform init` and `terraform apply` and fail the test if there are any errors terraform.InitAndApply(t, terraformOptions) // ", "keywords": ["test"]}, {"source": "Text", "text": "At the end of the test, run `terraform destroy` to clean up any resources that were created defer terraform.Destroy(t, terraformOptions) // Run `terraform output` to get the value of an output variable instanceUrl := terraform.Output(t, terraformOptions, \"instance_url\") // Verify that we get back a 200 OK with the expected text // ", "keywords": ["test"]}, {"source": "Text", "text": "It can take a minute or so for the Instance to boot up, so retry a few times expected := \"Hello, World\" maxRetries := 15 timeBetweenRetries := 5 * time.Second http_helper.HttpGetWithRetry(t, instanceUrl, 200, expected, maxRetries, timeBetweenRetries) ", "keywords": ["instance"]}, {"source": "Text", "text": "These are integration tests, and depending on what you're testing, can take 5 - 50 minutes. ", "keywords": ["test"]}, {"source": "Text", "text": "It's not fast (though using [Docker](https://github.com/gruntwork-io/terratest#iterating-locally-using-docker) and [test stages](https://github.com/gruntwork-io/terratest#iterating-locally-using-test-stages), you can speed *some* things up), and you'll have to work to make the tests reliable, but it is well worth the time. ", "keywords": ["test"]}, {"source": "Text", "text": "Check out the [Terratest repo](https://github.com/gruntwork-io/terratest#iterating-locally-using-test-stages) for docs and lots of examples of various types of infrastructure code and the corresponding tests for them.", "keywords": ["test"]}]}], "filtered-sentences": [{"source": "Body", "text": "We recently open sourced Terratest, our swiss army knife for testing infrastructure code. ", "keywords": ["test"]}, {"source": "Body", "text": "Today, you're probably testing all your infrastructure code manually by deploying, validating, and undeploying. ", "keywords": ["test"]}, {"source": "Body", "text": "Terratest helps you automate this process: Write tests in Go. ", "keywords": ["test"]}, {"source": "Body", "text": "Use helpers in Terratest to undeploy everything at the end of the test. ", "keywords": ["test"]}, {"source": "Body", "text": "Here's an example test for some Terraform code: These are integration tests, and depending on what you're testing, can take 5 - 50 minutes. ", "keywords": ["test"]}, {"source": "Body", "text": "It's not fast (though using Docker and test stages, you can speed some things up), and you'll have to work to make the tests reliable, but it is well worth the time. ", "keywords": ["test"]}, {"source": "Body", "text": "Check out the Terratest repo for docs and lots of examples of various types of infrastructure code and the corresponding tests for them.", "keywords": ["test"]}]}], "contains-topic": true, "filtered-sentences": [{"source": "Title", "text": "How to test terraform templates other than trial and error", "keywords": ["test"]}, {"source": "Body", "text": "Is there any testing tool/library that can help here?", "keywords": ["test"]}]}