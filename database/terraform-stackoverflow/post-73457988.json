{"Id": "73457988", "PostTypeId": "1", "CreationDate": "2022-08-23T11:35:33.737", "Score": "0", "ViewCount": "651", "Body": "<p>I am new to terraform. While creating terraform AWS DynamoDB module, It will try to replace the existing table instead of creating a new table every-time. But if we use new terraform state file it will create another dynamodb table without replacing.</p>\n<p>Terraform Version: 0.15</p>\n<pre><code>locals {\n  table_name_from_env = var.dynamodb_table\n  table_name = join(&quot;-&quot;, [local.table_name_from_env, lower(var.Component)])\n  kinesis_name = join(&quot;-&quot;, [local.table_name, &quot;kinesis&quot;])\n   \n}\n\n\nresource &quot;aws_dynamodb_table&quot; &quot;non_autoscaled&quot; {\n  count = !var.autoscaling_enabled ? 1 : 0\n\n  name           = &quot;${local.table_name}&quot;\n  read_capacity  = &quot;${var.read_capacity}&quot;\n  write_capacity = &quot;${var.write_capacity}&quot;\n  billing_mode   = &quot;${var.billing_mode}&quot;\n  hash_key       = &quot;${var.hash_key}&quot;\n  range_key      = var.range_key\n\n\n  dynamic &quot;attribute&quot; {\n    for_each = var.attributes\n\n    content {\n      name = attribute.value.name\n      type = attribute.value.type\n    }\n  }\n\n  ttl {\n    enabled        = var.ttl_enabled\n    attribute_name = var.ttl_attribute_name\n  }\n\n  #  tags = tomap({&quot;organization&quot; = &quot;${var.organization}&quot;, &quot;businessunit&quot; = &quot;${var.businessunit}&quot;})\n    tags = tomap({&quot;Component&quot; = &quot;${var.Component}&quot;})\n   #  tags =  local.common_tags\n\n}\n\n\nresource &quot;aws_dynamodb_table&quot; &quot;autoscaled&quot; {\n  count = var.autoscaling_enabled ? 1 : 0\n\n  name           = &quot;${local.table_name}&quot;\n  read_capacity  = &quot;${var.read_capacity}&quot;\n  write_capacity = &quot;${var.write_capacity}&quot;\n  billing_mode   = &quot;${var.billing_mode}&quot;\n  hash_key       = &quot;${var.hash_key}&quot;\n  range_key      = var.range_key\n\n\n  dynamic &quot;attribute&quot; {\n    for_each = var.attributes\n\n    content {\n      name = attribute.value.name\n      type = attribute.value.type\n    }\n  }\n\n  ttl {\n    enabled        = var.ttl_enabled\n    attribute_name = var.ttl_attribute_name\n  }\n\n\n}\n\nresource &quot;aws_kinesis_stream&quot; &quot;dynamodb_table_kinesis&quot; {\n   count =    var.kinesis_enabled ? 1 : 0\n\n   name       = &quot;${local.kinesis_name}&quot;\n   shard_count = &quot;${var.shard_count}&quot;\n\n   stream_mode_details {\n    stream_mode =  &quot;${var.kinesis_stream_mode}&quot;\n  }\n }\n\n resource &quot;aws_dynamodb_kinesis_streaming_destination&quot; &quot;dynamodb_table_kinesis_dest_non_autoscaled&quot;{\n   count =    var.kinesis_enabled &amp;&amp; !var.autoscaling_enabled ? 1 : 0\n\n   stream_arn = aws_kinesis_stream.dynamodb_table_kinesis[0].arn\n   table_name = aws_dynamodb_table.non_autoscaled[0].name\n }\n\n\nresource &quot;aws_dynamodb_kinesis_streaming_destination&quot; &quot;dynamodb_table_kinesis_dest_autoscaled&quot;{\n   count =    var.kinesis_enabled &amp;&amp; var.autoscaling_enabled ? 1 : 0\n\n   stream_arn = aws_kinesis_stream.dynamodb_table_kinesis[0].arn\n   table_name = aws_dynamodb_table.autoscaled[0].name\n }\n</code></pre>\n<p>Can anybody suggest what is missing in my approach ?</p>\n<p>Terraform Plan output:</p>\n<pre><code>+ terraform plan\nmodule.aws_managed_dynamodb_table.aws_kinesis_stream.dynamodb_table_kinesis[0]: Refreshing state... [id=arn:aws:kinesis:stream/dynamodb-testing12345-coms-kinesis]\nmodule.aws_managed_dynamodb_table.aws_dynamodb_table.non_autoscaled[0]: Refreshing state... [id=dynamodb-testing12345-coms]\nmodule.aws_managed_dynamodb_table.aws_dynamodb_kinesis_streaming_destination.dynamodb_table_kinesis_dest_non_autoscaled[0]: Refreshing state... [id=dynamodb-testing12345-coms,arn:aws:kinesis:ap-south-1:stream/dynamodb-testing12345-coms-kinesis]\n\nTerraform used the selected providers to generate the following execution\nplan. Resource actions are indicated with the following symbols:\n-/+ destroy and then create replacement\n\nTerraform will perform the following actions:\n\n  # module.aws_managed_dynamodb_table.aws_dynamodb_kinesis_streaming_destination.dynamodb_table_kinesis_dest_non_autoscaled[0] must be replaced\n-/+ resource &quot;aws_dynamodb_kinesis_streaming_destination&quot; &quot;dynamodb_table_kinesis_dest_non_autoscaled&quot; {\n      ~ id         = &quot;dynamodb-testing12345-coms,arn:aws:kinesis:ap-south-1:stream/dynamodb-testing12345-coms-kinesis&quot; -&gt; (known after apply)\n      ~ stream_arn = &quot;arn:aws:kinesis:ap-south-1:stream/dynamodb-testing12345-coms-kinesis&quot; -&gt; (known after apply) # forces replacement\n      ~ table_name = &quot;dynamodb-testing12345-coms&quot; -&gt; &quot;dynamodb-testing123456-coms&quot; # forces replacement\n    }\n\n  # module.aws_managed_dynamodb_table.aws_dynamodb_table.non_autoscaled[0] must be replaced\n-/+ resource &quot;aws_dynamodb_table&quot; &quot;non_autoscaled&quot; {\n      ~ arn              = &quot;arn:aws:dynamodb:ap-south-1:table/dynamodb-testing12345-coms&quot; -&gt; (known after apply)\n      ~ id               = &quot;dynamodb-testing12345-coms&quot; -&gt; (known after apply)\n      ~ name             = &quot;dynamodb-testing12345-coms&quot; -&gt; &quot;dynamodb-testing123456-coms&quot; # forces replacement\n      + stream_arn       = (known after apply)\n      - stream_enabled   = false -&gt; null\n      + stream_label     = (known after apply)\n      + stream_view_type = (known after apply)\n        tags             = {\n            &quot;Component&quot; = &quot;XXX&quot;\n        }\n        # (6 unchanged attributes hidden)\n\n\n      ~ point_in_time_recovery {\n          ~ enabled = false -&gt; (known after apply)\n        }\n\n      + server_side_encryption {\n          + enabled     = (known after apply)\n          + kms_key_arn = (known after apply)\n        }\n\n        # (3 unchanged blocks hidden)\n    }\n\n  # module.aws_managed_dynamodb_table.aws_kinesis_stream.dynamodb_table_kinesis[0] must be replaced\n-/+ resource &quot;aws_kinesis_stream&quot; &quot;dynamodb_table_kinesis&quot; {\n      ~ arn                       = (known after apply)\n      ~ id                        = (known after apply)\n      ~ name                      = &quot;dynamodb-testing12345-coms-kinesis&quot; -&gt; &quot;dynamodb-testing123456-coms-kinesis&quot; # forces replacement\n      - shard_level_metrics       = [] -&gt; null\n      - tags                      = {} -&gt; null\n      ~ tags_all                  = {} -&gt; (known after apply)\n        # (4 unchanged attributes hidden)\n\n        # (1 unchanged block hidden)\n    }\n\nPlan: 3 to add, 0 to change, 3 to destroy.\n</code></pre>\n", "OwnerUserId": "7062502", "LastEditorUserId": "7062502", "LastEditDate": "2022-08-23T12:13:00.453", "LastActivityDate": "2022-08-23T12:13:00.453", "Title": "Terraform try to replace the previous DynamoDB table instead of creating new one", "Tags": "<amazon-web-services><terraform><amazon-dynamodb><terraform-provider-aws>", "AnswerCount": "0", "CommentCount": "7", "ContentLicense": "CC BY-SA 4.0", "comments": [{"Id": "129723339", "PostId": "73457988", "Score": "0", "Text": "What is the value you are assigning to the `autoscaling_enabled` variable? Also, which of the two tables is being recreated?", "CreationDate": "2022-08-23T11:48:28.757", "UserId": "8343484", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "129723480", "PostId": "73457988", "Score": "0", "Text": "Adding the output of the plan would also help.", "CreationDate": "2022-08-23T11:54:07.903", "UserId": "8343484", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "129723892", "PostId": "73457988", "Score": "2", "Text": "To the question please, not in the comments section. And this shows practically nothing except it's refreshing the state.", "CreationDate": "2022-08-23T12:10:25.030", "UserId": "8343484", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "129725493", "PostId": "73457988", "Score": "0", "Text": "It seems that you are changing the name of the table: `dynamodb-testing12345-coms`. I'm guessing it's deriving it's value from the local variable, which uses another local variable `table_name_from_env`. Can you elaborate on how you are calling the module?", "CreationDate": "2022-08-23T13:11:40.340", "UserId": "8343484", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "It seems that you are changing the name of the table: `dynamodb-testing12345-coms`. ", "keywords": ["change", "test"]}]}, {"Id": "129736905", "PostId": "73457988", "Score": "0", "Text": "It seems like your goal is to keep your table named `dynamodb-testing12345-coms` and _add_ a new table called `dynamodb-testing123456-coms`. If so, the way to achieve that is _not_ to edit your existing resource definition, but instead to add a new resource definition describing the new table while retaining the old definition so that Terraform can see that you intend to keep it and haven't changed its settings.", "CreationDate": "2022-08-23T22:41:21.507", "UserId": "281848", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "It seems like your goal is to keep your table named `dynamodb-testing12345-coms` and _add_ a new table called `dynamodb-testing123456-coms`. ", "keywords": ["test"]}, {"source": "Text", "text": "If so, the way to achieve that is _not_ to edit your existing resource definition, but instead to add a new resource definition describing the new table while retaining the old definition so that Terraform can see that you intend to keep it and haven't changed its settings.", "keywords": ["change"]}]}, {"Id": "129740879", "PostId": "73457988", "Score": "0", "Text": "@MartinAtkins  Ok Thanks, So What would be the good practice for maintaining new tables and previous one, Do we need to create separate .tf state file for every table or anything else ?", "CreationDate": "2022-08-24T06:26:09.313", "UserId": "7062502", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "129753894", "PostId": "73457988", "Score": "0", "Text": "The only strong requirement is that you have a separate `resource` block (or, alternatively, separate instance of the same resource block using `for_each`/`count`) for each distinct object that should exist. From Terraform's perspective it doesn't matter if those multiple resources are declared all together in the same configuration or declared in separate configurations each with their own state. To decide that would require more context about how these databases are intended to be used, which is a bit beyond what we can cover in a comment thread here.", "CreationDate": "2022-08-24T15:24:57.250", "UserId": "281848", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "The only strong requirement is that you have a separate `resource` block (or, alternatively, separate instance of the same resource block using `for_each`/`count`) for each distinct object that should exist. ", "keywords": ["instance"]}]}], "history": [{"Id": "276797407", "PostHistoryTypeId": "2", "PostId": "73457988", "RevisionGUID": "61960b1a-be02-4557-b6bf-2d7aac3fc917", "CreationDate": "2022-08-23T11:35:33.737", "UserId": "7062502", "Text": "I am new to terraform. While creating terraform AWS DynamoDB module, It will try to replace the existing table instead of creating a new table every-time. But if we use new terraform state file it will create another dynamodb table without replacing. \r\n\r\nTerraform Version: 0.15\r\n\r\n    locals {\r\n      table_name_from_env = var.dynamodb_table\r\n      table_name = join(\"-\", [local.table_name_from_env, lower(var.Component)])\r\n      kinesis_name = join(\"-\", [local.table_name, \"kinesis\"])\r\n       \r\n    }\r\n    \r\n    \r\n    resource \"aws_dynamodb_table\" \"non_autoscaled\" {\r\n      count = !var.autoscaling_enabled ? 1 : 0\r\n    \r\n      name           = \"${local.table_name}\"\r\n      read_capacity  = \"${var.read_capacity}\"\r\n      write_capacity = \"${var.write_capacity}\"\r\n      billing_mode   = \"${var.billing_mode}\"\r\n      hash_key       = \"${var.hash_key}\"\r\n      range_key      = var.range_key\r\n    \r\n    \r\n      dynamic \"attribute\" {\r\n        for_each = var.attributes\r\n    \r\n        content {\r\n          name = attribute.value.name\r\n          type = attribute.value.type\r\n        }\r\n      }\r\n    \r\n      ttl {\r\n        enabled        = var.ttl_enabled\r\n        attribute_name = var.ttl_attribute_name\r\n      }\r\n    \r\n      #  tags = tomap({\"organization\" = \"${var.organization}\", \"businessunit\" = \"${var.businessunit}\"})\r\n        tags = tomap({\"Component\" = \"${var.Component}\"})\r\n       #  tags =  local.common_tags\r\n    \r\n    }\r\n    \r\n    \r\n    resource \"aws_dynamodb_table\" \"autoscaled\" {\r\n      count = var.autoscaling_enabled ? 1 : 0\r\n    \r\n      name           = \"${local.table_name}\"\r\n      read_capacity  = \"${var.read_capacity}\"\r\n      write_capacity = \"${var.write_capacity}\"\r\n      billing_mode   = \"${var.billing_mode}\"\r\n      hash_key       = \"${var.hash_key}\"\r\n      range_key      = var.range_key\r\n    \r\n    \r\n      dynamic \"attribute\" {\r\n        for_each = var.attributes\r\n    \r\n        content {\r\n          name = attribute.value.name\r\n          type = attribute.value.type\r\n        }\r\n      }\r\n    \r\n      ttl {\r\n        enabled        = var.ttl_enabled\r\n        attribute_name = var.ttl_attribute_name\r\n      }\r\n    \r\n    \r\n    }\r\n    \r\n    resource \"aws_kinesis_stream\" \"dynamodb_table_kinesis\" {\r\n       count =    var.kinesis_enabled ? 1 : 0\r\n    \r\n       name       = \"${local.kinesis_name}\"\r\n       shard_count = \"${var.shard_count}\"\r\n    \r\n       stream_mode_details {\r\n        stream_mode =  \"${var.kinesis_stream_mode}\"\r\n      }\r\n     }\r\n    \r\n     resource \"aws_dynamodb_kinesis_streaming_destination\" \"dynamodb_table_kinesis_dest_non_autoscaled\"{\r\n       count =    var.kinesis_enabled && !var.autoscaling_enabled ? 1 : 0\r\n    \r\n       stream_arn = aws_kinesis_stream.dynamodb_table_kinesis[0].arn\r\n       table_name = aws_dynamodb_table.non_autoscaled[0].name\r\n     }\r\n    \r\n    \r\n    resource \"aws_dynamodb_kinesis_streaming_destination\" \"dynamodb_table_kinesis_dest_autoscaled\"{\r\n       count =    var.kinesis_enabled && var.autoscaling_enabled ? 1 : 0\r\n    \r\n       stream_arn = aws_kinesis_stream.dynamodb_table_kinesis[0].arn\r\n       table_name = aws_dynamodb_table.autoscaled[0].name\r\n     }\r\n\r\nCan anybody suggest what is missing in my approach ?\r\n\r\n\r\n\r\n", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "Terraform Version: 0.15 locals { table_name_from_env = var.dynamodb_table table_name = join(\"-\", [local.table_name_from_env, lower(var.Component)]) kinesis_name = join(\"-\", [local.table_name, \"kinesis\"]) } resource \"aws_dynamodb_table\" \"non_autoscaled\" { count = !var.autoscaling_enabled ? 1 : 0 name = \"${local.table_name}\" read_capacity = \"${var.read_capacity}\" write_capacity = \"${var.write_capacity}\" billing_mode = \"${var.billing_mode}\" hash_key = \"${var.hash_key}\" range_key = var.range_key dynamic \"attribute\" { for_each = var.attributes content { name = attribute.value.name type = attribute.value.type } } ttl { enabled = var.ttl_enabled attribute_name = var.ttl_attribute_name } # tags = tomap({\"organization\" = \"${var.organization}\", \"businessunit\" = \"${var.businessunit}\"}) tags = tomap({\"Component\" = \"${var.Component}\"}) # tags = local.common_tags } resource \"aws_dynamodb_table\" \"autoscaled\" { count = var.autoscaling_enabled ? 1 : 0 name = \"${local.table_name}\" read_capacity = \"${var.read_capacity}\" write_capacity = \"${var.write_capacity}\" billing_mode = \"${var.billing_mode}\" hash_key = \"${var.hash_key}\" range_key = var.range_key dynamic \"attribute\" { for_each = var.attributes content { name = attribute.value.name type = attribute.value.type } } ttl { enabled = var.ttl_enabled attribute_name = var.ttl_attribute_name } } resource \"aws_kinesis_stream\" \"dynamodb_table_kinesis\" { count = var.kinesis_enabled ? 1 : 0 name = \"${local.kinesis_name}\" shard_count = \"${var.shard_count}\" stream_mode_details { stream_mode = \"${var.kinesis_stream_mode}\" } } resource \"aws_dynamodb_kinesis_streaming_destination\" \"dynamodb_table_kinesis_dest_non_autoscaled\"{ count = var.kinesis_enabled && !var.autoscaling_enabled ? 1 : 0 stream_arn = aws_kinesis_stream.dynamodb_table_kinesis[0].arn table_name = aws_dynamodb_table.non_autoscaled[0].name } resource \"aws_dynamodb_kinesis_streaming_destination\" \"dynamodb_table_kinesis_dest_autoscaled\"{ count = var.kinesis_enabled && var.autoscaling_enabled ? 1 : 0 stream_arn = aws_kinesis_stream.dynamodb_table_kinesis[0]", "keywords": ["bill"]}]}, {"Id": "276797409", "PostHistoryTypeId": "1", "PostId": "73457988", "RevisionGUID": "61960b1a-be02-4557-b6bf-2d7aac3fc917", "CreationDate": "2022-08-23T11:35:33.737", "UserId": "7062502", "Text": "Terraform try to replace the previous DynamoDB table instead of creating new one", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "276797410", "PostHistoryTypeId": "3", "PostId": "73457988", "RevisionGUID": "61960b1a-be02-4557-b6bf-2d7aac3fc917", "CreationDate": "2022-08-23T11:35:33.737", "UserId": "7062502", "Text": "<terraform><amazon-dynamodb><hcl>", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "276798476", "PostHistoryTypeId": "6", "PostId": "73457988", "RevisionGUID": "3471830e-71af-4af8-a65c-9fef9adbfe94", "CreationDate": "2022-08-23T11:49:01.730", "UserId": "8343484", "Comment": "Added tags", "Text": "<amazon-web-services><terraform><amazon-dynamodb><terraform-provider-aws>", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "276800241", "PostHistoryTypeId": "5", "PostId": "73457988", "RevisionGUID": "ebadeb35-7ade-43ab-82b0-f52c79082e4a", "CreationDate": "2022-08-23T12:13:00.453", "UserId": "7062502", "Comment": "added 3451 characters in body", "Text": "I am new to terraform. While creating terraform AWS DynamoDB module, It will try to replace the existing table instead of creating a new table every-time. But if we use new terraform state file it will create another dynamodb table without replacing. \r\n\r\nTerraform Version: 0.15\r\n\r\n    locals {\r\n      table_name_from_env = var.dynamodb_table\r\n      table_name = join(\"-\", [local.table_name_from_env, lower(var.Component)])\r\n      kinesis_name = join(\"-\", [local.table_name, \"kinesis\"])\r\n       \r\n    }\r\n    \r\n    \r\n    resource \"aws_dynamodb_table\" \"non_autoscaled\" {\r\n      count = !var.autoscaling_enabled ? 1 : 0\r\n    \r\n      name           = \"${local.table_name}\"\r\n      read_capacity  = \"${var.read_capacity}\"\r\n      write_capacity = \"${var.write_capacity}\"\r\n      billing_mode   = \"${var.billing_mode}\"\r\n      hash_key       = \"${var.hash_key}\"\r\n      range_key      = var.range_key\r\n    \r\n    \r\n      dynamic \"attribute\" {\r\n        for_each = var.attributes\r\n    \r\n        content {\r\n          name = attribute.value.name\r\n          type = attribute.value.type\r\n        }\r\n      }\r\n    \r\n      ttl {\r\n        enabled        = var.ttl_enabled\r\n        attribute_name = var.ttl_attribute_name\r\n      }\r\n    \r\n      #  tags = tomap({\"organization\" = \"${var.organization}\", \"businessunit\" = \"${var.businessunit}\"})\r\n        tags = tomap({\"Component\" = \"${var.Component}\"})\r\n       #  tags =  local.common_tags\r\n    \r\n    }\r\n    \r\n    \r\n    resource \"aws_dynamodb_table\" \"autoscaled\" {\r\n      count = var.autoscaling_enabled ? 1 : 0\r\n    \r\n      name           = \"${local.table_name}\"\r\n      read_capacity  = \"${var.read_capacity}\"\r\n      write_capacity = \"${var.write_capacity}\"\r\n      billing_mode   = \"${var.billing_mode}\"\r\n      hash_key       = \"${var.hash_key}\"\r\n      range_key      = var.range_key\r\n    \r\n    \r\n      dynamic \"attribute\" {\r\n        for_each = var.attributes\r\n    \r\n        content {\r\n          name = attribute.value.name\r\n          type = attribute.value.type\r\n        }\r\n      }\r\n    \r\n      ttl {\r\n        enabled        = var.ttl_enabled\r\n        attribute_name = var.ttl_attribute_name\r\n      }\r\n    \r\n    \r\n    }\r\n    \r\n    resource \"aws_kinesis_stream\" \"dynamodb_table_kinesis\" {\r\n       count =    var.kinesis_enabled ? 1 : 0\r\n    \r\n       name       = \"${local.kinesis_name}\"\r\n       shard_count = \"${var.shard_count}\"\r\n    \r\n       stream_mode_details {\r\n        stream_mode =  \"${var.kinesis_stream_mode}\"\r\n      }\r\n     }\r\n    \r\n     resource \"aws_dynamodb_kinesis_streaming_destination\" \"dynamodb_table_kinesis_dest_non_autoscaled\"{\r\n       count =    var.kinesis_enabled && !var.autoscaling_enabled ? 1 : 0\r\n    \r\n       stream_arn = aws_kinesis_stream.dynamodb_table_kinesis[0].arn\r\n       table_name = aws_dynamodb_table.non_autoscaled[0].name\r\n     }\r\n    \r\n    \r\n    resource \"aws_dynamodb_kinesis_streaming_destination\" \"dynamodb_table_kinesis_dest_autoscaled\"{\r\n       count =    var.kinesis_enabled && var.autoscaling_enabled ? 1 : 0\r\n    \r\n       stream_arn = aws_kinesis_stream.dynamodb_table_kinesis[0].arn\r\n       table_name = aws_dynamodb_table.autoscaled[0].name\r\n     }\r\n\r\nCan anybody suggest what is missing in my approach ?\r\n\r\n\r\nTerraform Plan output:\r\n\r\n    + terraform plan\r\n    module.aws_managed_dynamodb_table.aws_kinesis_stream.dynamodb_table_kinesis[0]: Refreshing state... [id=arn:aws:kinesis:stream/dynamodb-testing12345-coms-kinesis]\r\n    module.aws_managed_dynamodb_table.aws_dynamodb_table.non_autoscaled[0]: Refreshing state... [id=dynamodb-testing12345-coms]\r\n    module.aws_managed_dynamodb_table.aws_dynamodb_kinesis_streaming_destination.dynamodb_table_kinesis_dest_non_autoscaled[0]: Refreshing state... [id=dynamodb-testing12345-coms,arn:aws:kinesis:ap-south-1:stream/dynamodb-testing12345-coms-kinesis]\r\n    \r\n    Terraform used the selected providers to generate the following execution\r\n    plan. Resource actions are indicated with the following symbols:\r\n    -/+ destroy and then create replacement\r\n    \r\n    Terraform will perform the following actions:\r\n    \r\n      # module.aws_managed_dynamodb_table.aws_dynamodb_kinesis_streaming_destination.dynamodb_table_kinesis_dest_non_autoscaled[0] must be replaced\r\n    -/+ resource \"aws_dynamodb_kinesis_streaming_destination\" \"dynamodb_table_kinesis_dest_non_autoscaled\" {\r\n          ~ id         = \"dynamodb-testing12345-coms,arn:aws:kinesis:ap-south-1:stream/dynamodb-testing12345-coms-kinesis\" -> (known after apply)\r\n          ~ stream_arn = \"arn:aws:kinesis:ap-south-1:stream/dynamodb-testing12345-coms-kinesis\" -> (known after apply) # forces replacement\r\n          ~ table_name = \"dynamodb-testing12345-coms\" -> \"dynamodb-testing123456-coms\" # forces replacement\r\n        }\r\n    \r\n      # module.aws_managed_dynamodb_table.aws_dynamodb_table.non_autoscaled[0] must be replaced\r\n    -/+ resource \"aws_dynamodb_table\" \"non_autoscaled\" {\r\n          ~ arn              = \"arn:aws:dynamodb:ap-south-1:table/dynamodb-testing12345-coms\" -> (known after apply)\r\n          ~ id               = \"dynamodb-testing12345-coms\" -> (known after apply)\r\n          ~ name             = \"dynamodb-testing12345-coms\" -> \"dynamodb-testing123456-coms\" # forces replacement\r\n          + stream_arn       = (known after apply)\r\n          - stream_enabled   = false -> null\r\n          + stream_label     = (known after apply)\r\n          + stream_view_type = (known after apply)\r\n            tags             = {\r\n                \"Component\" = \"XXX\"\r\n            }\r\n            # (6 unchanged attributes hidden)\r\n    \r\n    \r\n          ~ point_in_time_recovery {\r\n              ~ enabled = false -> (known after apply)\r\n            }\r\n    \r\n          + server_side_encryption {\r\n              + enabled     = (known after apply)\r\n              + kms_key_arn = (known after apply)\r\n            }\r\n    \r\n            # (3 unchanged blocks hidden)\r\n        }\r\n    \r\n      # module.aws_managed_dynamodb_table.aws_kinesis_stream.dynamodb_table_kinesis[0] must be replaced\r\n    -/+ resource \"aws_kinesis_stream\" \"dynamodb_table_kinesis\" {\r\n          ~ arn                       = (known after apply)\r\n          ~ id                        = (known after apply)\r\n          ~ name                      = \"dynamodb-testing12345-coms-kinesis\" -> \"dynamodb-testing123456-coms-kinesis\" # forces replacement\r\n          - shard_level_metrics       = [] -> null\r\n          - tags                      = {} -> null\r\n          ~ tags_all                  = {} -> (known after apply)\r\n            # (4 unchanged attributes hidden)\r\n    \r\n            # (1 unchanged block hidden)\r\n        }\r\n    \r\n    Plan: 3 to add, 0 to change, 3 to destroy.\r\n\r\n", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "Terraform Version: 0.15 locals { table_name_from_env = var.dynamodb_table table_name = join(\"-\", [local.table_name_from_env, lower(var.Component)]) kinesis_name = join(\"-\", [local.table_name, \"kinesis\"]) } resource \"aws_dynamodb_table\" \"non_autoscaled\" { count = !var.autoscaling_enabled ? 1 : 0 name = \"${local.table_name}\" read_capacity = \"${var.read_capacity}\" write_capacity = \"${var.write_capacity}\" billing_mode = \"${var.billing_mode}\" hash_key = \"${var.hash_key}\" range_key = var.range_key dynamic \"attribute\" { for_each = var.attributes content { name = attribute.value.name type = attribute.value.type } } ttl { enabled = var.ttl_enabled attribute_name = var.ttl_attribute_name } # tags = tomap({\"organization\" = \"${var.organization}\", \"businessunit\" = \"${var.businessunit}\"}) tags = tomap({\"Component\" = \"${var.Component}\"}) # tags = local.common_tags } resource \"aws_dynamodb_table\" \"autoscaled\" { count = var.autoscaling_enabled ? 1 : 0 name = \"${local.table_name}\" read_capacity = \"${var.read_capacity}\" write_capacity = \"${var.write_capacity}\" billing_mode = \"${var.billing_mode}\" hash_key = \"${var.hash_key}\" range_key = var.range_key dynamic \"attribute\" { for_each = var.attributes content { name = attribute.value.name type = attribute.value.type } } ttl { enabled = var.ttl_enabled attribute_name = var.ttl_attribute_name } } resource \"aws_kinesis_stream\" \"dynamodb_table_kinesis\" { count = var.kinesis_enabled ? 1 : 0 name = \"${local.kinesis_name}\" shard_count = \"${var.shard_count}\" stream_mode_details { stream_mode = \"${var.kinesis_stream_mode}\" } } resource \"aws_dynamodb_kinesis_streaming_destination\" \"dynamodb_table_kinesis_dest_non_autoscaled\"{ count = var.kinesis_enabled && !var.autoscaling_enabled ? 1 : 0 stream_arn = aws_kinesis_stream.dynamodb_table_kinesis[0].arn table_name = aws_dynamodb_table.non_autoscaled[0].name } resource \"aws_dynamodb_kinesis_streaming_destination\" \"dynamodb_table_kinesis_dest_autoscaled\"{ count = var.kinesis_enabled && var.autoscaling_enabled ? 1 : 0 stream_arn = aws_kinesis_stream.dynamodb_table_kinesis[0].arn table_name = aws_dynamodb_table.autoscaled[0].name } Can anybody suggest what is missing in my approach ? Terraform Plan output: + terraform plan module.aws_managed_dynamodb_table.aws_kinesis_stream.dynamodb_table_kinesis[0]: Refreshing state... [id=arn:aws:kinesis:stream/dynamodb-testing12345-coms-kinesis] module.aws_managed_dynamodb_table.aws_dynamodb_table.non_autoscaled[0]: Refreshing state... [id=dynamodb-testing12345-coms] module.aws_managed_dynamodb_table.aws_dynamodb_kinesis_streaming_destination.dynamodb_table_kinesis_dest_non_autoscaled[0]: Refreshing state... [id=dynamodb-testing12345-coms,arn:aws:kinesis:ap-south-1:stream/dynamodb-testing12345-coms-kinesis] Terraform used the selected providers to generate the following execution plan. ", "keywords": ["bill", "test"]}, {"source": "Text", "text": "Resource actions are indicated with the following symbols: -/+ destroy and then create replacement Terraform will perform the following actions: # module.aws_managed_dynamodb_table.aws_dynamodb_kinesis_streaming_destination.dynamodb_table_kinesis_dest_non_autoscaled[0] must be replaced -/+ resource \"aws_dynamodb_kinesis_streaming_destination\" \"dynamodb_table_kinesis_dest_non_autoscaled\" { ~ id = \"dynamodb-testing12345-coms,arn:aws:kinesis:ap-south-1:stream/dynamodb-testing12345-coms-kinesis\" -> (known after apply) ~ stream_arn = \"arn:aws:kinesis:ap-south-1:stream/dynamodb-testing12345-coms-kinesis\" -> (known after apply) # forces replacement ~ table_name = \"dynamodb-testing12345-coms\" -> \"dynamodb-testing123456-coms\" # forces replacement } # module.aws_managed_dynamodb_table.aws_dynamodb_table.non_autoscaled[0] must be replaced -/+ resource \"aws_dynamodb_table\" \"non_autoscaled\" { ~ arn = \"arn:aws:dynamodb:ap-south-1:table/dynamodb-testing12345-coms\" -> (known after apply) ~ id = \"dynamodb-testing12345-coms\" -> (known after apply) ~ name = \"dynamodb-testing12345-coms\" -> \"dynamodb-testing123456-coms\" # forces replacement + stream_arn = (known after apply) - stream_enabled = false -> null + stream_label = (known after apply) + stream_view_type = (known after apply) tags = { \"Component\" = \"XXX\" } # (6 unchanged attributes hidden) ~ point_in_time_recovery { ~ enabled = false -> (known after apply) } + server_side_encryption { + enabled = (known after apply) + kms_key_arn = (known after apply) } # (3 unchanged blocks hidden) } # module.aws_managed_dynamodb_table.aws_kinesis_stream.dynamodb_table_kinesis[0] must be replaced -/+ resource \"aws_kinesis_stream\" \"dynamodb_table_kinesis\" { ~ arn = (known after apply) ~ id = (known after apply) ~ name = \"dynamodb-testing12345-coms-kinesis\" -> \"dynamodb-testing123456-coms-kinesis\" # forces replacement - shard_level_metrics = [] -> null - tags = {} -> null ~ tags_all = {} -> (known after apply) # (4 unchanged attributes hidden) # (1 unchanged block hidden) } Plan: 3 to add, 0 to change, 3 to destroy.", "keywords": ["change", "test"]}]}], "contains-topic": true, "filtered-sentences": []}