{"Id": "66080706", "PostTypeId": "1", "AcceptedAnswerId": "66111652", "CreationDate": "2021-02-06T18:54:58.993", "Score": "18", "ViewCount": "5559", "Body": "<p>I am going through a <code>terraform</code> guide, where the author is spinning up a docker setup using the <code>docker_image</code> and <code>docker_container</code> resources.</p>\n<p>In the sample code the <code>main.tf</code> file includes <strong>both</strong> the <code>required_providers</code> <strong>and</strong> the <code>provider</code> blocks, as follows:</p>\n<pre><code>terraform {\n  required_providers {\n    docker = {\n      source = &quot;kreuzwerker/docker&quot;\n    }\n  }\n}\n\nprovider &quot;docker&quot; {}\n</code></pre>\n<p>Why are they both needed?</p>\n<p>Shouldn't <code>terraform</code> be able to understand the need for a <code>docker</code> provider, only by this line?</p>\n<pre><code>provider &quot;docker&quot; {}\n</code></pre>\n", "OwnerUserId": "2409793", "LastActivityDate": "2021-05-26T17:40:21.417", "Title": "Terraform using both required_providers and provider blocks", "Tags": "<terraform>", "AnswerCount": "2", "CommentCount": "0", "FavoriteCount": "0", "ContentLicense": "CC BY-SA 4.0", "history": [{"Id": "240302693", "PostHistoryTypeId": "2", "PostId": "66080706", "RevisionGUID": "8bb9638a-66bc-41a7-b4fa-a6ba71e15634", "CreationDate": "2021-02-06T18:54:58.993", "UserId": "2409793", "Text": "I am going through a `terraform` guide, where the author is spinning up a docker setup using the `docker_image` and `docker_container` resources.\r\n\r\nIn the sample code the `main.tf` file includes __both__ the `required_providers` __and__ the `provider` blocks, as follows:\r\n\r\n```hcl \r\nterraform {\r\n  required_providers {\r\n    docker = {\r\n      source = \"kreuzwerker/docker\"\r\n    }\r\n  }\r\n}\r\n\r\nprovider \"docker\" {}\r\n```\r\n\r\nWhy are they both needed? \r\n\r\nShouldn't `terraform` be able to understand the need for a `docker` provider, only by this line?\r\n\r\n```\r\nprovider \"docker\" {}\r\n```", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "In the sample code the `main.tf` file includes __both__ the `required_providers` __and__ the `provider` blocks, as follows: ```hcl terraform { required_providers { docker = { source = \"kreuzwerker/docker\" } } } provider \"docker\" {} ``` ", "keywords": ["provider"]}, {"source": "Text", "text": "Shouldn't `terraform` be able to understand the need for a `docker` provider, only by this line? ", "keywords": ["provider"]}, {"source": "Text", "text": "``` provider \"docker\" {} ```", "keywords": ["provider"]}]}, {"Id": "240302694", "PostHistoryTypeId": "1", "PostId": "66080706", "RevisionGUID": "8bb9638a-66bc-41a7-b4fa-a6ba71e15634", "CreationDate": "2021-02-06T18:54:58.993", "UserId": "2409793", "Text": "Terraform using both required_providers and provider blocks", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "Terraform using both required_providers and provider blocks", "keywords": ["provider"]}]}, {"Id": "240302695", "PostHistoryTypeId": "3", "PostId": "66080706", "RevisionGUID": "8bb9638a-66bc-41a7-b4fa-a6ba71e15634", "CreationDate": "2021-02-06T18:54:58.993", "UserId": "2409793", "Text": "<terraform>", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "answers": [{"Id": "66081903", "PostTypeId": "2", "ParentId": "66080706", "CreationDate": "2021-02-06T20:58:52.600", "Score": "15", "Body": "<p>The <code>source</code> needs to be provided since this isn't one of the &quot;official&quot; HashiCorp providers. There could be multiple providers with the name &quot;docker&quot; in the provider registry, so providing the <code>source</code> is needed in order to tell Terraform exactly which provider to download.</p>\n", "OwnerUserId": "13070", "LastEditorUserId": "13070", "LastEditDate": "2021-02-06T21:06:10.180", "LastActivityDate": "2021-02-06T21:06:10.180", "CommentCount": "0", "ContentLicense": "CC BY-SA 4.0", "history": [{"Id": "240307788", "PostHistoryTypeId": "2", "PostId": "66081903", "RevisionGUID": "5e4e57a0-5fe1-4a3f-92fe-d6d0dc24f3b8", "CreationDate": "2021-02-06T20:58:52.600", "UserId": "13070", "Text": "The `source` needs to be provided since this isn't one of the \"built-in\" HashiCorp providers. There could be multiple providers with the name \"docker\" in the provider registry, so providing the `source` is needed in order to tell Terraform exactly which provider to download.", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "There could be multiple providers with the name \"docker\" in the provider registry, so providing the `source` is needed in order to tell Terraform exactly which provider to download.", "keywords": ["provider"]}]}, {"Id": "240307809", "PostHistoryTypeId": "12", "PostId": "66081903", "RevisionGUID": "ccf228e0-8de3-4b6b-b917-8f1914fb8744", "CreationDate": "2021-02-06T20:59:33.723", "UserId": "13070", "Comment": "via Vote", "Text": "{\"Voters\":[{\"Id\":13070,\"DisplayName\":\"Mark B\"}]}", "filtered-sentences": []}, {"Id": "240307817", "PostHistoryTypeId": "13", "PostId": "66081903", "RevisionGUID": "94970bb2-0710-4ad9-84c7-64a18a968917", "CreationDate": "2021-02-06T20:59:41.490", "UserId": "13070", "Text": "{\"Voters\":[{\"Id\":13070,\"DisplayName\":\"Mark B\"}]}", "filtered-sentences": []}, {"Id": "240308062", "PostHistoryTypeId": "5", "PostId": "66081903", "RevisionGUID": "2a806de9-327b-4f0b-a82e-0dcb224897fe", "CreationDate": "2021-02-06T21:06:10.180", "UserId": "13070", "Comment": "edited body", "Text": "The `source` needs to be provided since this isn't one of the \"official\" HashiCorp providers. There could be multiple providers with the name \"docker\" in the provider registry, so providing the `source` is needed in order to tell Terraform exactly which provider to download.", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "There could be multiple providers with the name \"docker\" in the provider registry, so providing the `source` is needed in order to tell Terraform exactly which provider to download.", "keywords": ["provider"]}]}], "filtered-sentences": [{"source": "Body", "text": "There could be multiple providers with the name \"docker\" in the provider registry, so providing the source is needed in order to tell Terraform exactly which provider to download.", "keywords": ["provider"]}]}, {"Id": "66111652", "PostTypeId": "2", "ParentId": "66080706", "CreationDate": "2021-02-09T01:17:22.657", "Score": "28", "Body": "<p>When considering Terraform providers there are two related notions to think about: the provider itself, and a configuration for the provider.</p>\n<p>As an analogy, the provider <code>kreuzwerker/docker</code> here is a bit like a class you're importing from another library, giving it the local name <code>docker</code>. I'll use a pseudo-JavaScript syntax just to make this a bit more concrete:</p>\n<pre><code>var docker = require(&quot;kreuzwerker/docker&quot;);\n</code></pre>\n<p>However, all we have here so far is the class itself. In order to use it we need to create an <em>instance</em> of it, which in Terraform's vernacular is called a &quot;configuration&quot;. Again, using pseudo-JavaScript syntax:</p>\n<pre><code>var dockerInstance = new docker({});\n</code></pre>\n<p>Terraform's syntax here is decidedly less explicit than this pseudo-JavaScript form, but we can make the distinction more visible by adding a second instance of the provider to the configuration, which in Terraform we do by assigning it a configuration &quot;alias&quot;:</p>\n<pre><code>provider &quot;docker&quot; {\n  alias = &quot;example&quot;\n\n  host = &quot;ssh://user@remote-host:22&quot;\n}\n</code></pre>\n<p>This is like creating a second instance of the provider &quot;class&quot; in our pseudo-JavaScript example:</p>\n<pre><code>var dockerInstance2 = new docker({\n  host: 'ssh://user@remote-host:22'\n});\n</code></pre>\n<p>Another variant that shows the distinction is when a module inherits a provider configuration from its calling module. In that case, it's as if the calling module were implicitly passing the provider configuration (instance) into the module, but the child module still needs to import the provider &quot;class&quot; so Terraform can see that we're talking about <code>kreuzwerker/docker</code> as opposed to any other provider that might have the name &quot;docker&quot;.</p>\n<p>Terraform has some automatic &quot;magic&quot; behaviors that try to make simpler cases implicit, but unfortunately that comes at the cost of making it harder to understand what's going on when things get more complicated. Providers and provider configurations are a particularly hard example of this, because providers have been in the Terraform language for a long time and the current incarnation of the language is trying to stay broadly backward-compatible with the simple uses while still allowing for the newer features like having third-party providers installable from multiple namespaces.</p>\n<p>The particularly confusing assumption here is that if you don't declare a particular provider Terraform will create an implicit <code>required_providers</code> declaration assuming that you mean a provider in the <code>hashicorp/</code> namespace, which makes it seem as though <code>required_providers</code> is only for third-party providers. In fact though, that is largely a backward-compatibility mechanism and so I'd suggest <em>always</em> writing out the <code>required_providers</code> entries, even for the providers in the <code>hashicorp/</code> namespace, so that less-experienced readers don't need to know about this special backward-compatibility behavior. In your case though, the provider you're using is in a third-party namespace anyway and so the <code>required_providers</code> entry is mandatory.</p>\n", "OwnerUserId": "281848", "LastEditorUserId": "281848", "LastEditDate": "2021-05-26T17:40:21.417", "LastActivityDate": "2021-05-26T17:40:21.417", "CommentCount": "0", "ContentLicense": "CC BY-SA 4.0", "history": [{"Id": "240435488", "PostHistoryTypeId": "2", "PostId": "66111652", "RevisionGUID": "687766b4-0491-45fc-9c95-3bc971bc09a7", "CreationDate": "2021-02-09T01:17:22.657", "UserId": "281848", "Text": "When considering Terraform providers there are two related notions to think about: the provider itself, and a configuration for the provider.\r\n\r\nAs an analogy, the provider `kreuzwerker/docker` here is a bit like a class you're importing from another library, giving it the local name `docker`. I'll use a pseudo-JavaScript syntax just to make this a bit more concrete:\r\n\r\n```\r\nvar docker = require(\"kreuzwerker/docker\");\r\n```\r\n\r\nHowever, all we have here so far is the class itself. In order to use it we need to create an _instance_ of it, which in Terraform's vernacular is called a \"configuration\". Again, using pseudo-JavaScript syntax:\r\n\r\n```\r\nvar dockerInstance = new docker({});\r\n```\r\n\r\nTerraform's syntax here is decidedly less explicit than this pseudo-JavaScript form, but we can make the distinction more visible by adding a second instance of the provider to the configuration, which in Terraform we do by assigning it a configuration \"alias\":\r\n\r\n```\r\nprovider \"docker\" {\r\n  alias = \"example\"\r\n\r\n  host = \"ssh://user@remote-host:22\"\r\n}\r\n```\r\n\r\nThis is like creating a second instance of the provider \"class\" in our pseudo-JavaScript example:\r\n\r\n```\r\nvar dockerInstance2 = new docker({\r\n  host: 'ssh://user@remote-host:22'\r\n});\r\n```\r\n\r\nAnother variant that shows the distinction is when a module inherits a provider configuration from its calling module. In that case, it's as if the calling module were implicitly passing the provider configuration (instance) into the module, but the child module still needs to import the provider \"class\" so Terraform can see that we're talking about `kreuzwerker/docker` as opposed to any other provider that might have the name \"docker\".\r\n\r\nTerraform has some automatic \"magic\" behaviors that try to make simpler cases implicit, but unfortunately that comes at the cost of making it harder to understand what's going on when things get more complicated. Providers and provider configurations are a particularly hard example of this, because providers have been in the Terraform language for a long time and the current incarnation of the language is trying to stay broadly backward-compatible with the simple uses while still allowing for the newer features like having third-party providers installable from multiple namespaces.\r\n\r\nThe particularly confusing assumption here is that if you don't declare a particular provider Terraform will create an implicit `required_providers` declaration assuming that you mean a provider in the `hashicorp/` namespace, which makes it seem as though `required_providers` is only for third-party providers. In fact though, that is largely a backward-compatibility mechanism and so I'd suggest _always_ writing out the `required_providers` entries, even for the providers in the `hashicorp/` namespace, so that less experience readers don't need to know about this special backward-compatibility behavior. In your case though, the provider you're using is in a third-party namespace anyway and so the `required_providers` entry is mandatory.\r\n", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "When considering Terraform providers there are two related notions to think about: the provider itself, and a configuration for the provider. ", "keywords": ["provider"]}, {"source": "Text", "text": "As an analogy, the provider `kreuzwerker/docker` here is a bit like a class you're importing from another library, giving it the local name `docker`. ", "keywords": ["provider"]}, {"source": "Text", "text": "Again, using pseudo-JavaScript syntax: ``` var dockerInstance = new docker({}); ``` Terraform's syntax here is decidedly less explicit than this pseudo-JavaScript form, but we can make the distinction more visible by adding a second instance of the provider to the configuration, which in Terraform we do by assigning it a configuration \"alias\": ``` provider \"docker\" { alias = \"example\" host = \"ssh://user@remote-host:22\" } ``` This is like creating a second instance of the provider \"class\" in our pseudo-JavaScript example: ``` var dockerInstance2 = new docker({ host: 'ssh://user@remote-host:22' }); ``` ", "keywords": ["instance", "provider"]}, {"source": "Text", "text": "Another variant that shows the distinction is when a module inherits a provider configuration from its calling module. ", "keywords": ["provider"]}, {"source": "Text", "text": "In that case, it's as if the calling module were implicitly passing the provider configuration (instance) into the module, but the child module still needs to import the provider \"class\" so Terraform can see that we're talking about `kreuzwerker/docker` as opposed to any other provider that might have the name \"docker\". ", "keywords": ["instance", "provider"]}, {"source": "Text", "text": "Terraform has some automatic \"magic\" behaviors that try to make simpler cases implicit, but unfortunately that comes at the cost of making it harder to understand what's going on when things get more complicated. ", "keywords": ["cost"]}, {"source": "Text", "text": "Providers and provider configurations are a particularly hard example of this, because providers have been in the Terraform language for a long time and the current incarnation of the language is trying to stay broadly backward-compatible with the simple uses while still allowing for the newer features like having third-party providers installable from multiple namespaces. ", "keywords": ["provider"]}, {"source": "Text", "text": "The particularly confusing assumption here is that if you don't declare a particular provider Terraform will create an implicit `required_providers` declaration assuming that you mean a provider in the `hashicorp/` namespace, which makes it seem as though `required_providers` is only for third-party providers. ", "keywords": ["provider"]}, {"source": "Text", "text": "In your case though, the provider you're using is in a third-party namespace anyway and so the `required_providers` entry is mandatory.", "keywords": ["provider"]}]}, {"Id": "247331516", "PostHistoryTypeId": "5", "PostId": "66111652", "RevisionGUID": "d7792e0c-dad3-4790-ab46-6757820297b9", "CreationDate": "2021-05-26T17:40:21.417", "UserId": "281848", "Comment": "added 1 character in body", "Text": "When considering Terraform providers there are two related notions to think about: the provider itself, and a configuration for the provider.\r\n\r\nAs an analogy, the provider `kreuzwerker/docker` here is a bit like a class you're importing from another library, giving it the local name `docker`. I'll use a pseudo-JavaScript syntax just to make this a bit more concrete:\r\n\r\n```\r\nvar docker = require(\"kreuzwerker/docker\");\r\n```\r\n\r\nHowever, all we have here so far is the class itself. In order to use it we need to create an _instance_ of it, which in Terraform's vernacular is called a \"configuration\". Again, using pseudo-JavaScript syntax:\r\n\r\n```\r\nvar dockerInstance = new docker({});\r\n```\r\n\r\nTerraform's syntax here is decidedly less explicit than this pseudo-JavaScript form, but we can make the distinction more visible by adding a second instance of the provider to the configuration, which in Terraform we do by assigning it a configuration \"alias\":\r\n\r\n```\r\nprovider \"docker\" {\r\n  alias = \"example\"\r\n\r\n  host = \"ssh://user@remote-host:22\"\r\n}\r\n```\r\n\r\nThis is like creating a second instance of the provider \"class\" in our pseudo-JavaScript example:\r\n\r\n```\r\nvar dockerInstance2 = new docker({\r\n  host: 'ssh://user@remote-host:22'\r\n});\r\n```\r\n\r\nAnother variant that shows the distinction is when a module inherits a provider configuration from its calling module. In that case, it's as if the calling module were implicitly passing the provider configuration (instance) into the module, but the child module still needs to import the provider \"class\" so Terraform can see that we're talking about `kreuzwerker/docker` as opposed to any other provider that might have the name \"docker\".\r\n\r\nTerraform has some automatic \"magic\" behaviors that try to make simpler cases implicit, but unfortunately that comes at the cost of making it harder to understand what's going on when things get more complicated. Providers and provider configurations are a particularly hard example of this, because providers have been in the Terraform language for a long time and the current incarnation of the language is trying to stay broadly backward-compatible with the simple uses while still allowing for the newer features like having third-party providers installable from multiple namespaces.\r\n\r\nThe particularly confusing assumption here is that if you don't declare a particular provider Terraform will create an implicit `required_providers` declaration assuming that you mean a provider in the `hashicorp/` namespace, which makes it seem as though `required_providers` is only for third-party providers. In fact though, that is largely a backward-compatibility mechanism and so I'd suggest _always_ writing out the `required_providers` entries, even for the providers in the `hashicorp/` namespace, so that less-experienced readers don't need to know about this special backward-compatibility behavior. In your case though, the provider you're using is in a third-party namespace anyway and so the `required_providers` entry is mandatory.\r\n", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "When considering Terraform providers there are two related notions to think about: the provider itself, and a configuration for the provider. ", "keywords": ["provider"]}, {"source": "Text", "text": "As an analogy, the provider `kreuzwerker/docker` here is a bit like a class you're importing from another library, giving it the local name `docker`. ", "keywords": ["provider"]}, {"source": "Text", "text": "Again, using pseudo-JavaScript syntax: ``` var dockerInstance = new docker({}); ``` Terraform's syntax here is decidedly less explicit than this pseudo-JavaScript form, but we can make the distinction more visible by adding a second instance of the provider to the configuration, which in Terraform we do by assigning it a configuration \"alias\": ``` provider \"docker\" { alias = \"example\" host = \"ssh://user@remote-host:22\" } ``` This is like creating a second instance of the provider \"class\" in our pseudo-JavaScript example: ``` var dockerInstance2 = new docker({ host: 'ssh://user@remote-host:22' }); ``` ", "keywords": ["instance", "provider"]}, {"source": "Text", "text": "Another variant that shows the distinction is when a module inherits a provider configuration from its calling module. ", "keywords": ["provider"]}, {"source": "Text", "text": "In that case, it's as if the calling module were implicitly passing the provider configuration (instance) into the module, but the child module still needs to import the provider \"class\" so Terraform can see that we're talking about `kreuzwerker/docker` as opposed to any other provider that might have the name \"docker\". ", "keywords": ["instance", "provider"]}, {"source": "Text", "text": "Terraform has some automatic \"magic\" behaviors that try to make simpler cases implicit, but unfortunately that comes at the cost of making it harder to understand what's going on when things get more complicated. ", "keywords": ["cost"]}, {"source": "Text", "text": "Providers and provider configurations are a particularly hard example of this, because providers have been in the Terraform language for a long time and the current incarnation of the language is trying to stay broadly backward-compatible with the simple uses while still allowing for the newer features like having third-party providers installable from multiple namespaces. ", "keywords": ["provider"]}, {"source": "Text", "text": "The particularly confusing assumption here is that if you don't declare a particular provider Terraform will create an implicit `required_providers` declaration assuming that you mean a provider in the `hashicorp/` namespace, which makes it seem as though `required_providers` is only for third-party providers. ", "keywords": ["provider"]}, {"source": "Text", "text": "In your case though, the provider you're using is in a third-party namespace anyway and so the `required_providers` entry is mandatory.", "keywords": ["provider"]}]}], "filtered-sentences": [{"source": "Body", "text": "When considering Terraform providers there are two related notions to think about: the provider itself, and a configuration for the provider. ", "keywords": ["provider"]}, {"source": "Body", "text": "As an analogy, the provider kreuzwerker/docker here is a bit like a class you're importing from another library, giving it the local name docker. ", "keywords": ["provider"]}, {"source": "Body", "text": "In order to use it we need to create an instance of it, which in Terraform's vernacular is called a \"configuration\". ", "keywords": ["instance"]}, {"source": "Body", "text": "Again, using pseudo-JavaScript syntax: Terraform's syntax here is decidedly less explicit than this pseudo-JavaScript form, but we can make the distinction more visible by adding a second instance of the provider to the configuration, which in Terraform we do by assigning it a configuration \"alias\": ", "keywords": ["instance", "provider"]}, {"source": "Body", "text": "This is like creating a second instance of the provider \"class\" in our pseudo-JavaScript example: Another variant that shows the distinction is when a module inherits a provider configuration from its calling module. ", "keywords": ["instance", "provider"]}, {"source": "Body", "text": "In that case, it's as if the calling module were implicitly passing the provider configuration (instance) into the module, but the child module still needs to import the provider \"class\" so Terraform can see that we're talking about kreuzwerker/docker as opposed to any other provider that might have the name \"docker\". ", "keywords": ["instance", "provider"]}, {"source": "Body", "text": "Terraform has some automatic \"magic\" behaviors that try to make simpler cases implicit, but unfortunately that comes at the cost of making it harder to understand what's going on when things get more complicated. ", "keywords": ["cost"]}, {"source": "Body", "text": "Providers and provider configurations are a particularly hard example of this, because providers have been in the Terraform language for a long time and the current incarnation of the language is trying to stay broadly backward-compatible with the simple uses while still allowing for the newer features like having third-party providers installable from multiple namespaces. ", "keywords": ["provider"]}, {"source": "Body", "text": "The particularly confusing assumption here is that if you don't declare a particular provider Terraform will create an implicit required_providers declaration assuming that you mean a provider in the hashicorp/ namespace, which makes it seem as though required_providers is only for third-party providers. ", "keywords": ["provider"]}, {"source": "Body", "text": "In your case though, the provider you're using is in a third-party namespace anyway and so the required_providers entry is mandatory.", "keywords": ["provider"]}]}], "contains-topic": true, "filtered-sentences": [{"source": "Title", "text": "Terraform using both required_providers and provider blocks", "keywords": ["provider"]}, {"source": "Body", "text": "In the sample code the main.tf file includes both the required_providers and the provider blocks, as follows: Why are they both needed? ", "keywords": ["provider"]}, {"source": "Body", "text": "Shouldn't terraform be able to understand the need for a docker provider, only by this line?", "keywords": ["provider"]}]}