{"Id": "65671433", "PostTypeId": "1", "AcceptedAnswerId": "65672454", "CreationDate": "2021-01-11T17:08:58.697", "Score": "1", "ViewCount": "813", "Body": "<p>I was looking to see if there if there is something I can do that will allow me to deploy 3 EC2 instances of different instance types? Clearly below doesnt work but I cant see anything online on the most efficient way of performing this.</p>\n<pre><code>variable &quot;instance_type&quot; {\n    type = list \n    default = [&quot;t2.micro&quot;, &quot;t2.small&quot;, &quot;t2.medium&quot;]\n}\n\nresource &quot;aws_instance&quot; &quot;Server1&quot; {\n    instance_type = var.instance_type [0,1,2]\n    count = 3\n</code></pre>\n", "OwnerUserId": "14979614", "LastActivityDate": "2021-01-11T18:19:36.133", "Title": "Terraform multiple instance types from count?", "Tags": "<terraform>", "AnswerCount": "1", "CommentCount": "2", "ContentLicense": "CC BY-SA 4.0", "comments": [{"Id": "116111334", "PostId": "65671433", "Score": "0", "Text": "What version of Terraform?", "CreationDate": "2021-01-11T17:46:02.587", "UserId": "5343387", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "116111516", "PostId": "65671433", "Score": "1", "Text": "There are a lot of similar questions with answers here. An example from earlier today even is https://stackoverflow.com/questions/65664963/ec2-instance-creation. Does that work for you? If not then please could you edit your question to show other things you've tried and then explain why they didn't work or show any errors you got?", "CreationDate": "2021-01-11T17:52:47.157", "UserId": "2291321", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "An example from earlier today even is https://stackoverflow.com/questions/65664963/ec2-instance-creation. ", "keywords": ["instance"]}]}], "links": [{"Id": "1790972639", "CreationDate": "2021-01-11T17:52:47.157", "PostId": "65671433", "RelatedPostId": "65664963", "LinkTypeId": "1"}], "history": [{"Id": "238539532", "PostHistoryTypeId": "2", "PostId": "65671433", "RevisionGUID": "215ce178-196f-42bf-a32b-7b97961816c8", "CreationDate": "2021-01-11T17:08:58.697", "UserId": "14979614", "Text": "I was looking to see if there if there is something I can do that will allow me to deploy 3 EC2 instances of different instance types? Clearly below doesnt work but I cant see anything online on the most efficient way of performing this.\r\n\r\n    \r\n\r\n    variable \"instance_type\" {\r\n        type = list \r\n        default = [\"t2.micro\", \"t2.small\", \"t2.medium\"]\r\n    }\r\n    \r\n    resource \"aws_instance\" \"Server1\" {\r\n        instance_type = var.instance_type [0,1,2]\r\n        count = 3", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "I was looking to see if there if there is something I can do that will allow me to deploy 3 EC2 instances of different instance types? ", "keywords": ["instance"]}, {"source": "Text", "text": "Clearly below doesnt work but I cant see anything online on the most efficient way of performing this. ", "keywords": ["efficient"]}]}, {"Id": "238539533", "PostHistoryTypeId": "1", "PostId": "65671433", "RevisionGUID": "215ce178-196f-42bf-a32b-7b97961816c8", "CreationDate": "2021-01-11T17:08:58.697", "UserId": "14979614", "Text": "Terraform multiple instance types from count?", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "Terraform multiple instance types from count?", "keywords": ["instance"]}]}, {"Id": "238539534", "PostHistoryTypeId": "3", "PostId": "65671433", "RevisionGUID": "215ce178-196f-42bf-a32b-7b97961816c8", "CreationDate": "2021-01-11T17:08:58.697", "UserId": "14979614", "Text": "<terraform>", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "answers": [{"Id": "65672454", "PostTypeId": "2", "ParentId": "65671433", "CreationDate": "2021-01-11T18:19:36.133", "Score": "2", "Body": "<p>The answer that is the smallest change to what you already tried would be something like the following, but it has some caveats which I'll describe afterwards.</p>\n<pre><code>variable &quot;instance_types&quot; {\n  type = list(string)\n}\n\nresource &quot;aws_instance&quot; &quot;example&quot; {\n  count = length(var.instance_types)\n\n  instance_type = var.instance_types[count.index]\n  # etc...\n}\n</code></pre>\n<p>The above uses <code>count.index</code> in order to correlate the numbered instances of <code>aws_instance.example</code> with the element indices in <code>var.instance_types</code>, getting the result I think you were looking for.</p>\n<p>A significant caveat with this solution is that it makes the indices of the elements in <code>var.instance_type</code> be the unique identifiers for your instances as far as Terraform is concerned. If you run <code>terraform plan</code> with the above then you'll see Terraform plan instances with addresses like this:</p>\n<ul>\n<li><code>aws_instance.example[0]</code> with <code>instance_type = &quot;t2.micro&quot;</code></li>\n<li><code>aws_instance.example[1]</code> with <code>instance_type = &quot;t2.small&quot;</code></li>\n<li><code>aws_instance.example[2]</code> with <code>instance_type = &quot;t2.medium&quot;</code></li>\n</ul>\n<p>When designing a Terraform module it's important to consider how it will respond to changes in the future, because the infrastructure you describe with Terraform typically stays running &quot;indefinitely&quot; and we want to avoid replacing it wherever possbile.</p>\n<p>Given that, consider what would happen if you were to add a new element at the <em>start</em> of your list of instance types:</p>\n<pre><code>  instance_types = [\n    &quot;m3.medium&quot;,\n    &quot;t2.micro&quot;,\n    &quot;t2.small&quot;,\n    &quot;t2.medium&quot;,\n  ]\n</code></pre>\n<p>If you run <code>terraform plan</code> again, then Terraform will once again correlate list element indices with resource instance identifiers, and will make a plan like this:</p>\n<ul>\n<li><code>aws_instance.example[0]</code> with <code>~ instance_type = &quot;t2.micro&quot; -&gt; &quot;m3.medium&quot;</code></li>\n<li><code>aws_instance.example[1]</code> with <code>~ instance_type = &quot;t2.small&quot; -&gt; &quot;t2.micro&quot;</code></li>\n<li><code>aws_instance.example[2]</code> with <code>~ instance_type = &quot;t2.medium&quot; -&gt; &quot;t2.small&quot;</code></li>\n<li><code>aws_instance.example[3]</code> with <code>+ instance_type = &quot;t2.medium&quot;</code></li>\n</ul>\n<p>It's not possible to change the instance type of an EC2 instance after it's running, so the AWS provider will therefore plan to <em>replace</em> the three existing instances in order to apply this change. &quot;Replace&quot; here means to destroy the existing object and create a new one instead, which would therefore lose any state on those instances and possibly cause downtime.</p>\n<hr />\n<p>A typical answer to this concern is to use meaningful identifier strings for the instances instead of just positions in a list. You can do that by changing your variable to be a map, whose keys are the meaningful identifiers, and then using <a href=\"https://www.terraform.io/docs/configuration/meta-arguments/for_each.html\" rel=\"nofollow noreferrer\"><code>for_each</code></a> instead of <a href=\"https://www.terraform.io/docs/configuration/meta-arguments/count.html\" rel=\"nofollow noreferrer\"><code>count</code></a>:</p>\n<pre><code>variable &quot;instance_types&quot; {\n  type = map(string)\n}\n\nresource &quot;aws_instance&quot; &quot;example&quot; {\n  for_each = var.instance_types\n\n  instance_type = each.value\n  # etc...\n}\n</code></pre>\n<p>In this case you might populate the <code>instance_types</code> variable with a map whose keys are names that describe to human maintainers what each of the instances is for:</p>\n<pre><code>  instance_types = {\n    worker   = &quot;t2.micro&quot;\n    web      = &quot;t2.small&quot;\n    database = &quot;t2.medium&quot;\n  }\n</code></pre>\n<p>When you use <code>for_each</code>, Terraform uses the keys from the map as the instance identifiers, so your plan will now look like this instead:</p>\n<ul>\n<li><code>aws_instance.example[&quot;worker&quot;]</code> with <code>instance_type = &quot;t2.micro&quot;</code></li>\n<li><code>aws_instance.example[&quot;web&quot;]</code> with <code>instance_type = &quot;t2.small&quot;</code></li>\n<li><code>aws_instance.example[&quot;database&quot;]</code> with <code>instance_type = &quot;t2.medium&quot;</code></li>\n</ul>\n<p>Now if you want to add a new instance later you can add a new element to the map, with a new unique key, and Terraform will understand that you intend to add a new instance and leave all of the other instances unchanged.</p>\n", "OwnerUserId": "281848", "LastActivityDate": "2021-01-11T18:19:36.133", "CommentCount": "1", "ContentLicense": "CC BY-SA 4.0", "comments": [{"Id": "116115440", "PostId": "65672454", "Score": "0", "Text": "Thanks for the in depth answer Martin.  That greatly improves my understanding of how to achieve this in a few different ways", "CreationDate": "2021-01-11T20:38:09.057", "UserId": "14979614", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "history": [{"Id": "238543889", "PostHistoryTypeId": "2", "PostId": "65672454", "RevisionGUID": "7aeccea9-2a46-4f69-9e74-2eb78233b205", "CreationDate": "2021-01-11T18:19:36.133", "UserId": "281848", "Text": "The answer that is the smallest change to what you already tried would be something like the following, but it has some caveats which I'll describe afterwards.\r\n\r\n```\r\nvariable \"instance_types\" {\r\n  type = list(string)\r\n}\r\n\r\nresource \"aws_instance\" \"example\" {\r\n  count = length(var.instance_types)\r\n\r\n  instance_type = var.instance_types[count.index]\r\n  # etc...\r\n}\r\n```\r\n\r\nThe above uses `count.index` in order to correlate the numbered instances of `aws_instance.example` with the element indices in `var.instance_types`, getting the result I think you were looking for.\r\n\r\nA significant caveat with this solution is that it makes the indices of the elements in `var.instance_type` be the unique identifiers for your instances as far as Terraform is concerned. If you run `terraform plan` with the above then you'll see Terraform plan instances with addresses like this:\r\n\r\n* `aws_instance.example[0]` with `instance_type = \"t2.micro\"`\r\n* `aws_instance.example[1]` with `instance_type = \"t2.small\"`\r\n* `aws_instance.example[2]` with `instance_type = \"t2.medium\"`\r\n\r\nWhen designing a Terraform module it's important to consider how it will respond to changes in the future, because the infrastructure you describe with Terraform typically stays running \"indefinitely\" and we want to avoid replacing it wherever possbile.\r\n\r\nGiven that, consider what would happen if you were to add a new element at the _start_ of your list of instance types:\r\n\r\n```\r\n  instance_types = [\r\n    \"m3.medium\",\r\n    \"t2.micro\",\r\n    \"t2.small\",\r\n    \"t2.medium\",\r\n  ]\r\n```\r\n\r\nIf you run `terraform plan` again, then Terraform will once again correlate list element indices with resource instance identifiers, and will make a plan like this:\r\n\r\n* `aws_instance.example[0]` with `~ instance_type = \"t2.micro\" -> \"m3.medium\"`\r\n* `aws_instance.example[1]` with `~ instance_type = \"t2.small\" -> \"t2.micro\"`\r\n* `aws_instance.example[2]` with `~ instance_type = \"t2.medium\" -> \"t2.small\"`\r\n* `aws_instance.example[3]` with `+ instance_type = \"t2.medium\"`\r\n\r\nIt's not possible to change the instance type of an EC2 instance after it's running, so the AWS provider will therefore plan to _replace_ the three existing instances in order to apply this change. \"Replace\" here means to destroy the existing object and create a new one instead, which would therefore lose any state on those instances and possibly cause downtime.\r\n\r\n---\r\n\r\nA typical answer to this concern is to use meaningful identifier strings for the instances instead of just positions in a list. You can do that by changing your variable to be a map, whose keys are the meaningful identifiers, and then using [`for_each`](https://www.terraform.io/docs/configuration/meta-arguments/for_each.html) instead of [`count`](https://www.terraform.io/docs/configuration/meta-arguments/count.html):\r\n\r\n```\r\nvariable \"instance_types\" {\r\n  type = map(string)\r\n}\r\n\r\nresource \"aws_instance\" \"example\" {\r\n  for_each = var.instance_types\r\n\r\n  instance_type = each.value\r\n  # etc...\r\n}\r\n```\r\n\r\nIn this case you might populate the `instance_types` variable with a map whose keys are names that describe to human maintainers what each of the instances is for:\r\n\r\n```\r\n  instance_types = {\r\n    worker   = \"t2.micro\"\r\n    web      = \"t2.small\"\r\n    database = \"t2.medium\"\r\n  }\r\n```\r\n\r\nWhen you use `for_each`, Terraform uses the keys from the map as the instance identifiers, so your plan will now look like this instead:\r\n\r\n* `aws_instance.example[\"worker\"]` with `instance_type = \"t2.micro\"`\r\n* `aws_instance.example[\"web\"]` with `instance_type = \"t2.small\"`\r\n* `aws_instance.example[\"database\"]` with `instance_type = \"t2.medium\"`\r\n\r\nNow if you want to add a new instance later you can add a new element to the map, with a new unique key, and Terraform will understand that you intend to add a new instance and leave all of the other instances unchanged.\r\n", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "The answer that is the smallest change to what you already tried would be something like the following, but it has some caveats which I'll describe afterwards. ", "keywords": ["change"]}, {"source": "Text", "text": "When designing a Terraform module it's important to consider how it will respond to changes in the future, because the infrastructure you describe with Terraform typically stays running \"indefinitely\" and we want to avoid replacing it wherever possbile. ", "keywords": ["change"]}, {"source": "Text", "text": "Given that, consider what would happen if you were to add a new element at the _start_ of your list of instance types: ``` instance_types = [ \"m3.medium\", \"t2.micro\", \"t2.small\", \"t2.medium\", ] ``` ", "keywords": ["instance"]}, {"source": "Text", "text": "If you run `terraform plan` again, then Terraform will once again correlate list element indices with resource instance identifiers, and will make a plan like this: * `aws_instance.example[0]` with `~ instance_type = \"t2.micro\" -> \"m3.medium\"` * `aws_instance.example[1]` with `~ instance_type = \"t2.small\" -> \"t2.micro\"` * `aws_instance.example[2]` with `~ instance_type = \"t2.medium\" -> \"t2.small\"` * `aws_instance.example[3]` with `+ instance_type = \"t2.medium\"` ", "keywords": ["instance"]}, {"source": "Text", "text": "It's not possible to change the instance type of an EC2 instance after it's running, so the AWS provider will therefore plan to _replace_ the three existing instances in order to apply this change. ", "keywords": ["instance", "provider", "change"]}, {"source": "Text", "text": "You can do that by changing your variable to be a map, whose keys are the meaningful identifiers, and then using [`for_each`](https://www.terraform.io/docs/configuration/meta-arguments/for_each.html) instead of [`count`](https://www.terraform.io/docs/configuration/meta-arguments/count.html): ``` variable \"instance_types\" { type = map(string) } resource \"aws_instance\" \"example\" { for_each = var.instance_types instance_type = each.value # etc... } ``` In this case you might populate the `instance_types` variable with a map whose keys are names that describe to human maintainers what each of the instances is for: ``` instance_types = { worker = \"t2.micro\" web = \"t2.small\" database = \"t2.medium\" } ``` ", "keywords": ["change"]}, {"source": "Text", "text": "When you use `for_each`, Terraform uses the keys from the map as the instance identifiers, so your plan will now look like this instead: * `aws_instance.example[\"worker\"]` with `instance_type = \"t2.micro\"` * `aws_instance.example[\"web\"]` with `instance_type = \"t2.small\"` * `aws_instance.example[\"database\"]` with `instance_type = \"t2.medium\"` ", "keywords": ["instance"]}, {"source": "Text", "text": "Now if you want to add a new instance later you can add a new element to the map, with a new unique key, and Terraform will understand that you intend to add a new instance and leave all of the other instances unchanged", "keywords": ["instance"]}]}], "filtered-sentences": [{"source": "Body", "text": "The answer that is the smallest change to what you already tried would be something like the following, but it has some caveats which I'll describe afterwards. ", "keywords": ["change"]}, {"source": "Body", "text": "When designing a Terraform module it's important to consider how it will respond to changes in the future, because the infrastructure you describe with Terraform typically stays running \"indefinitely\" and we want to avoid replacing it wherever possbile. ", "keywords": ["change"]}, {"source": "Body", "text": "Given that, consider what would happen if you were to add a new element at the start of your list of instance types: ", "keywords": ["instance"]}, {"source": "Body", "text": "If you run terraform plan again, then Terraform will once again correlate list element indices with resource instance identifiers, and will make a plan like this: aws_instance.example[0] with ~ instance_type = \"t2.micro\" -> \"m3.medium\" aws_instance.example[1] with ~ instance_type = \"t2.small\" -> \"t2.micro\" aws_instance.example[2] with ~ instance_type = \"t2.medium\" -> \"t2.small\" aws_instance.example[3] with + instance_type = \"t2.medium\" It's not possible to change the instance type of an EC2 instance after it's running, so the AWS provider will therefore plan to replace the three existing instances in order to apply this change. ", "keywords": ["instance", "provider", "change"]}, {"source": "Body", "text": "You can do that by changing your variable to be a map, whose keys are the meaningful identifiers, and then using for_each instead of count: ", "keywords": ["change"]}, {"source": "Body", "text": "In this case you might populate the instance_types variable with a map whose keys are names that describe to human maintainers what each of the instances is for: When you use for_each, Terraform uses the keys from the map as the instance identifiers, so your plan will now look like this instead: aws_instance.example[\"worker\"] with instance_type = \"t2.micro\" aws_instance.example[\"web\"] with instance_type = \"t2.small\" aws_instance.example[\"database\"] with instance_type = \"t2.medium\" Now if you want to add a new instance later you can add a new element to the map, with a new unique key, and Terraform will understand that you intend to add a new instance and leave all of the other instances unchanged.", "keywords": ["instance"]}]}], "contains-topic": true, "filtered-sentences": [{"source": "Title", "text": "Terraform multiple instance types from count?", "keywords": ["instance"]}, {"source": "Body", "text": "I was looking to see if there if there is something I can do that will allow me to deploy 3 EC2 instances of different instance types? ", "keywords": ["instance"]}, {"source": "Body", "text": "Clearly below doesnt work but I cant see anything online on the most efficient way of performing this.", "keywords": ["efficient"]}]}