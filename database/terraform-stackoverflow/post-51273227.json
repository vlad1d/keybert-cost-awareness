{"Id": "51273227", "PostTypeId": "1", "AcceptedAnswerId": "66307357", "CreationDate": "2018-07-10T20:10:08.623", "Score": "61", "ViewCount": "20818", "Body": "<p>I have a Terraform configuration targeting deployment on AWS. It applies beautifully when using an IAM user that has permission to do anything (i.e. <code>{actions: [\"*\"], resources: [\"*\"]}</code>. </p>\n\n<p>In pursuit of automating the application of this Terraform configuration, I want to determine the <em>minimum</em> set of permissions necessary to apply the configuration initially and effect subsequent changes. I specifically want to avoid giving overbroad permissions in policy, e.g. <code>{actions: [\"s3:*\"], resources: [\"*\"]}</code>.</p>\n\n<p>So far, I'm simply running <code>terraform apply</code> until an error occurs. I look at the output or at the terraform log output to see what API call failed and then add it to the deployment user policy. EC2 and S3 are particularly frustrating because the name of the actions seems to not necessarily align with the API method name. I'm several hours into this with easy way to tell how far long I am.</p>\n\n<p><strong>Is there a more efficient way to do this?</strong> </p>\n\n<p>It'd be really nice if Terraform advised me what permission/action I need but that's a product enhancement best left to Hashicorp.</p>\n", "OwnerUserId": "204052", "LastEditorUserId": "400222", "LastEditDate": "2018-07-11T04:20:26.813", "LastActivityDate": "2023-02-28T13:20:05.000", "Title": "What's the most efficient way to determine the minimum AWS permissions necessary for a Terraform configuration?", "Tags": "<amazon-web-services><terraform>", "AnswerCount": "9", "CommentCount": "2", "FavoriteCount": "0", "ContentLicense": "CC BY-SA 4.0", "comments": [{"Id": "89572526", "PostId": "51273227", "Score": "5", "Text": "Note that applying these from a clean slate will not give you the total permissions needed to manage these resources! Consider updating or deleting these resources in the future... you may need additional permissions to do these actions.", "CreationDate": "2018-07-12T05:14:41.370", "UserId": "9443614", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "89675937", "PostId": "51273227", "Score": "2", "Text": "That's a very important distinction, @EricJohnson. Thanks for pointing that out. I'd love recommendations on how to account for that, as well.", "CreationDate": "2018-07-15T19:53:02.863", "UserId": "204052", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "history": [{"Id": "177368551", "PostHistoryTypeId": "2", "PostId": "51273227", "RevisionGUID": "defbd66a-ee46-4a9b-a722-fd49aeecbbbb", "CreationDate": "2018-07-10T20:10:08.623", "UserId": "204052", "Text": "I have a Terraform configuration targeting deployment on AWS. It applies beautifully when using an IAM user that has permission to do anything (i.e. `{actions: [\"*\"], resources: [\"*\"]}`. \r\n\r\nIn pursuit of automating the application of this Terraform configuration, I want to determine the _minimum_ set of permissions necessary to apply the configuration initially and effect subsequent changes. I specifically want to avoid giving overbroad permissions in policy, e.g. `{actions: [\"s3:*\"], resources: [\"*\"]}`.\r\n\r\nSo far, I'm simply running `terraform apply` until an error occurs. I look at the output or at the terraform log output to see what API call failed and then add it to the deployment user policy. EC2 and S3 are particularly frustrating because the name of the actions seems to not necessarily align with the API method name. I'm several hours into this with easy way to tell how far long I am.\r\n\r\n**Is there a more efficient way to do this?** \r\n\r\nIt'd be really nice if Terraform advised me what permission/action I need but that's a product enhancement best left to Hashicorp.", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "In pursuit of automating the application of this Terraform configuration, I want to determine the _minimum_ set of permissions necessary to apply the configuration initially and effect subsequent changes. ", "keywords": ["change"]}, {"source": "Text", "text": "I specifically want to avoid giving overbroad permissions in policy, e.g. `{actions: [\"s3:*\"], resources: [\"*\"]}`. ", "keywords": ["policy"]}, {"source": "Text", "text": "I look at the output or at the terraform log output to see what API call failed and then add it to the deployment user policy. ", "keywords": ["policy"]}, {"source": "Text", "text": "**Is there a more efficient way to do this?** ", "keywords": ["efficient"]}]}, {"Id": "177368552", "PostHistoryTypeId": "1", "PostId": "51273227", "RevisionGUID": "defbd66a-ee46-4a9b-a722-fd49aeecbbbb", "CreationDate": "2018-07-10T20:10:08.623", "UserId": "204052", "Text": "What's the most efficient way to determine the minimum AWS permissions necessary for a Terraform configuration?", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "What's the most efficient way to determine the minimum AWS permissions necessary for a Terraform configuration?", "keywords": ["efficient"]}]}, {"Id": "177368553", "PostHistoryTypeId": "3", "PostId": "51273227", "RevisionGUID": "defbd66a-ee46-4a9b-a722-fd49aeecbbbb", "CreationDate": "2018-07-10T20:10:08.623", "UserId": "204052", "Text": "<amazon-web-services><build-automation><terraform><continuous-delivery>", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "177384802", "PostHistoryTypeId": "6", "PostId": "51273227", "RevisionGUID": "2ea1e881-3cb2-4b41-b032-b6812d49002c", "CreationDate": "2018-07-11T04:20:26.813", "UserId": "400222", "Comment": "edited tags", "Text": "<amazon-web-services><terraform>", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "223739766", "PostHistoryTypeId": "33", "PostId": "51273227", "RevisionGUID": "97806984-412b-4a72-a26c-301e77b49ed9", "CreationDate": "2020-06-10T09:45:45.920", "UserId": "597473", "Comment": "207700", "filtered-sentences": []}, {"Id": "224041064", "PostHistoryTypeId": "34", "PostId": "51273227", "RevisionGUID": "eac00284-a71e-438f-8dfa-1012d2eb9190", "CreationDate": "2020-06-14T10:09:44.647", "UserId": "597473", "Comment": "207700", "filtered-sentences": []}], "answers": [{"Id": "71017848", "PostTypeId": "2", "ParentId": "51273227", "CreationDate": "2022-02-07T11:32:13.333", "Score": "4", "Body": "<p>The tracking of minimum permissions is now provided by AWS itself. <a href=\"https://aws.amazon.com/blogs/security/iam-access-analyzer-makes-it-easier-to-implement-least-privilege-permissions-by-generating-iam-policies-based-on-access-activity/\" rel=\"nofollow noreferrer\">https://aws.amazon.com/blogs/security/iam-access-analyzer-makes-it-easier-to-implement-least-privilege-permissions-by-generating-iam-policies-based-on-access-activity/</a>.</p>\n<p>If you wanted to be picky about the minimum viable permission principle, you could use CloudFormation StackSets to deploy different roles with minimum permissions, so Terraform could assume them on each module call via different providers, i.e. if you have a module that deploys ASGs, LBs and EC2 instances, then:</p>\n<ul>\n<li>include those actions in a role where the workload lives</li>\n<li>add an terraform aws provider block that <a href=\"https://registry.terraform.io/providers/hashicorp/aws/latest/docs#assume-role\" rel=\"nofollow noreferrer\">assumes</a> that role</li>\n<li>use that <a href=\"https://learn.hashicorp.com/tutorials/terraform/aws-assumerole#review-ec2-instance-configuration\" rel=\"nofollow noreferrer\">provider block</a> within the module call.</li>\n</ul>\n<p>The burden is to manage possibly quite a few terraform roles, but as I said, if you want to be picky or you have customer requirements to shrink down terraform user's permissions.</p>\n<p>You could also download the CloudTrail event history for the last X days (up to 90) and run the following:</p>\n<pre><code>cat event_history.json &lt;(echo &quot;]}&quot;) | jq '[.Records[] | .eventName] | unique'\n</code></pre>\n<p>The echo thing is due to the file being too big and shrunk (unknown reason) when downloaded from CloudTrail's page. You can see it below:</p>\n<pre><code>&gt; jsonlint event_history.json\nError: Parse error on line 1:\n...iam.amazonaws.com&quot;}}\n-----------------------^\nExpecting ',', ']', got 'EOF'\n    at Object.parseError (/usr/local/Cellar/jsonlint/1.6.0/libexec/lib/node_modules/jsonlint/lib/jsonlint.js:55:11)\n    at Object.parse (/usr/local/Cellar/jsonlint/1.6.0/libexec/lib/node_modules/jsonlint/lib/jsonlint.js:132:22)\n    at parse (/usr/local/Cellar/jsonlint/1.6.0/libexec/lib/node_modules/jsonlint/lib/cli.js:82:14)\n    at main (/usr/local/Cellar/jsonlint/1.6.0/libexec/lib/node_modules/jsonlint/lib/cli.js:136:14)\n    at Object.&lt;anonymous&gt; (/usr/local/Cellar/jsonlint/1.6.0/libexec/lib/node_modules/jsonlint/lib/cli.js:178:1)\n    at Module._compile (node:internal/modules/cjs/loader:1097:14)\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1149:10)\n    at Module.load (node:internal/modules/cjs/loader:975:32)\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:77:12)\n</code></pre>\n", "OwnerUserId": "14491866", "LastEditorUserId": "14491866", "LastEditDate": "2022-02-08T18:33:25.840", "LastActivityDate": "2022-02-08T18:33:25.840", "CommentCount": "0", "ContentLicense": "CC BY-SA 4.0", "history": [{"Id": "263588374", "PostHistoryTypeId": "2", "PostId": "71017848", "RevisionGUID": "04ef357d-e14a-4fa3-9ebc-ec029c8fc7dc", "CreationDate": "2022-02-07T11:32:13.333", "UserId": "14491866", "Text": "The tracking of minimum permissions is now provided by AWS itself. https://aws.amazon.com/blogs/security/iam-access-analyzer-makes-it-easier-to-implement-least-privilege-permissions-by-generating-iam-policies-based-on-access-activity/.\r\n\r\nIf you wanted to be picky about the minimum viable permission principle, you could use CloudFormation StackSets to deploy different roles with minimum permissions, so Terraform could assume them on each module call via different providers, i.e. if you have a module that deploys ASGs, LBs and EC2 instances, then:\r\n\r\n - include those actions in a role where the workload lives\r\n - add an terraform aws provider block that [assumes][1] that role\r\n - use that [provider block][2] within the module call.\r\n\r\nThe burden is to manage possibly quite a few terraform roles, but as I said, if you want to be picky or you have customer requirements to shrink down terraform user's permissions.\r\n\r\n\r\n  [1]: https://registry.terraform.io/providers/hashicorp/aws/latest/docs#assume-role\r\n  [2]: https://learn.hashicorp.com/tutorials/terraform/aws-assumerole#review-ec2-instance-configuration", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "If you wanted to be picky about the minimum viable permission principle, you could use CloudFormation StackSets to deploy different roles with minimum permissions, so Terraform could assume them on each module call via different providers, i.e. if you have a module that deploys ASGs, LBs and EC2 instances, then: - include those actions in a role where the workload lives - add an terraform aws provider block that [assumes][1] that role - use that [provider block][2] within the module call. ", "keywords": ["provider"]}, {"source": "Text", "text": "The burden is to manage possibly quite a few terraform roles, but as I said, if you want to be picky or you have customer requirements to shrink down terraform user's permissions. [1]: https://registry.terraform.io/providers/hashicorp/aws/latest/docs#assume-role [2]: https://learn.hashicorp.com/tutorials/terraform/aws-assumerole#review-ec2-instance-configuration", "keywords": ["instance"]}]}, {"Id": "263689719", "PostHistoryTypeId": "5", "PostId": "71017848", "RevisionGUID": "39d353cc-3c54-4da4-ad78-92b4220597e1", "CreationDate": "2022-02-08T16:33:40.957", "UserId": "14491866", "Comment": "added 195 characters in body", "Text": "The tracking of minimum permissions is now provided by AWS itself. https://aws.amazon.com/blogs/security/iam-access-analyzer-makes-it-easier-to-implement-least-privilege-permissions-by-generating-iam-policies-based-on-access-activity/.\r\n\r\nIf you wanted to be picky about the minimum viable permission principle, you could use CloudFormation StackSets to deploy different roles with minimum permissions, so Terraform could assume them on each module call via different providers, i.e. if you have a module that deploys ASGs, LBs and EC2 instances, then:\r\n\r\n - include those actions in a role where the workload lives\r\n - add an terraform aws provider block that [assumes][1] that role\r\n - use that [provider block][2] within the module call.\r\n\r\nThe burden is to manage possibly quite a few terraform roles, but as I said, if you want to be picky or you have customer requirements to shrink down terraform user's permissions.\r\n\r\nYou could also download the CloudTrail event history for the last X days (up to 90) and run the following:\r\n\r\n    cat event_history.json <(echo \"]}\") | jq '[.Records[] | .eventName] | unique'\r\n\r\n\r\n  [1]: https://registry.terraform.io/providers/hashicorp/aws/latest/docs#assume-role\r\n  [2]: https://learn.hashicorp.com/tutorials/terraform/aws-assumerole#review-ec2-instance-configuration", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "If you wanted to be picky about the minimum viable permission principle, you could use CloudFormation StackSets to deploy different roles with minimum permissions, so Terraform could assume them on each module call via different providers, i.e. if you have a module that deploys ASGs, LBs and EC2 instances, then: - include those actions in a role where the workload lives - add an terraform aws provider block that [assumes][1] that role - use that [provider block][2] within the module call. ", "keywords": ["provider"]}, {"source": "Text", "text": "You could also download the CloudTrail event history for the last X days (up to 90) and run the following: cat event_history.json <(echo \"]}\") | jq '[.Records[] | .eventName] | unique' [1]: https://registry.terraform.io/providers/hashicorp/aws/latest/docs#assume-role [2]: https://learn.hashicorp.com/tutorials/terraform/aws-assumerole#review-ec2-instance-configuration", "keywords": ["instance"]}]}, {"Id": "263698164", "PostHistoryTypeId": "5", "PostId": "71017848", "RevisionGUID": "564bb973-8638-4838-89eb-e4dcfb2a70b4", "CreationDate": "2022-02-08T18:33:25.840", "UserId": "14491866", "Comment": "added 1212 characters in body", "Text": "The tracking of minimum permissions is now provided by AWS itself. https://aws.amazon.com/blogs/security/iam-access-analyzer-makes-it-easier-to-implement-least-privilege-permissions-by-generating-iam-policies-based-on-access-activity/.\r\n\r\nIf you wanted to be picky about the minimum viable permission principle, you could use CloudFormation StackSets to deploy different roles with minimum permissions, so Terraform could assume them on each module call via different providers, i.e. if you have a module that deploys ASGs, LBs and EC2 instances, then:\r\n\r\n - include those actions in a role where the workload lives\r\n - add an terraform aws provider block that [assumes][1] that role\r\n - use that [provider block][2] within the module call.\r\n\r\nThe burden is to manage possibly quite a few terraform roles, but as I said, if you want to be picky or you have customer requirements to shrink down terraform user's permissions.\r\n\r\nYou could also download the CloudTrail event history for the last X days (up to 90) and run the following:\r\n\r\n    cat event_history.json <(echo \"]}\") | jq '[.Records[] | .eventName] | unique'\r\n\r\nThe echo thing is due to the file being too big and shrunk (unknown reason) when downloaded from CloudTrail's page. You can see it below:\r\n\r\n    > jsonlint event_history.json\r\n    Error: Parse error on line 1:\r\n    ...iam.amazonaws.com\"}}\r\n    -----------------------^\r\n    Expecting ',', ']', got 'EOF'\r\n        at Object.parseError (/usr/local/Cellar/jsonlint/1.6.0/libexec/lib/node_modules/jsonlint/lib/jsonlint.js:55:11)\r\n        at Object.parse (/usr/local/Cellar/jsonlint/1.6.0/libexec/lib/node_modules/jsonlint/lib/jsonlint.js:132:22)\r\n        at parse (/usr/local/Cellar/jsonlint/1.6.0/libexec/lib/node_modules/jsonlint/lib/cli.js:82:14)\r\n        at main (/usr/local/Cellar/jsonlint/1.6.0/libexec/lib/node_modules/jsonlint/lib/cli.js:136:14)\r\n        at Object.<anonymous> (/usr/local/Cellar/jsonlint/1.6.0/libexec/lib/node_modules/jsonlint/lib/cli.js:178:1)\r\n        at Module._compile (node:internal/modules/cjs/loader:1097:14)\r\n        at Object.Module._extensions..js (node:internal/modules/cjs/loader:1149:10)\r\n        at Module.load (node:internal/modules/cjs/loader:975:32)\r\n        at Function.Module._load (node:internal/modules/cjs/loader:822:12)\r\n        at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:77:12)\r\n\r\n  [1]: https://registry.terraform.io/providers/hashicorp/aws/latest/docs#assume-role\r\n  [2]: https://learn.hashicorp.com/tutorials/terraform/aws-assumerole#review-ec2-instance-configuration", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "If you wanted to be picky about the minimum viable permission principle, you could use CloudFormation StackSets to deploy different roles with minimum permissions, so Terraform could assume them on each module call via different providers, i.e. if you have a module that deploys ASGs, LBs and EC2 instances, then: - include those actions in a role where the workload lives - add an terraform aws provider block that [assumes][1] that role - use that [provider block][2] within the module call. ", "keywords": ["provider"]}, {"source": "Text", "text": "You can see it below: > jsonlint event_history.json Error: Parse error on line 1: ...iam.amazonaws.com\"}} -----------------------^ Expecting ',', ']', got 'EOF' at Object.parseError (/usr/local/Cellar/jsonlint/1.6.0/libexec/lib/node_modules/jsonlint/lib/jsonlint.js:55:11) at Object.parse (/usr/local/Cellar/jsonlint/1.6.0/libexec/lib/node_modules/jsonlint/lib/jsonlint.js:132:22) at parse (/usr/local/Cellar/jsonlint/1.6.0/libexec/lib/node_modules/jsonlint/lib/cli.js:82:14) at main (/usr/local/Cellar/jsonlint/1.6.0/libexec/lib/node_modules/jsonlint/lib/cli.js:136:14) at Object. (/usr/local/Cellar/jsonlint/1.6.0/libexec/lib/node_modules/jsonlint/lib/cli.js:178:1) at Module._compile (node:internal/modules/cjs/loader:1097:14) at Object.Module._extensions..js (node:internal/modules/cjs/loader:1149:10) at Module.load (node:internal/modules/cjs/loader:975:32) at Function.Module._load (node:internal/modules/cjs/loader:822:12) at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:77:12) [1]: https://registry.terraform.io/providers/hashicorp/aws/latest/docs#assume-role [2]: https://learn.hashicorp.com/tutorials/terraform/aws-assumerole#review-ec2-instance-configuration", "keywords": ["instance"]}]}], "filtered-sentences": [{"source": "Body", "text": "If you wanted to be picky about the minimum viable permission principle, you could use CloudFormation StackSets to deploy different roles with minimum permissions, so Terraform could assume them on each module call via different providers, i.e. if you have a module that deploys ASGs, LBs and EC2 instances, then: include those actions in a role where the workload lives add an terraform aws provider block that assumes that role use that provider block within the module call. ", "keywords": ["provider"]}]}, {"Id": "70807185", "PostTypeId": "2", "ParentId": "51273227", "CreationDate": "2022-01-21T20:15:16.810", "Score": "3", "Body": "<p>As an addition to either of <code>TF_LOG=trace</code> /  iamlive / CloudTrail approaches suggested before, please also note that to capture a complete set of actions required to manage a configuration (create/update/delete resources) one would need to actually apply three configurations:</p>\n<ol>\n<li>Original one, to capture actions required to create resources.</li>\n<li>Mutated one with as many resource arguments changed as possible, to capture actions required to update resources inplace.</li>\n<li>Empty one (applied last) or <code>terraform destroy</code> to capture actions required to delete resources.</li>\n</ol>\n<p>While configurations 1 and 3 are common to consider, configuration 2 is sometimes overlooked and it can be a tedious one to prepare. Without it Terraform will fail to apply changes that modify resources instead of deleting and recreating them.</p>\n", "OwnerUserId": "3206908", "LastActivityDate": "2022-01-21T20:15:16.810", "CommentCount": "0", "ContentLicense": "CC BY-SA 4.0", "history": [{"Id": "262465832", "PostHistoryTypeId": "2", "PostId": "70807185", "RevisionGUID": "8bd3cbfc-893b-4f33-8be7-d11e7f6cb50e", "CreationDate": "2022-01-21T20:15:16.810", "UserId": "3206908", "Text": "As an addition to either of `TF_LOG=trace` /  iamlive / CloudTrail approaches suggested before, please also note that to capture a complete set of actions required to manage a configuration (create/update/delete resources) one would need to actually apply three configurations:\r\n1. Original one, to capture actions required to create resources.\r\n2. Mutated one with as many resource arguments changed as possible, to capture actions required to update resources inplace.\r\n3. Empty one (applied last) or `terraform destroy` to capture actions required to delete resources.\r\n\r\nWhile configurations 1 and 3 are common to consider, configuration 2 is sometimes overlooked and it can be a tedious one to prepare. Without it Terraform will fail to apply changes that modify resources instead of deleting and recreating them.", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "2. Mutated one with as many resource arguments changed as possible, to capture actions required to update resources inplace. ", "keywords": ["change"]}, {"source": "Text", "text": "Without it Terraform will fail to apply changes that modify resources instead of deleting and recreating them.", "keywords": ["change"]}]}], "filtered-sentences": [{"source": "Body", "text": "Mutated one with as many resource arguments changed as possible, to capture actions required to update resources inplace. ", "keywords": ["change"]}, {"source": "Body", "text": "Without it Terraform will fail to apply changes that modify resources instead of deleting and recreating them.", "keywords": ["change"]}]}, {"Id": "74001835", "PostTypeId": "2", "ParentId": "51273227", "CreationDate": "2022-10-09T02:53:09.677", "Score": "0", "Body": "<p>Here is an extension on <a href=\"https://stackoverflow.com/a/60542958/11297691\">AvnerSo's answer</a>:</p>\n<p><code>cat log.log | ack -o &quot;(?&lt;=DEBUG: Request )[^ ]*&quot; | sort -u</code></p>\n<p>This command outputs every unique AWS request that Terraform has logged.</p>\n<ol>\n<li>The <code>&quot;(?&lt;=DEBUG: Request )[^ ]*&quot;</code> pattern performs a negative lookahead to find the first word after the match.</li>\n<li>The <code>-o</code> flag only shows the match in the output.</li>\n<li><code>sort -u</code> selects the unique values from the list and sorts them.</li>\n</ol>\n", "OwnerUserId": "11297691", "LastEditorUserId": "11297691", "LastEditDate": "2022-10-09T03:05:45.653", "LastActivityDate": "2022-10-09T03:05:45.653", "CommentCount": "0", "ContentLicense": "CC BY-SA 4.0", "history": [{"Id": "279756997", "PostHistoryTypeId": "2", "PostId": "74001835", "RevisionGUID": "4365e38d-18ea-4361-a8e1-d8e8b49c88e4", "CreationDate": "2022-10-09T02:53:09.677", "UserId": "11297691", "Text": "Here is an extension on [AvnerSo's answer](https://stackoverflow.com/a/60542958/11297691):\r\n\r\n`cat log.log | ack -o \"(?<=DEBUG: Request )[^ ]*\" | sort -u`\r\n\r\nThis command outputs every unique AWS request that Terraform has logged.\r\n\r\n1. The `\"(?<=DEBUG: Request )[^ ]*\"` pattern performs a negative lookahead to find the first word after the match.\r\n2. The `-o` flag only shows the match in the output.\r\n3. `sort -u` selects the unique values from the list and outputs them.", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "279757184", "PostHistoryTypeId": "5", "PostId": "74001835", "RevisionGUID": "bbe9128c-1027-4d92-838d-4ba786f9b81a", "CreationDate": "2022-10-09T03:05:45.653", "UserId": "11297691", "Comment": "deleted 2 characters in body", "Text": "Here is an extension on [AvnerSo's answer](https://stackoverflow.com/a/60542958/11297691):\r\n\r\n`cat log.log | ack -o \"(?<=DEBUG: Request )[^ ]*\" | sort -u`\r\n\r\nThis command outputs every unique AWS request that Terraform has logged.\r\n\r\n1. The `\"(?<=DEBUG: Request )[^ ]*\"` pattern performs a negative lookahead to find the first word after the match.\r\n2. The `-o` flag only shows the match in the output.\r\n3. `sort -u` selects the unique values from the list and sorts them.", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "filtered-sentences": []}, {"Id": "74154442", "PostTypeId": "2", "ParentId": "51273227", "CreationDate": "2022-10-21T13:32:09.983", "Score": "1", "Body": "<p>Another option in addition to the previous answers is:</p>\n<ul>\n<li>give broad permissions <code>&quot;s3:*&quot;, ...</code> as explained earlier</li>\n<li>Check the <a href=\"https://aws.amazon.com/about-aws/whats-new/2019/06/now-use-iam-access-advisor-with-aws-organizations-to-set-permission-guardrails-confidently/?nc1=h_ls\" rel=\"nofollow noreferrer\">AWS Access Advisor</a> tab in the AWS console for used permission and then trim down your permissions accordingly</li>\n</ul>\n", "OwnerUserId": "8054917", "LastActivityDate": "2022-10-21T13:32:09.983", "CommentCount": "1", "ContentLicense": "CC BY-SA 4.0", "comments": [{"Id": "134192712", "PostId": "74154442", "Score": "0", "Text": "Also, [AWS Access Analyzer](https://docs.aws.amazon.com/IAM/latest/UserGuide/what-is-access-analyzer.html) that can generate least privilege policies for you based on your usage.", "CreationDate": "2023-04-24T10:10:14.820", "UserId": "3486675", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "history": [{"Id": "280580435", "PostHistoryTypeId": "2", "PostId": "74154442", "RevisionGUID": "0ac7a3f1-ffb8-4997-8ff2-422b5c3d4904", "CreationDate": "2022-10-21T13:32:09.983", "UserId": "8054917", "Text": "Another option in addition to the previous answers is:\r\n- give broad permissions `\"s3:*\", ...` as explained earlier \r\n- Check the [AWS Access Advisor][1] tab in the AWS console for used permission and then trim down your permissions accordingly\r\n\r\n\r\n  [1]: https://aws.amazon.com/about-aws/whats-new/2019/06/now-use-iam-access-advisor-with-aws-organizations-to-set-permission-guardrails-confidently/?nc1=h_ls", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "filtered-sentences": []}, {"Id": "51277207", "PostTypeId": "2", "ParentId": "51273227", "CreationDate": "2018-07-11T04:20:06.143", "Score": "8", "Body": "<p>EDIT Feb 2021: there is a better way using iamlive and client side monitoring. Please see my other answer.</p>\n<p>As I guess that there's no perfect solution, treat this answer a bit as result of my brain storming. At least for the initial permission setup, I could imagine the following:</p>\n<p>Allow everything first and then process the CloudTrail logs to see, which API calls were made in a <code>terraform apply</code> / <code>destroy</code> cycle.</p>\n<p>Afterwards, you update the IAM policy to include exactly these calls.</p>\n", "OwnerUserId": "400222", "LastEditorUserId": "459877", "LastEditDate": "2021-12-11T20:12:21.550", "LastActivityDate": "2021-12-11T20:12:21.550", "CommentCount": "2", "ContentLicense": "CC BY-SA 4.0", "comments": [{"Id": "89675918", "PostId": "51277207", "Score": "4", "Text": "I think if I were to do this process again, I'd do it this way. I wonder if anyone has written a tool that is some kind of \"CloudTrail recorder\": it starts and filters out all but one user, then records each action that CloudTrail sees during a time period and spits out a list of those actions when complete.", "CreationDate": "2018-07-15T19:52:11.637", "UserId": "204052", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "117176546", "PostId": "51277207", "Score": "0", "Text": "this recommendation, and the @avnerso trace log one, work fine when you are setting up a project for the first time \u2014 that is, granting full power (step 1) is _feasible_. Any delta use case where there is the need to build a new feature for a production system can\u2019t use this method as it\u2019s too dangerous.", "CreationDate": "2021-02-19T13:33:31.773", "UserId": "1115762", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "Any delta use case where there is the need to build a new feature for a production system can\u2019t use this method as it\u2019s too dangerous.", "keywords": ["feature"]}]}], "history": [{"Id": "177384782", "PostHistoryTypeId": "2", "PostId": "51277207", "RevisionGUID": "df64dcd7-310d-4239-a6ec-96c34d7d3737", "CreationDate": "2018-07-11T04:20:06.143", "UserId": "400222", "Text": "As I guess that there's no perfect solution, treat this answer a bit as result of my brain storming. At least for the initial permission setup, I could imagine the following:\r\n\r\nAllow everything first and then process the CloudTrail logs to see, which API calls were made in a `terraform apply` / `destroy` cycle.\r\n\r\nAfterwards, you update the IAM policy to include exactly these calls.", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "Afterwards, you update the IAM policy to include exactly these calls.", "keywords": ["policy"]}]}, {"Id": "241283265", "PostHistoryTypeId": "5", "PostId": "51277207", "RevisionGUID": "01bf442b-16c0-4818-b3d0-0376259802ac", "CreationDate": "2021-02-21T21:35:11.517", "UserId": "400222", "Comment": "added 108 characters in body", "Text": "EDIT Feb 2022: there is a better way using iamlive and client side monitoring. Please see my other answer.\n\nAs I guess that there's no perfect solution, treat this answer a bit as result of my brain storming. At least for the initial permission setup, I could imagine the following:\r\n\r\nAllow everything first and then process the CloudTrail logs to see, which API calls were made in a `terraform apply` / `destroy` cycle.\r\n\r\nAfterwards, you update the IAM policy to include exactly these calls.", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "Afterwards, you update the IAM policy to include exactly these calls.", "keywords": ["policy"]}]}, {"Id": "259867026", "PostHistoryTypeId": "5", "PostId": "51277207", "RevisionGUID": "ec378ef6-bcb7-4561-9cae-2f26bd89d459", "CreationDate": "2021-12-11T20:12:21.550", "UserId": "459877", "Comment": "Fix date", "Text": "EDIT Feb 2021: there is a better way using iamlive and client side monitoring. Please see my other answer.\r\n\r\nAs I guess that there's no perfect solution, treat this answer a bit as result of my brain storming. At least for the initial permission setup, I could imagine the following:\r\n\r\nAllow everything first and then process the CloudTrail logs to see, which API calls were made in a `terraform apply` / `destroy` cycle.\r\n\r\nAfterwards, you update the IAM policy to include exactly these calls.", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "Afterwards, you update the IAM policy to include exactly these calls.", "keywords": ["policy"]}]}], "filtered-sentences": [{"source": "Body", "text": "Afterwards, you update the IAM policy to include exactly these calls.", "keywords": ["policy"]}]}, {"Id": "66307357", "PostTypeId": "2", "ParentId": "51273227", "CreationDate": "2021-02-21T21:33:47.560", "Score": "26", "Body": "<p>While I still believe that such super strict policy will be a continuous pain and likely kill productivity (but might depend on the project), there is now a tool for this.</p>\n<p><a href=\"https://github.com/iann0036/iamlive\" rel=\"noreferrer\">iamlive</a> uses the Client Side Monitoring feature of the AWS SDK to create a minimal policy based on the executed API calls. As Terraform uses the AWS SDK, this works here as well.</p>\n<p>In contrast to my previous (and accepted) answer, iamlive should even get the actual IAM actions right, which not necessarily match the API calls 1:1 (and which would be logged by CloudTrail).</p>\n<p>For this to work with terraform, you should do <code>export AWS_CSM_ENABLED=true</code></p>\n", "OwnerUserId": "400222", "LastEditorUserId": "400222", "LastEditDate": "2022-12-25T12:06:11.273", "LastActivityDate": "2022-12-25T12:06:11.273", "CommentCount": "3", "ContentLicense": "CC BY-SA 4.0", "comments": [{"Id": "119129743", "PostId": "66307357", "Score": "1", "Text": "This doesn't seem to work with terraform commands. From my testing, it only works with aws cli commands. Any thoughts?", "CreationDate": "2021-05-05T09:30:20.640", "UserId": "1512555", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "From my testing, it only works with aws cli commands. ", "keywords": ["test"]}]}, {"Id": "119137898", "PostId": "66307357", "Score": "1", "Text": "it absolutely does, I tried it myself. Just set up the correct environment variables", "CreationDate": "2021-05-05T14:20:31.587", "UserId": "400222", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "122569307", "PostId": "66307357", "Score": "3", "Text": "To be clear, the easiest way to get iamlive working with Terraform is to enable the 'AWS_CSM_ENABLED' environment variable via: 'export AWS_CSM_ENABLED=true'", "CreationDate": "2021-09-27T13:09:15.890", "UserId": "4768230", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "history": [{"Id": "241283229", "PostHistoryTypeId": "2", "PostId": "66307357", "RevisionGUID": "629cb5e0-c190-41dc-8e5c-5a80d84b3070", "CreationDate": "2021-02-21T21:33:47.560", "UserId": "400222", "Text": "While I still believe that such super strict policy will be a continuous pain and likely kill productivity (but might depend on the project), there is now a tool for this.\n\n[iamlive](https://github.com/iann0036/iamlive) uses the Client Side Monitoring feature of the AWS SDK to create a minimal policy based on the executed API calls. As Terraform uses the AWS SDK, this works here as well.\n\nIn contrast to my previous (and accepted) answer, iamlive should even get the actual IAM actions right, which not necessarily match the API calls 1:1 (and which would be logged by CloudTrail).", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "While I still believe that such super strict policy will be a continuous pain and likely kill productivity (but might depend on the project), there is now a tool for this. ", "keywords": ["policy"]}, {"source": "Text", "text": "[iamlive](https://github.com/iann0036/iamlive) uses the Client Side Monitoring feature of the AWS SDK to create a minimal policy based on the executed API calls. ", "keywords": ["feature", "policy"]}]}, {"Id": "284914555", "PostHistoryTypeId": "5", "PostId": "66307357", "RevisionGUID": "b4048a6d-d6b6-4d39-bb1b-81ec8d85984f", "CreationDate": "2022-12-24T11:25:29.217", "UserId": "336271", "Comment": "added 98 characters in body", "Text": "While I still believe that such super strict policy will be a continuous pain and likely kill productivity (but might depend on the project), there is now a tool for this.\r\n\r\n[iamlive](https://github.com/iann0036/iamlive) uses the Client Side Monitoring feature of the AWS SDK to create a minimal policy based on the executed API calls. As Terraform uses the AWS SDK, this works here as well.\r\n\r\nIn contrast to my previous (and accepted) answer, iamlive should even get the actual IAM actions right, which not necessarily match the API calls 1:1 (and which would be logged by CloudTrail).\r\n\r\nEDIT: \r\n\r\n\r\nFor this to work with terraform, you should do `export AWS_CSM_ENABLED=true`\r\n", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "While I still believe that such super strict policy will be a continuous pain and likely kill productivity (but might depend on the project), there is now a tool for this. ", "keywords": ["policy"]}, {"source": "Text", "text": "[iamlive](https://github.com/iann0036/iamlive) uses the Client Side Monitoring feature of the AWS SDK to create a minimal policy based on the executed API calls. ", "keywords": ["feature", "policy"]}]}, {"Id": "284950169", "PostHistoryTypeId": "5", "PostId": "66307357", "RevisionGUID": "86104abe-209c-469e-9049-9045c3457757", "CreationDate": "2022-12-25T12:06:11.273", "UserId": "400222", "Comment": "deleted 12 characters in body", "Text": "While I still believe that such super strict policy will be a continuous pain and likely kill productivity (but might depend on the project), there is now a tool for this.\r\n\r\n[iamlive](https://github.com/iann0036/iamlive) uses the Client Side Monitoring feature of the AWS SDK to create a minimal policy based on the executed API calls. As Terraform uses the AWS SDK, this works here as well.\r\n\r\nIn contrast to my previous (and accepted) answer, iamlive should even get the actual IAM actions right, which not necessarily match the API calls 1:1 (and which would be logged by CloudTrail).\r\n\r\nFor this to work with terraform, you should do `export AWS_CSM_ENABLED=true`\r\n", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "While I still believe that such super strict policy will be a continuous pain and likely kill productivity (but might depend on the project), there is now a tool for this. ", "keywords": ["policy"]}, {"source": "Text", "text": "[iamlive](https://github.com/iann0036/iamlive) uses the Client Side Monitoring feature of the AWS SDK to create a minimal policy based on the executed API calls. ", "keywords": ["feature", "policy"]}]}], "filtered-sentences": [{"source": "Body", "text": "While I still believe that such super strict policy will be a continuous pain and likely kill productivity (but might depend on the project), there is now a tool for this. ", "keywords": ["policy"]}, {"source": "Body", "text": "iamlive uses the Client Side Monitoring feature of the AWS SDK to create a minimal policy based on the executed API calls. ", "keywords": ["feature", "policy"]}]}, {"Id": "60542958", "PostTypeId": "2", "ParentId": "51273227", "CreationDate": "2020-03-05T10:15:21.947", "Score": "67", "Body": "<p>Here is another approach, similar to what was said above, but without getting into CloudTrail -</p>\n\n<ol>\n<li>Give full permissions to your IAM user.</li>\n<li>Run <code>TF_LOG=trace terraform apply --auto-approve &amp;&gt; log.log</code></li>\n<li>Run <code>cat log.log | grep \"DEBUG: Request\"</code> </li>\n</ol>\n\n<p>You will get a list of all AWS Actions used.</p>\n", "OwnerUserId": "1173751", "LastActivityDate": "2020-03-05T10:15:21.947", "CommentCount": "9", "ContentLicense": "CC BY-SA 4.0", "comments": [{"Id": "107159011", "PostId": "60542958", "Score": "1", "Text": "This seems like a decent way to go about it because the log would be parseable to extract the permissions automatically. If you couldn't give full permissions for some reason, run `terraform apply` in an interactive, iterable loop and add permissions through IAM each time something fails, provided that the exact permission text is available in the log output. Neat!", "CreationDate": "2020-03-06T19:26:26.070", "UserId": "204052", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "107174749", "PostId": "60542958", "Score": "4", "Text": "@ColinDean Thanks. That's a good direction but please notice that you can't automate this 100%, some actions have permissions with different names, e.g. \"s3.GetBucketAccelerateConfiguration\" needs the permission \"s3:GetAccelerateConfiguration\".", "CreationDate": "2020-03-07T16:42:53.720", "UserId": "1173751", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "112473663", "PostId": "60542958", "Score": "0", "Text": "Great solution @AvnerSo! I typically dev the terraform code in a testing account where I am an admin with full permissions. Once ready I create dedicated roles with minimal permissions for the accounts and environments the final infra will be deployed into. Your solution targets the required permissions (or close to them) pretty quickly for my workflow.", "CreationDate": "2020-08-26T19:51:59.273", "UserId": "3723796", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "I typically dev the terraform code in a testing account where I am an admin with full permissions. ", "keywords": ["test"]}]}, {"Id": "117176519", "PostId": "60542958", "Score": "1", "Text": "this recommendation, and the CloudTrail one, works fine when you are setting up a project for the first time \u2014 that is, granting full power (step 1) is _feasible_. Any delta use case where there is the need to build a new feature for a production system can\u2019t use this method as it\u2019s too dangerous.", "CreationDate": "2021-02-19T13:32:57.027", "UserId": "1115762", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "Any delta use case where there is the need to build a new feature for a production system can\u2019t use this method as it\u2019s too dangerous.", "keywords": ["feature"]}]}, {"Id": "120746011", "PostId": "60542958", "Score": "0", "Text": "This was a godsend for me, thank you! For some reason though it didn't notice a KMS key use during `terraform plan`, and I had to add `kms:Decrypt` as well.", "CreationDate": "2021-07-09T17:05:16.137", "UserId": "2573402", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "125175424", "PostId": "60542958", "Score": "0", "Text": "Thanks! One can also use process substitution and some sed replacements to see the actions right in the terminal output:\n`TF_LOG=trace terraform apply -auto-approve 2> >(grep --line-buffered -i \"DEBUG: Request\" | sed 's/.*DEBUG: Request //;s/ Details://;s#/#:#' | sort | cat)`", "CreationDate": "2022-01-21T19:40:24.723", "UserId": "3206908", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "131914275", "PostId": "60542958", "Score": "0", "Text": "`cat log.log | grep -e \"DEBUG: Request.*\" -o | awk '{print $3}' | sort | uniq` command to parse all IAM actions", "CreationDate": "2022-12-09T12:24:40.453", "UserId": "4073304", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "131914975", "PostId": "60542958", "Score": "0", "Text": "This has a drawback that, if some resources are already exist, then it will just have describe calls, no create/update calls will be made by terraform. So those will not get caught here.", "CreationDate": "2022-12-09T12:59:18.617", "UserId": "4073304", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "133018202", "PostId": "60542958", "Score": "2", "Text": "@AvnerSo Thanks for the great solution! But it seems like the log format has changed in the meanwhile.\nI looked for occurrences of  ```aws.operation=``` instead and replaced your last step with: ```cat log.log | grep -o \"aws.operation=[a-zA-Z0-9]*\" | uniq``` which gives me a list of AWS operations used.", "CreationDate": "2023-02-08T13:00:12.057", "UserId": "713751", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "But it seems like the log format has changed in the meanwhile. ", "keywords": ["change"]}]}], "history": [{"Id": "216326147", "PostHistoryTypeId": "2", "PostId": "60542958", "RevisionGUID": "005cf952-7de8-42c9-8df6-d9398ba8dd21", "CreationDate": "2020-03-05T10:15:21.947", "UserId": "1173751", "Text": "Here is another approach, similar to what was said above, but without getting into CloudTrail -\r\n\r\n1. Give full permissions to your IAM user.\r\n2. Run `TF_LOG=trace terraform apply --auto-approve &> log.log`\r\n3. Run `cat log.log | grep \"DEBUG: Request\"` \r\n\r\nYou will get a list of all AWS Actions used.\r\n\r\n", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "filtered-sentences": []}, {"Id": "51275413", "PostTypeId": "2", "ParentId": "51273227", "CreationDate": "2018-07-10T23:57:53.023", "Score": "9", "Body": "<h3>Efficient way I followed.</h3>\n\n<p>The way I deal with is, allow all permissions (*) for that service first, then deny some of them if not required.</p>\n\n<p>For example</p>\n\n<pre><code>{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Sid\": \"AllowSpecifics\",\n            \"Action\": [\n                \"ec2:*\",\n                \"rds:*\",\n                \"s3:*\",\n                \"sns:*\",\n                \"sqs:*\",\n                \"iam:*\",\n                \"elasticloadbalancing:*\",\n                \"autoscaling:*\",\n                \"cloudwatch:*\",\n                \"cloudfront:*\",\n                \"route53:*\",\n                \"ecr:*\",\n                \"logs:*\",\n                \"ecs:*\",\n                \"application-autoscaling:*\",\n                \"logs:*\",\n                \"events:*\",\n                \"elasticache:*\",\n                \"es:*\",\n                \"kms:*\",\n                \"dynamodb:*\"\n            ],\n            \"Effect\": \"Allow\",\n            \"Resource\": \"*\"\n        },\n        {\n            \"Sid\": \"DenySpecifics\",\n            \"Action\": [\n                \"iam:*User*\",\n                \"iam:*Login*\",\n                \"iam:*Group*\",\n                \"iam:*Provider*\",\n                \"aws-portal:*\",\n                \"budgets:*\",\n                \"config:*\",\n                \"directconnect:*\",\n                \"aws-marketplace:*\",\n                \"aws-marketplace-management:*\",\n                \"ec2:*ReservedInstances*\"\n            ],\n            \"Effect\": \"Deny\",\n            \"Resource\": \"*\"\n        }\n    ]\n}\n</code></pre>\n\n<p>You can easily adjust the list in Deny session, if terraform doesn't need or your company doesn't use some aws services.</p>\n\n<p><a href=\"https://i.stack.imgur.com/G9H39.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/G9H39.png\" alt=\"enter image description here\"></a></p>\n", "OwnerUserId": "498256", "LastActivityDate": "2018-07-10T23:57:53.023", "CommentCount": "1", "ContentLicense": "CC BY-SA 4.0", "comments": [{"Id": "89675894", "PostId": "51275413", "Score": "3", "Text": "This is certainly a way to do it, but I'm concerned about missing something. I'd end up having to keep up with the action list as it changes, adding a maintenance burden risk I'm not sure I want to accept.", "CreationDate": "2018-07-15T19:50:19.400", "UserId": "204052", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "I'd end up having to keep up with the action list as it changes, adding a maintenance burden risk I'm not sure I want to accept.", "keywords": ["change"]}]}], "history": [{"Id": "177377346", "PostHistoryTypeId": "2", "PostId": "51275413", "RevisionGUID": "7623144f-3564-4a85-a34a-7c38801b436f", "CreationDate": "2018-07-10T23:57:53.023", "UserId": "498256", "Text": "### Efficient way I followed.\r\n\r\nThe way I deal with is, allow all permissions (*) for that service first, then deny some of them if not required.\r\n\r\nFor example\r\n\r\n    {\r\n        \"Version\": \"2012-10-17\",\r\n        \"Statement\": [\r\n            {\r\n                \"Sid\": \"AllowSpecifics\",\r\n                \"Action\": [\r\n                    \"ec2:*\",\r\n                    \"rds:*\",\r\n                    \"s3:*\",\r\n                    \"sns:*\",\r\n                    \"sqs:*\",\r\n                    \"iam:*\",\r\n                    \"elasticloadbalancing:*\",\r\n                    \"autoscaling:*\",\r\n                    \"cloudwatch:*\",\r\n                    \"cloudfront:*\",\r\n                    \"route53:*\",\r\n                    \"ecr:*\",\r\n                    \"logs:*\",\r\n                    \"ecs:*\",\r\n                    \"application-autoscaling:*\",\r\n                    \"logs:*\",\r\n                    \"events:*\",\r\n                    \"elasticache:*\",\r\n                    \"es:*\",\r\n                    \"kms:*\",\r\n                    \"dynamodb:*\"\r\n                ],\r\n                \"Effect\": \"Allow\",\r\n                \"Resource\": \"*\"\r\n            },\r\n            {\r\n                \"Sid\": \"DenySpecifics\",\r\n                \"Action\": [\r\n                    \"iam:*User*\",\r\n                    \"iam:*Login*\",\r\n                    \"iam:*Group*\",\r\n                    \"iam:*Provider*\",\r\n                    \"aws-portal:*\",\r\n                    \"budgets:*\",\r\n                    \"config:*\",\r\n                    \"directconnect:*\",\r\n                    \"aws-marketplace:*\",\r\n                    \"aws-marketplace-management:*\",\r\n                    \"ec2:*ReservedInstances*\"\r\n                ],\r\n                \"Effect\": \"Deny\",\r\n                \"Resource\": \"*\"\r\n            }\r\n        ]\r\n    }\r\n\r\nYou can easily adjust the list in Deny session, if terraform doesn't need or your company doesn't use some aws services.\r\n\r\n[![enter image description here][1]][1]\r\n\r\n\r\n  [1]: https://i.stack.imgur.com/G9H39.png", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "Efficient way I followed. ", "keywords": ["efficient"]}, {"source": "Text", "text": "For example { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Sid\": \"AllowSpecifics\", \"Action\": [ \"ec2:*\", \"rds:*\", \"s3:*\", \"sns:*\", \"sqs:*\", \"iam:*\", \"elasticloadbalancing:*\", \"autoscaling:*\", \"cloudwatch:*\", \"cloudfront:*\", \"route53:*\", \"ecr:*\", \"logs:*\", \"ecs:*\", \"application-autoscaling:*\", \"logs:*\", \"events:*\", \"elasticache:*\", \"es:*\", \"kms:*\", \"dynamodb:*\" ], \"Effect\": \"Allow\", \"Resource\": \"*\" }, { \"Sid\": \"DenySpecifics\", \"Action\": [ \"iam:*User*\", \"iam:*Login*\", \"iam:*Group*\", \"iam:*Provider*\", \"aws-portal:*\", \"budgets:*\", \"config:*\", \"directconnect:*\", \"aws-marketplace:*\", \"aws-marketplace-management:*\", \"ec2:*ReservedInstances*\" ], \"Effect\": \"Deny\", \"Resource\": \"*\" ", "keywords": ["provider"]}]}], "filtered-sentences": [{"source": "Body", "text": "Efficient way I followed. ", "keywords": ["efficient"]}]}, {"Id": "75581796", "PostTypeId": "2", "ParentId": "51273227", "CreationDate": "2023-02-27T14:31:50.393", "Score": "0", "Body": "<p>Commenting on <a href=\"https://stackoverflow.com/questions/51273227/whats-the-most-efficient-way-to-determine-the-minimum-aws-permissions-necessary/60542958#60542958\">AvnerSo's Answer</a>. As someone else mentioned further up, log format has since changed.</p>\n<p>In any case, I used the following command to find what I was looking for:\n<code>perl -ne 'm/aws.operation=([\\S]*).*aws.service=&quot;([\\S]*\\s[\\S]*)&quot;/ &amp;&amp; !$seen{&quot;$1:$2&quot;}++ &amp;&amp; print &quot;$2: $1\\n&quot;' log.log</code></p>\n", "OwnerUserId": "20213694", "LastEditorUserId": "20213694", "LastEditDate": "2023-02-28T13:20:05.000", "LastActivityDate": "2023-02-28T13:20:05.000", "CommentCount": "0", "ContentLicense": "CC BY-SA 4.0", "history": [{"Id": "288823992", "PostHistoryTypeId": "2", "PostId": "75581796", "RevisionGUID": "77d4836a-7f96-4a50-8fa0-30a551477ad5", "CreationDate": "2023-02-27T14:31:50.393", "UserId": "20213694", "Text": "Commenting on [AvnerSo's Answer](https://stackoverflow.com/questions/51273227/whats-the-most-efficient-way-to-determine-the-minimum-aws-permissions-necessary/60542958#60542958). As someone else mentioned further up, log format has since changed.\r\n\r\nNot only that but in my case, piping the apply command to a file prevented some of resources of being deployed. Maybe this messes up Terraforms outputs?\r\n\r\nIn any case, I used the following command to find what I was looking for: \r\n`perl -ne 'm/aws.operation=([\\S]*).*aws.service=\"([\\S]*\\s[\\S]*)\"/ && !$seen{\"$1:$2\"}++ && print \"$2: $1\\n\"' log.log`  ", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "Commenting on [AvnerSo's Answer](https://stackoverflow.com/questions/51273227/whats-the-most-efficient-way-to-determine-the-minimum-aws-permissions-necessary/60542958#60542958). ", "keywords": ["efficient"]}, {"source": "Text", "text": "As someone else mentioned further up, log format has since changed. ", "keywords": ["change"]}]}, {"Id": "288850567", "PostHistoryTypeId": "5", "PostId": "75581796", "RevisionGUID": "41c3ce35-01bc-49cd-aa71-b2f2b030a930", "CreationDate": "2023-02-27T23:07:06.817", "UserId": "20213694", "Comment": "added 5 characters in body", "Text": "Commenting on [AvnerSo's Answer](https://stackoverflow.com/questions/51273227/whats-the-most-efficient-way-to-determine-the-minimum-aws-permissions-necessary/60542958#60542958). As someone else mentioned further up, log format has since changed.\r\n\r\nNot only that but in my case, redirecting the apply command to a file prevented some of resources of being deployed. Maybe this messes up Terraforms outputs?\r\n\r\nIn any case, I used the following command to find what I was looking for: \r\n`perl -ne 'm/aws.operation=([\\S]*).*aws.service=\"([\\S]*\\s[\\S]*)\"/ && !$seen{\"$1:$2\"}++ && print \"$2: $1\\n\"' log.log`  ", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "Commenting on [AvnerSo's Answer](https://stackoverflow.com/questions/51273227/whats-the-most-efficient-way-to-determine-the-minimum-aws-permissions-necessary/60542958#60542958). ", "keywords": ["efficient"]}, {"source": "Text", "text": "As someone else mentioned further up, log format has since changed. ", "keywords": ["change"]}]}, {"Id": "288885905", "PostHistoryTypeId": "5", "PostId": "75581796", "RevisionGUID": "520f73f2-16a6-4948-9198-12d178ceb13d", "CreationDate": "2023-02-28T13:20:05.000", "UserId": "20213694", "Comment": "deleted 161 characters in body", "Text": "Commenting on [AvnerSo's Answer](https://stackoverflow.com/questions/51273227/whats-the-most-efficient-way-to-determine-the-minimum-aws-permissions-necessary/60542958#60542958). As someone else mentioned further up, log format has since changed.\r\n\r\nIn any case, I used the following command to find what I was looking for: \r\n`perl -ne 'm/aws.operation=([\\S]*).*aws.service=\"([\\S]*\\s[\\S]*)\"/ && !$seen{\"$1:$2\"}++ && print \"$2: $1\\n\"' log.log`  ", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "Commenting on [AvnerSo's Answer](https://stackoverflow.com/questions/51273227/whats-the-most-efficient-way-to-determine-the-minimum-aws-permissions-necessary/60542958#60542958). ", "keywords": ["efficient"]}, {"source": "Text", "text": "As someone else mentioned further up, log format has since changed. ", "keywords": ["change"]}]}], "filtered-sentences": [{"source": "Body", "text": "As someone else mentioned further up, log format has since changed. ", "keywords": ["change"]}]}], "contains-topic": true, "filtered-sentences": [{"source": "Title", "text": "What's the most efficient way to determine the minimum AWS permissions necessary for a Terraform configuration?", "keywords": ["efficient"]}, {"source": "Body", "text": "In pursuit of automating the application of this Terraform configuration, I want to determine the minimum set of permissions necessary to apply the configuration initially and effect subsequent changes. ", "keywords": ["change"]}, {"source": "Body", "text": "I specifically want to avoid giving overbroad permissions in policy, e.g. {actions: [\"s3:*\"], resources: [\"*\"]}. ", "keywords": ["policy"]}, {"source": "Body", "text": "I look at the output or at the terraform log output to see what API call failed and then add it to the deployment user policy. ", "keywords": ["policy"]}, {"source": "Body", "text": "Is there a more efficient way to do this? ", "keywords": ["efficient"]}]}