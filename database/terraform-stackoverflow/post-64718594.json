{"Id": "64718594", "PostTypeId": "1", "AcceptedAnswerId": "64760064", "CreationDate": "2020-11-06T16:47:51.150", "Score": "1", "ViewCount": "2257", "Body": "<p>I'm using Open Policy Agent to write policy against the JSON output of my terraform state.</p>\n<p>Here is the structure of the state file:</p>\n<pre><code>{\n  &quot;format_version&quot;: &quot;0.1&quot;,\n  &quot;terraform_version&quot;: &quot;0.12.28&quot;,\n  &quot;values&quot;: {\n    &quot;root_module&quot;: {\n      &quot;resources&quot;: [],\n      &quot;child_modules&quot;: [\n        {\n          &quot;resources&quot;: [],\n          &quot;address&quot;: &quot;&quot;,\n          &quot;child_modules&quot;: [\n            {\n              &quot;resources&quot;: [],\n              &quot;address&quot;: &quot;&quot;,\n              &quot;child_modules&quot;: [\n                {}\n              ]\n            }\n          ]\n        }\n      ]\n    }\n  }\n}\n</code></pre>\n<p>I have this nasty rule defined that achieves what I want, but it is obviously not an ideal way to be aggregating these resources.</p>\n<pre><code>resources[resource_type] = all {\n    some resource_type\n    resource_types[resource_type]\n    rm := tfstate.values.root_module\n\n    # I think the below can be simplified with the built in &quot;walk&quot; function TODO: do that.\n    root_resources := [name |\n        name := rm.resources[_]\n        name.type == resource_type\n    ]\n\n    cmone_resources = [name |\n        name := rm.child_modules[_].resources[_]\n        name.type == resource_type\n    ]\n\n    cmtwo_resources = [name |\n        name := rm.child_modules[_].child_modules[_].resources[_]\n        name.type == resource_type\n    ]\n\n    cm := array.concat(cmone_resources, cmtwo_resources)\n\n    all := array.concat(cm, root_resources)\n}\n</code></pre>\n<p>I have read the documentation of the built-in function <code>walk(x, [path, value])</code>. Docs <a href=\"https://www.openpolicyagent.org/docs/latest/policy-reference/#graphs\" rel=\"nofollow noreferrer\">here</a>. I believe this function does what I want it to do, but based on the documentation given and admittedly sparse examples I've found elsewhere, I cannot figure out how to get it to work how I'm expecting.</p>\n<p>I've included a <a href=\"https://play.openpolicyagent.org/p/VxJjrDfpf9\" rel=\"nofollow noreferrer\">playground</a> with a very basic setup and the current rule I have defined. Any help at all would be greatly appreciated.</p>\n", "OwnerUserId": "5499716", "LastEditorUserId": "5499716", "LastEditDate": "2020-11-06T18:26:50.777", "LastActivityDate": "2022-12-22T15:43:33.150", "Title": "Using walk to recursively aggregate resources in a terraform state with rego", "Tags": "<terraform><policy><open-policy-agent><rego>", "AnswerCount": "2", "CommentCount": "0", "ContentLicense": "CC BY-SA 4.0", "history": [{"Id": "234393439", "PostHistoryTypeId": "2", "PostId": "64718594", "RevisionGUID": "036d42af-f264-48e1-8d0d-2b74973cef7b", "CreationDate": "2020-11-06T16:47:51.150", "UserId": "5499716", "Text": "I'm using Open Policy Agent to write policy against the JSON output of my terraform state. \r\n\r\nHere is the structure of the state file: \r\n```\r\n{\r\n  \"format_version\": \"0.1\",\r\n  \"terraform_version\": \"0.12.28\",\r\n  \"values\": {\r\n    \"root_module\": {\r\n      \"resources\": [],\r\n      \"child_modules\": [\r\n        {\r\n          \"resources\": [],\r\n          \"address\": \"\",\r\n          \"child_modules\": [\r\n            {\r\n              \"resources\": [],\r\n              \"address\": \"\",\r\n              \"child_modules\": [\r\n                {}\r\n              ]\r\n            }\r\n          ]\r\n        }\r\n      ]\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nI have this nasty rule defined that achieves what I want, but it is obviously not an ideal way to be aggregating these resources.\r\n```\r\nresources[resource_type] = all {\r\n some resource_type\r\n resource_types[resource_type]\r\n rm := tfstate.values.root_module\r\n\r\n # I think the below can be simplified with the built in \"walk\" function TODO: do that.\r\n root_resources := [name |\r\n  name := rm.resources[_]\r\n  name.type == resource_type\r\n ]\r\n\r\n cmone_resources = [name |\r\n  name := rm.child_modules[_].resources[_]\r\n  name.type == resource_type\r\n ]\r\n\r\n cmtwo_resources = [name |\r\n  name := rm.child_modules[_].child_modules[_].resources[_]\r\n  name.type == resource_type\r\n ]\r\n\r\n cm := array.concat(cmone_resources, cmtwo_resources)\r\n\r\n all := array.concat(cm, root_resources)\r\n}\r\n```\r\n\r\nI have read the documentation of the built-in function `walk(x, [path, value])`. Docs [here](https://www.openpolicyagent.org/docs/latest/policy-reference/#graphs). I believe this function does what I want it to do, but based on the documentation given and admittedly sparse examples I've found elsewhere, I cannot figure out how to get it to work how I'm expecting. \r\n\r\nAny help at all would be greatly appreciated.", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "I'm using Open Policy Agent to write policy against the JSON output of my terraform state. ", "keywords": ["policy"]}, {"source": "Text", "text": "Docs [here](https://www.openpolicyagent.org/docs/latest/policy-reference/#graphs)", "keywords": ["policy"]}]}, {"Id": "234393440", "PostHistoryTypeId": "1", "PostId": "64718594", "RevisionGUID": "036d42af-f264-48e1-8d0d-2b74973cef7b", "CreationDate": "2020-11-06T16:47:51.150", "UserId": "5499716", "Text": "Using walk to recursively aggregate resources in a terraform state with rego", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "234393441", "PostHistoryTypeId": "3", "PostId": "64718594", "RevisionGUID": "036d42af-f264-48e1-8d0d-2b74973cef7b", "CreationDate": "2020-11-06T16:47:51.150", "UserId": "5499716", "Text": "<recursion><terraform><policy><open-policy-agent><rego>", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "234394003", "PostHistoryTypeId": "5", "PostId": "64718594", "RevisionGUID": "e7cf5901-7ef4-46d0-a2ea-36b55279bbb6", "CreationDate": "2020-11-06T16:56:27.420", "UserId": "5499716", "Comment": "added 137 characters in body", "Text": "I'm using Open Policy Agent to write policy against the JSON output of my terraform state. \r\n\r\nHere is the structure of the state file: \r\n```\r\n{\r\n  \"format_version\": \"0.1\",\r\n  \"terraform_version\": \"0.12.28\",\r\n  \"values\": {\r\n    \"root_module\": {\r\n      \"resources\": [],\r\n      \"child_modules\": [\r\n        {\r\n          \"resources\": [],\r\n          \"address\": \"\",\r\n          \"child_modules\": [\r\n            {\r\n              \"resources\": [],\r\n              \"address\": \"\",\r\n              \"child_modules\": [\r\n                {}\r\n              ]\r\n            }\r\n          ]\r\n        }\r\n      ]\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nI have this nasty rule defined that achieves what I want, but it is obviously not an ideal way to be aggregating these resources.\r\n```\r\nresources[resource_type] = all {\r\n some resource_type\r\n resource_types[resource_type]\r\n rm := tfstate.values.root_module\r\n\r\n # I think the below can be simplified with the built in \"walk\" function TODO: do that.\r\n root_resources := [name |\r\n  name := rm.resources[_]\r\n  name.type == resource_type\r\n ]\r\n\r\n cmone_resources = [name |\r\n  name := rm.child_modules[_].resources[_]\r\n  name.type == resource_type\r\n ]\r\n\r\n cmtwo_resources = [name |\r\n  name := rm.child_modules[_].child_modules[_].resources[_]\r\n  name.type == resource_type\r\n ]\r\n\r\n cm := array.concat(cmone_resources, cmtwo_resources)\r\n\r\n all := array.concat(cm, root_resources)\r\n}\r\n```\r\n\r\nI have read the documentation of the built-in function `walk(x, [path, value])`. Docs [here](https://www.openpolicyagent.org/docs/latest/policy-reference/#graphs). I believe this function does what I want it to do, but based on the documentation given and admittedly sparse examples I've found elsewhere, I cannot figure out how to get it to work how I'm expecting. \r\n\r\nI've included a [playground](https://play.openpolicyagent.org/p/VxJjrDfpf9) with a very basic setup and the current rule I have defined. Any help at all would be greatly appreciated.", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "I'm using Open Policy Agent to write policy against the JSON output of my terraform state. ", "keywords": ["policy"]}, {"source": "Text", "text": "Docs [here](https://www.openpolicyagent.org/docs/latest/policy-reference/#graphs). ", "keywords": ["policy"]}]}, {"Id": "234398970", "PostHistoryTypeId": "6", "PostId": "64718594", "RevisionGUID": "54aa6c94-3447-4f40-8d8c-bdb519f4622b", "CreationDate": "2020-11-06T18:26:50.777", "UserId": "5499716", "Comment": "edited tags", "Text": "<terraform><policy><open-policy-agent><rego>", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "answers": [{"Id": "74890695", "PostTypeId": "2", "ParentId": "64718594", "CreationDate": "2022-12-22T15:34:09.337", "Score": "0", "Body": "<p>I just had a lot of use for the above, excellent answer. I wanted to validate that certain controlled resources only be created from the designated module. The resulting rule looks like this:</p>\n<pre><code>has_key(x, k) { _ = x[k] }\n\ncontrolled_resources[resource] {\n  # Recursively walk the module hierarchy\n  [path, module_ref] := walk(tfplan[&quot;configuration&quot;])\n\n  # Filter out only objects that are modules, i.e. have a source property\n  source := module_ref[&quot;source&quot;]\n\n  # Get all resources created in the module and their types\n  resources := module_ref[&quot;module&quot;][&quot;resources&quot;]\n  resource_type := resources[_][&quot;type&quot;]\n\n  # Filter out resources that are considered controlled\n  has_key(controlled_resource_types, resource_type)\n\n  # Create an object with the module and the resource type,\n  # this is a set so duplicates will be removed based on this object\n  resource := {\n    &quot;module&quot;: source,\n    &quot;type&quot;: resource_type\n  }\n}\n\ndefault resources_valid := false\nresources_valid {\n  # Iterate over resource types in the controlled set\n  some resource_type\n  has_key(controlled_resource_types, resource_type)\n\n  # Get the allowed modules for each resource type\n  expected_modules := controlled_resource_types[resource_type]\n\n  # For each instance of a controlled resource type, make sure its\n  # module is listed in the expected modules\n  every resource_instance in controlled_resources {\n    startswith(resource_instance.module, expected_modules[_])\n  }\n}\n</code></pre>\n<p>controlled_resource_types is an object mapping types such as <code>aws_iam_role</code> to accepted modules. I hope it helps someone.</p>\n", "OwnerUserId": "94818", "LastEditorUserId": "94818", "LastEditDate": "2022-12-22T15:43:33.150", "LastActivityDate": "2022-12-22T15:43:33.150", "CommentCount": "0", "ContentLicense": "CC BY-SA 4.0", "history": [{"Id": "284810260", "PostHistoryTypeId": "2", "PostId": "74890695", "RevisionGUID": "8a40d48f-808d-43c5-866c-a45f4701a9f3", "CreationDate": "2022-12-22T15:34:09.337", "UserId": "94818", "Text": "I just had a lot of use for the above, excellent answer. I wanted to validate that certain controlled resources only be created from the designated module. The resulting rule looks like this:\r\n\r\n```rego\r\nhas_key(x, k) { _ = x[k] }\r\n\r\ncontrolled_resources[resource] {\r\n  [path, module_ref] := walk(tfplan[\"configuration\"])\r\n\r\n  # This is a module def if it has a source property\r\n  source := module_ref[\"source\"]\r\n  module := module_ref[\"module\"]\r\n  resources := module[\"resources\"]\r\n  resource_type := resources[_][\"type\"]\r\n\r\n  has_key(controlled_resource_types, resource_type)\r\n\r\n  resource := {\r\n    \"module\": source,\r\n    \"type\": resource_type\r\n  }\r\n}\r\n\r\ndefault resources_valid := false\r\nresources_valid {\r\n  some resource_type\r\n  has_key(controlled_resource_types, resource_type)\r\n  expected_modules := controlled_resource_types[resource_type]\r\n\r\n  every resource_instance in controlled_resources {\r\n    startswith(resource_instance.module, expected_modules[_])\r\n  }\r\n}\r\n```\r\n\r\ncontrolled_resource_types is an object mapping types such as `aws_iam_role` to accepted modules. I hope it helps someone.", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "284810967", "PostHistoryTypeId": "5", "PostId": "74890695", "RevisionGUID": "51f22852-b7f7-45b3-9a51-5add9f3356f8", "CreationDate": "2022-12-22T15:43:33.150", "UserId": "94818", "Comment": "Add some explanatory comments to the rules", "Text": "I just had a lot of use for the above, excellent answer. I wanted to validate that certain controlled resources only be created from the designated module. The resulting rule looks like this:\r\n\r\n```rego\r\nhas_key(x, k) { _ = x[k] }\r\n\r\ncontrolled_resources[resource] {\r\n  # Recursively walk the module hierarchy\r\n  [path, module_ref] := walk(tfplan[\"configuration\"])\r\n\r\n  # Filter out only objects that are modules, i.e. have a source property\r\n  source := module_ref[\"source\"]\r\n\r\n  # Get all resources created in the module and their types\r\n  resources := module_ref[\"module\"][\"resources\"]\r\n  resource_type := resources[_][\"type\"]\r\n\r\n  # Filter out resources that are considered controlled\r\n  has_key(controlled_resource_types, resource_type)\r\n\r\n  # Create an object with the module and the resource type,\r\n  # this is a set so duplicates will be removed based on this object\r\n  resource := {\r\n    \"module\": source,\r\n    \"type\": resource_type\r\n  }\r\n}\r\n\r\ndefault resources_valid := false\r\nresources_valid {\r\n  # Iterate over resource types in the controlled set\r\n  some resource_type\r\n  has_key(controlled_resource_types, resource_type)\r\n\r\n  # Get the allowed modules for each resource type\r\n  expected_modules := controlled_resource_types[resource_type]\r\n\r\n  # For each instance of a controlled resource type, make sure its\r\n  # module is listed in the expected modules\r\n  every resource_instance in controlled_resources {\r\n    startswith(resource_instance.module, expected_modules[_])\r\n  }\r\n}\r\n```\r\n\r\ncontrolled_resource_types is an object mapping types such as `aws_iam_role` to accepted modules. I hope it helps someone.", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "The resulting rule looks like this: ```rego has_key(x, k) { _ = x[k] } controlled_resources[resource] { # Recursively walk the module hierarchy [path, module_ref] := walk(tfplan[\"configuration\"]) # Filter out only objects that are modules, i.e. have a source property source := module_ref[\"source\"] # Get all resources created in the module and their types resources := module_ref[\"module\"][\"resources\"] resource_type := resources[_][\"type\"] # Filter out resources that are considered controlled has_key(controlled_resource_types, resource_type) # Create an object with the module and the resource type, # this is a set so duplicates will be removed based on this object resource := { \"module\": source, \"type\": resource_type } } default resources_valid := false resources_valid { # Iterate over resource types in the controlled set some resource_type has_key(controlled_resource_types, resource_type) # Get the allowed modules for each resource type expected_modules := controlled_resource_types[resource_type] # For each instance of a controlled resource type, make sure its # module is listed in the expected modules every resource_instance in controlled_resources { startswith(resource_instance.module, expected_modules[_]) } } ``` controlled_resource_types is an object mapping types such as `aws_iam_role` to accepted modules. ", "keywords": ["instance"]}]}], "filtered-sentences": []}, {"Id": "64760064", "PostTypeId": "2", "ParentId": "64718594", "CreationDate": "2020-11-09T22:18:46.750", "Score": "4", "Body": "<p>You're on the right track, and using <code>walk</code> would definitely be a good approach for collecting arbitrarily nested child resources.</p>\n<p>To get started we'll want to explore what walk does. It is going to essentially iterate over all nodes in the object we're walking over, and for each one it gives the &quot;path&quot; and current node value. The path is going to be an array of keys, so like for object:</p>\n<pre><code>{&quot;a&quot;: {&quot;b&quot;: {&quot;c&quot;: 123}}}\n</code></pre>\n<p>if we do a walk over (example below using the <code>opa run</code> REPL:</p>\n<pre><code>&gt; [path, value] = walk({&quot;a&quot;: {&quot;b&quot;: {&quot;c&quot;: 123}}})\n+---------------+-----------------------+\n|     path      |         value         |\n+---------------+-----------------------+\n| []            | {&quot;a&quot;:{&quot;b&quot;:{&quot;c&quot;:123}}} |\n| [&quot;a&quot;]         | {&quot;b&quot;:{&quot;c&quot;:123}}       |\n| [&quot;a&quot;,&quot;b&quot;]     | {&quot;c&quot;:123}             |\n| [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;] | 123                   |\n+---------------+-----------------------+\n</code></pre>\n<p>We see that we have every path and value combination for the values of <code>path</code> and <code>value</code>. You can capture any of these values while iterating in a partial rule (like your <code>resources</code> rule), or in a comprehension.</p>\n<p>So.. taking this over to the terraform stuff. If we modify the playground example to walk over the example input (which is slightly modified to give some unique names to things) we get:</p>\n<pre><code>walk_example[path] = value {\n    [path, value] := walk(tfstate)\n}\n</code></pre>\n<p><a href=\"https://play.openpolicyagent.org/p/2u5shGbrV2\" rel=\"nofollow noreferrer\">https://play.openpolicyagent.org/p/2u5shGbrV2</a></p>\n<p>If you look at the resulting value for <code>walk_example</code> we can see all the paths and values we'd expect to have to handle.</p>\n<p>From there it is a matter of doing the filtering, similar to what you've done in the <code>resources</code> rule, for the <code>resource_types</code>. Instead of doing iteration over the set we will use it as a lookup to check on each type that is OK, and we will build a full set of <em>all</em> resources first (without grouping them by type). The reasoning being that it is very expensive to walk over all nodes of the input json so we want to only do that a single time. We can subsequently walk over the full list of every resource faster with a second pass to group by type (as needed).</p>\n<p>An updated version would look something like:</p>\n<pre><code>walk_resources[resource] {  \n    [path, value] := walk(tfstate)\n\n    # Attempt to iterate over &quot;resources&quot; of the value, if the key doesn't\n    # exist its OK, this iteration for walk will be undefined, and excluded\n    # from the results.\n    # Note: If you needed to be sure it was a &quot;real&quot; resource, and not some\n    # key you can perform additional validation on the path here!\n    resource := value.resources[_]\n    \n    # check if the resource type was contained in the set of desired resource types\n    resource_types[resource.type]\n}\n</code></pre>\n<p><a href=\"https://play.openpolicyagent.org/p/TyqMKDyWyh\" rel=\"nofollow noreferrer\">https://play.openpolicyagent.org/p/TyqMKDyWyh</a></p>\n<p>^ The playground input was updated to include another level of nesting and types on the examples. You can see that the original <code>resources</code> output is missing that depth 3 resource, but the <code>walk_resources</code> set contains all of the expected ones.</p>\n<p>The last part, if you wanted to group them by type, add a complete rule like:</p>\n<pre><code># list of all resources of a given type. given type must be defined in the resource_types variable above\nresources = { resource_type: resources |\n    some resource_type\n    resource_types[resource_type]\n    resources := { resource | \n        walk_resources[resource]\n        resource.type == resource_type\n    }\n}\n</code></pre>\n<p><a href=\"https://play.openpolicyagent.org/p/RlRZwibij9\" rel=\"nofollow noreferrer\">https://play.openpolicyagent.org/p/RlRZwibij9</a></p>\n<p>Which replaces the original <code>resources</code> rule with a comprehension that is going to iterate over each resource type, and then collect resources matching the type.</p>\n<p>One extra pointer, which I've seen be a problem in these terraform resource helper rules, is that you will want to reference that &quot;complete&quot; rule, see <a href=\"https://www.openpolicyagent.org/docs/latest/policy-language/#complete-definitions\" rel=\"nofollow noreferrer\">https://www.openpolicyagent.org/docs/latest/policy-language/#complete-definitions</a> for some details on what that means, rather than the &quot;partial&quot; rule (in this case the ones building a set of resources versus assigning the value to the comprehension result). The problem being that internally, as of writing this, OPA will cache values for the &quot;complete&quot; rules whereas the partial rules are not. So if you then go and write a bunch of rules like:</p>\n<pre><code>deny[msg] {\n    r := resources[&quot;foo&quot;]\n    # enforce something for resources of type &quot;foo&quot;...\n    ...\n}\n\ndeny[msg] {\n    r := resources[&quot;bar&quot;]\n    # enforce something for resources of type &quot;bar&quot;...\n    ...\n}\n</code></pre>\n<p>You want to ensure that it is using a cached value for <code>resources</code> each time and not recalculating the set. The original version of your <code>resources</code> rule would suffer from that issue, along with using the <code>walk_resources</code> rule I've shown in those examples. Something to keep an eye on as it can have a pretty dramatic performance impact if you had a large input tfplan.</p>\n", "OwnerUserId": "4789546", "LastActivityDate": "2020-11-09T22:18:46.750", "CommentCount": "0", "ContentLicense": "CC BY-SA 4.0", "history": [{"Id": "234583099", "PostHistoryTypeId": "2", "PostId": "64760064", "RevisionGUID": "54cff1eb-9267-4a10-aa2f-dafca29ec31d", "CreationDate": "2020-11-09T22:18:46.750", "UserId": "4789546", "Text": "You're on the right track, and using `walk` would definitely be a good approach for collecting arbitrarily nested child resources.\r\n\r\nTo get started we'll want to explore what walk does. It is going to essentially iterate over all nodes in the object we're walking over, and for each one it gives the \"path\" and current node value. The path is going to be an array of keys, so like for object:\r\n\r\n```\r\n{\"a\": {\"b\": {\"c\": 123}}}\r\n```\r\nif we do a walk over (example below using the `opa run` REPL:\r\n\r\n```\r\n> [path, value] = walk({\"a\": {\"b\": {\"c\": 123}}})\r\n+---------------+-----------------------+\r\n|     path      |         value         |\r\n+---------------+-----------------------+\r\n| []            | {\"a\":{\"b\":{\"c\":123}}} |\r\n| [\"a\"]         | {\"b\":{\"c\":123}}       |\r\n| [\"a\",\"b\"]     | {\"c\":123}             |\r\n| [\"a\",\"b\",\"c\"] | 123                   |\r\n+---------------+-----------------------+\r\n```\r\nWe see that we have every path and value combination for the values of `path` and `value`. You can capture any of these values while iterating in a partial rule (like your `resources` rule), or in a comprehension.\r\n\r\nSo.. taking this over to the terraform stuff. If we modify the playground example to walk over the example input (which is slightly modified to give some unique names to things) we get:\r\n\r\n```rego\r\nwalk_example[path] = value {\r\n    [path, value] := walk(tfstate)\r\n}\r\n```\r\nhttps://play.openpolicyagent.org/p/2u5shGbrV2\r\n\r\nIf you look at the resulting value for `walk_example` we can see all the paths and values we'd expect to have to handle.\r\n\r\nFrom there it is a matter of doing the filtering, similar to what you've done in the `resources` rule, for the `resource_types`. Instead of doing iteration over the set we will use it as a lookup to check on each type that is OK, and we will build a full set of _all_ resources first (without grouping them by type). The reasoning being that it is very expensive to walk over all nodes of the input json so we want to only do that a single time. We can subsequently walk over the full list of every resource faster with a second pass to group by type (as needed).\r\n\r\n\r\nAn updated version would look something like: \r\n\r\n```rego\r\nwalk_resources[resource] { \r\n    [path, value] := walk(tfstate)\r\n\r\n    # Attempt to iterate over \"resources\" of the value, if the key doesn't\r\n    # exist its OK, this iteration for walk will be undefined, and excluded\r\n    # from the results.\r\n    # Note: If you needed to be sure it was a \"real\" resource, and not some\r\n    # key you can perform additional validation on the path here!\r\n    resource := value.resources[_]\r\n \r\n    # check if the resource type was contained in the set of desired resource types\r\n    resource_types[resource.type]\r\n}\r\n```\r\n\r\nhttps://play.openpolicyagent.org/p/TyqMKDyWyh\r\n\r\n^ The playground input was updated to include another level of nesting and types on the examples. You can see that the original `resources` output is missing that depth 3 resource, but the `walk_resources` set contains all of the expected ones.\r\n\r\nThe last part, if you wanted to group them by type, add a complete rule like:\r\n\r\n```rego\r\n# list of all resources of a given type. given type must be defined in the resource_types variable above\r\nresources = { resource_type: resources |\r\n some resource_type\r\n resource_types[resource_type]\r\n    resources := { resource | \r\n     walk_resources[resource]\r\n        resource.type == resource_type\r\n    }\r\n}\r\n```\r\nhttps://play.openpolicyagent.org/p/RlRZwibij9\r\n\r\nWhich replaces the original `resources` rule with a comprehension that is going to iterate over each resource type, and then collect resources matching the type.\r\n\r\nOne extra pointer, which I've seen be a problem in these terraform resource helper rules, is that you will want to reference that \"complete\" rule, see https://www.openpolicyagent.org/docs/latest/policy-language/#complete-definitions for some details on what that means, rather than the \"partial\" rule (in this case the ones building a set of resources versus assigning the value to the comprehension result). The problem being that internally, as of writing this, OPA will cache values for the \"complete\" rules whereas the partial rules are not. So if you then go and write a bunch of rules like:\r\n\r\n```\r\ndeny[msg] {\r\n    r := resources[\"foo\"]\r\n    # enforce something for resources of type \"foo\"...\r\n    ...\r\n}\r\n\r\ndeny[msg] {\r\n    r := resources[\"bar\"]\r\n    # enforce something for resources of type \"bar\"...\r\n    ...\r\n}\r\n```\r\nYou want to ensure that it is using a cached value for `resources` each time and not recalculating the set. The original version of your `resources` rule would suffer from that issue, along with using the `walk_resources` rule I've shown in those examples. Something to keep an eye on as it can have a pretty dramatic performance impact if you had a large input tfplan.", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "The reasoning being that it is very expensive to walk over all nodes of the input json so we want to only do that a single time. ", "keywords": ["expense"]}, {"source": "Text", "text": "One extra pointer, which I've seen be a problem in these terraform resource helper rules, is that you will want to reference that \"complete\" rule, see https://www.openpolicyagent.org/docs/latest/policy-language/#complete-definitions for some details on what that means, rather than the \"partial\" rule (in this case the ones building a set of resources versus assigning the value to the comprehension result). ", "keywords": ["policy"]}]}], "filtered-sentences": [{"source": "Body", "text": "The reasoning being that it is very expensive to walk over all nodes of the input json so we want to only do that a single time. ", "keywords": ["expense"]}, {"source": "Body", "text": "One extra pointer, which I've seen be a problem in these terraform resource helper rules, is that you will want to reference that \"complete\" rule, see https://www.openpolicyagent.org/docs/latest/policy-language/#complete-definitions for some details on what that means, rather than the \"partial\" rule (in this case the ones building a set of resources versus assigning the value to the comprehension result). ", "keywords": ["policy"]}]}], "contains-topic": true, "filtered-sentences": [{"source": "Body", "text": "I'm using Open Policy Agent to write policy against the JSON output of my terraform state. ", "keywords": ["policy"]}]}