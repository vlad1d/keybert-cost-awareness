{"Id": "66571571", "PostTypeId": "1", "AcceptedAnswerId": "66592508", "CreationDate": "2021-03-10T19:27:38.433", "Score": "0", "ViewCount": "107", "Body": "<p>We have a large infrastructure codebase in terraform and ansible. Some tasks require small changes like adding/modifying a role/playbook. Merge requests however run and deploy the entire stage of 1) provision vm &gt; 2) Install software &gt; 3) configure VM with playbook changes.</p>\n<p>The problem with step 2 is that it takes a significant amount of time to complete before getting to actully running the playbook, everytime.</p>\n<p>I am curious to learn a better way of CD, thanks.</p>\n", "OwnerUserId": "12911594", "LastActivityDate": "2021-03-12T00:29:13.237", "Title": "How to do terraform continuous deployment of large codebases faster?", "Tags": "<ansible><continuous-integration><terraform><continuous-deployment>", "AnswerCount": "2", "CommentCount": "4", "ContentLicense": "CC BY-SA 4.0", "comments": [{"Id": "117683159", "PostId": "66571571", "Score": "0", "Text": "what does terraform have to do with the three steps?", "CreationDate": "2021-03-10T19:31:19.463", "UserId": "2442804", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "117683274", "PostId": "66571571", "Score": "0", "Text": "provision the vm", "CreationDate": "2021-03-10T19:36:27.323", "UserId": "12911594", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "117683321", "PostId": "66571571", "Score": "0", "Text": "Then what exactly is the problem with terraform if step 1 involves terraform but step 2 is the actual problem? What is a \"large codebase\" and what is a \"significant amount of time\"? What does \"install software\" entail?", "CreationDate": "2021-03-10T19:38:08.890", "UserId": "2442804", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "117684547", "PostId": "66571571", "Score": "0", "Text": "We are looking to setup node-exporter on the database vms so the exporter playbook is being pushed to the repo and staged to deploy after the vm is provisioned, and the software (MySQL DB) installed, those stages take approx. 74 minutes to complete. I am just looking for a better way to test the exporter without requiring the previous steps everytime a change in the exporter role is committed.", "CreationDate": "2021-03-10T20:26:35.877", "UserId": "12911594", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "I am just looking for a better way to test the exporter without requiring the previous steps everytime a change in the exporter role is committed.", "keywords": ["change", "test"]}]}], "history": [{"Id": "242414728", "PostHistoryTypeId": "2", "PostId": "66571571", "RevisionGUID": "b6670f00-c527-4b3c-8a24-7ac5dfb38e81", "CreationDate": "2021-03-10T19:27:38.433", "UserId": "12911594", "Text": "We have a large infrastructure codebase in terraform and ansible. Some tasks require small changes like adding/modifying a role/playbook. Merge requests however run and deploy the entire stage of 1) provision vm > 2) Install software > 3) configure VM with playbook changes.\r\n\r\nThe problem with step 2 is that it takes a significant amount of time to complete before getting to actully running the playbook, everytime.\r\n\r\nI am curious to learn a better way of CD, thanks.", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "Some tasks require small changes like adding/modifying a role/playbook. ", "keywords": ["change"]}, {"source": "Text", "text": "Merge requests however run and deploy the entire stage of 1) provision vm > 2) Install software > 3) configure VM with playbook changes. ", "keywords": ["change"]}]}, {"Id": "242414729", "PostHistoryTypeId": "1", "PostId": "66571571", "RevisionGUID": "b6670f00-c527-4b3c-8a24-7ac5dfb38e81", "CreationDate": "2021-03-10T19:27:38.433", "UserId": "12911594", "Text": "How to do terraform continuous deployment of large codebases faster?", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "242414730", "PostHistoryTypeId": "3", "PostId": "66571571", "RevisionGUID": "b6670f00-c527-4b3c-8a24-7ac5dfb38e81", "CreationDate": "2021-03-10T19:27:38.433", "UserId": "12911594", "Text": "<ansible><continuous-integration><terraform><continuous-deployment>", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "answers": [{"Id": "66592508", "PostTypeId": "2", "ParentId": "66571571", "CreationDate": "2021-03-12T00:29:13.237", "Score": "1", "Body": "<p>One common approach to the situation you've described is to pre-build custom virtual machine images that already contain the software you'll need at runtime, and then the final configuration step can focus only on adding in any final configuration settings that can be learned only at runtime, such as the network location of some other service that software in the VM might depend on.</p>\n<p>One way to achieve this is to use <a href=\"https://www.packer.io/\" rel=\"nofollow noreferrer\">HashiCorp Packer</a> in a separate build step to derive a custom machine image from a base image that's already available. Packer has the option of running Ansible as a way to prepare an image, so if you already have your software installation steps (step 2) defined as an Ansible playbook then you could use a subset of your steps as machine image steps and then have your existing step 3 run Ansible again only to finalize the running machine.</p>\n<p>This approach would be effective only if you create new VMs more often than you change the software to be installed, because it relies on the ability to amortize the cost of building the image across multiple VM boots. If you need to change the installed software for every change anyway then there isn't really any generalized way to optimize, since you can only change the order you do the steps in, not how often you'd run each step.</p>\n", "OwnerUserId": "281848", "LastActivityDate": "2021-03-12T00:29:13.237", "CommentCount": "1", "ContentLicense": "CC BY-SA 4.0", "comments": [{"Id": "117739284", "PostId": "66592508", "Score": "0", "Text": "Thanks Martin, that answers my question.", "CreationDate": "2021-03-12T16:28:10.503", "UserId": "12911594", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "history": [{"Id": "242502225", "PostHistoryTypeId": "2", "PostId": "66592508", "RevisionGUID": "70883480-f8bd-447a-8a16-71ed69c12e5f", "CreationDate": "2021-03-12T00:29:13.237", "UserId": "281848", "Text": "One common approach to the situation you've described is to pre-build custom virtual machine images that already contain the software you'll need at runtime, and then the final configuration step can focus only on adding in any final configuration settings that can be learned only at runtime, such as the network location of some other service that software in the VM might depend on.\r\n\r\nOne way to achieve this is to use [HashiCorp Packer](https://www.packer.io/) in a separate build step to derive a custom machine image from a base image that's already available. Packer has the option of running Ansible as a way to prepare an image, so if you already have your software installation steps (step 2) defined as an Ansible playbook then you could use a subset of your steps as machine image steps and then have your existing step 3 run Ansible again only to finalize the running machine.\r\n\r\nThis approach would be effective only if you create new VMs more often than you change the software to be installed, because it relies on the ability to amortize the cost of building the image across multiple VM boots. If you need to change the installed software for every change anyway then there isn't really any generalized way to optimize, since you can only change the order you do the steps in, not how often you'd run each step.", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "This approach would be effective only if you create new VMs more often than you change the software to be installed, because it relies on the ability to amortize the cost of building the image across multiple VM boots. ", "keywords": ["cost", "change"]}, {"source": "Text", "text": "If you need to change the installed software for every change anyway then there isn't really any generalized way to optimize, since you can only change the order you do the steps in, not how often you'd run each step.", "keywords": ["change"]}]}], "filtered-sentences": [{"source": "Body", "text": "This approach would be effective only if you create new VMs more often than you change the software to be installed, because it relies on the ability to amortize the cost of building the image across multiple VM boots. ", "keywords": ["cost", "change"]}, {"source": "Body", "text": "If you need to change the installed software for every change anyway then there isn't really any generalized way to optimize, since you can only change the order you do the steps in, not how often you'd run each step.", "keywords": ["change"]}]}, {"Id": "66572059", "PostTypeId": "2", "ParentId": "66571571", "CreationDate": "2021-03-10T20:02:39.677", "Score": "0", "Body": "<p>You are combining both Infrastructure as code and configuration as code. It's a good pattern to split both Ansible and Terraform. so first provision using Terraform. then Configure using Ansible. There should be a decoupling between Terraform and Ansible.</p>\n", "OwnerUserId": "5532207", "LastActivityDate": "2021-03-10T20:02:39.677", "CommentCount": "1", "ContentLicense": "CC BY-SA 4.0", "comments": [{"Id": "117684714", "PostId": "66572059", "Score": "0", "Text": "Thanks Mohammed, the pipeline stages first provision the machine, then configure. Are you saying place both in different repos? Changes in the ansible playbooks trigger the pipeline to execute terraform to provision the vms and configure it, we are looking to add in a playbook to install node-exporters on the vms so in order to test it, seems like we have to trigger the pipeline from the start everytime, I was wondering if there a better way.", "CreationDate": "2021-03-10T20:33:44.103", "UserId": "12911594", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "Changes in the ansible playbooks trigger the pipeline to execute terraform to provision the vms and configure it, we are looking to add in a playbook to install node-exporters on the vms so in order to test it, seems like we have to trigger the pipeline from the start everytime, I was wondering if there a better way.", "keywords": ["change", "test"]}]}], "history": [{"Id": "242416726", "PostHistoryTypeId": "2", "PostId": "66572059", "RevisionGUID": "e7d75b24-68cb-4d5b-8b1e-ac6a67c87f4f", "CreationDate": "2021-03-10T20:02:39.677", "UserId": "5532207", "Text": "You are combining both Infrastructure as code and configuration as code. It's a good pattern to split both Ansible and Terraform. so first provision using Terraform. then Configure using Ansible. There should be a decoupling between Terraform and Ansible.", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "filtered-sentences": []}], "contains-topic": true, "filtered-sentences": [{"source": "Body", "text": "Some tasks require small changes like adding/modifying a role/playbook. ", "keywords": ["change"]}, {"source": "Body", "text": "Merge requests however run and deploy the entire stage of 1) provision vm > 2) Install software > 3) configure VM with playbook changes. ", "keywords": ["change"]}]}