{"Id": "49946382", "PostTypeId": "1", "CreationDate": "2018-04-20T16:51:18.990", "Score": "6", "ViewCount": "4339", "Body": "<p>I've just struggle with terraform, and <code>terraform destroy</code> parameters. If I\nhave three nodes and I deleted one of the nodes with <code>terraform destroy\n--target</code> I have the following:</p>\n\n<pre><code>$ terraform state list\npacket_device.jenkins-node[0]\npacket_device.jenkins-node[1]\npacket_device.jenkins-node[2]\n$ terraform destroy --target packet_device.jenkins-node[1]\n....\n....\n....\n$ terraform state list\npacket_device.jenkins-node[0]\npacket_device.jenkins-node[2]\n</code></pre>\n\n<p>If I decrease the node count to two, terraform destroy jenkins node 2 and\ncreate a new one (jenkins node 1). The count is still two, but terraform\ndestroy one server and create a new one. Is there any way to disable this\nbehaviour?</p>\n\n<pre><code>$ terraform plan\nRefreshing Terraform state in-memory prior to plan...\nThe refreshed state will be used to calculate this plan, but will not be\npersisted to local or remote state storage.\n\npacket_device.jenkins-node.2: Refreshing state... (ID: XXXX)\npacket_device.jenkins-node.0: Refreshing state... (ID: XXXX)\nThe Terraform execution plan has been generated and is shown below.\nResources are shown in alphabetical order for quick scanning. Green resources\nwill be created (or destroyed and then created if an existing resource\nexists), yellow resources are being changed in-place, and red resources\nwill be destroyed. Cyan entries are data sources to be read.\n\nNote: You didn't specify an \"-out\" parameter to save this plan, so when\n\"apply\" is called, Terraform can't guarantee this is what will execute.\n\n  + packet_device.jenkins-node[1]\n      access_private_ipv4:     \"&lt;computed&gt;\"\n      access_public_ipv4:      \"&lt;computed&gt;\"\n      access_public_ipv6:      \"&lt;computed&gt;\"\n      always_pxe:              \"false\"\n      billing_cycle:           \"hourly\"\n      created:                 \"&lt;computed&gt;\"\n      facility:                \"sjc1\"\n      hardware_reservation_id: \"&lt;computed&gt;\"\n      hostname:                \"jenkins-eloy\"\n      locked:                  \"&lt;computed&gt;\"\n      network.#:               \"&lt;computed&gt;\"\n      operating_system:        \"ubuntu_17_10\"\n      plan:                    \"baremetal_0\"\n      project_id:              \"ea13e749-0b1b-4c0d-9701-d0a3df7391f2\"\n      public_ipv4_subnet_size: \"&lt;computed&gt;\"\n      root_password:           \"&lt;sensitive&gt;\"\n      state:                   \"&lt;computed&gt;\"\n      updated:                 \"&lt;computed&gt;\"\n\n  - packet_device.jenkins-node[2]\n\n\nPlan: 1 to add, 0 to change, 1 to destroy.\n</code></pre>\n\n<p>If I set terraform plan with three nodes I got the following:</p>\n\n<pre><code>$ export TF_VAR_nodes=3\n$ terraform plan\nRefreshing Terraform state in-memory prior to plan...\nThe refreshed state will be used to calculate this plan, but will not be\npersisted to local or remote state storage.\n\npacket_device.jenkins-node.0: Refreshing state... (ID: 02287fed-c281-4027-8603-bcad6db8b8e6)\npacket_device.jenkins-node.2: Refreshing state... (ID: f35fa202-423d-4e02-9d18-1f1bd7f7a3ef)\nThe Terraform execution plan has been generated and is shown below.\nResources are shown in alphabetical order for quick scanning. Green resources\nwill be created (or destroyed and then created if an existing resource\nexists), yellow resources are being changed in-place, and red resources\nwill be destroyed. Cyan entries are data sources to be read.\n\nNote: You didn't specify an \"-out\" parameter to save this plan, so when\n\"apply\" is called, Terraform can't guarantee this is what will execute.\n\n  + packet_device.jenkins-node[1]\n      access_private_ipv4:     \"&lt;computed&gt;\"\n      access_public_ipv4:      \"&lt;computed&gt;\"\n      access_public_ipv6:      \"&lt;computed&gt;\"\n      always_pxe:              \"false\"\n      billing_cycle:           \"hourly\"\n      created:                 \"&lt;computed&gt;\"\n      facility:                \"sjc1\"\n      hardware_reservation_id: \"&lt;computed&gt;\"\n      hostname:                \"jenkins-eloy\"\n      locked:                  \"&lt;computed&gt;\"\n      network.#:               \"&lt;computed&gt;\"\n      operating_system:        \"ubuntu_17_10\"\n      plan:                    \"baremetal_0\"\n      project_id:              \"ea13e749-0b1b-4c0d-9701-d0a3df7391f2\"\n      public_ipv4_subnet_size: \"&lt;computed&gt;\"\n      root_password:           \"&lt;sensitive&gt;\"\n      state:                   \"&lt;computed&gt;\"\n      updated:                 \"&lt;computed&gt;\"\n\n\nPlan: 1 to add, 0 to change, 0 to destroy.\n</code></pre>\n\n<p>Any idea?</p>\n", "OwnerUserId": "992995", "LastActivityDate": "2020-09-14T18:51:02.623", "Title": "Terraform destroy --target behaviour", "Tags": "<terraform>", "AnswerCount": "2", "CommentCount": "1", "FavoriteCount": "0", "ContentLicense": "CC BY-SA 3.0", "comments": [{"Id": "91859276", "PostId": "49946382", "Score": "0", "Text": "Why is this your preferred approach verses the standard approach of reducing the resource count and reapplying the infrastructure?", "CreationDate": "2018-09-22T16:22:06.633", "UserId": "6229946", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "history": [{"Id": "171745327", "PostHistoryTypeId": "2", "PostId": "49946382", "RevisionGUID": "f4c1f096-5de8-4945-aef7-d41ce3f78463", "CreationDate": "2018-04-20T16:51:18.990", "UserId": "992995", "Text": "I've just struggle with terraform, and `terraform destroy` parameters. If I\r\nhave three nodes and I deleted one of the nodes with `terraform destroy\r\n--target` I have the following:\r\n\r\n\r\n    $ terraform state list\r\n    packet_device.jenkins-node[0]\r\n    packet_device.jenkins-node[1]\r\n    packet_device.jenkins-node[2]\r\n    $ terraform destroy --target packet_device.jenkins-node[1]\r\n    ....\r\n    ....\r\n    ....\r\n    $ terraform state list\r\n    packet_device.jenkins-node[0]\r\n    packet_device.jenkins-node[2]\r\n\r\n\r\nIf I decrease the node count to two, terraform destroy jenkins node 2 and\r\ncreate a new one (jenkins node 1). The count is still two, but terraform\r\ndestroy one server and create a new one. Is there any way to disable this\r\nbehaviour?\r\n\r\n\r\n    $ terraform plan\r\n    Refreshing Terraform state in-memory prior to plan...\r\n    The refreshed state will be used to calculate this plan, but will not be\r\n    persisted to local or remote state storage.\r\n\r\n    packet_device.jenkins-node.2: Refreshing state... (ID: XXXX)\r\n    packet_device.jenkins-node.0: Refreshing state... (ID: XXXX)\r\n    The Terraform execution plan has been generated and is shown below.\r\n    Resources are shown in alphabetical order for quick scanning. Green resources\r\n    will be created (or destroyed and then created if an existing resource\r\n    exists), yellow resources are being changed in-place, and red resources\r\n    will be destroyed. Cyan entries are data sources to be read.\r\n\r\n    Note: You didn't specify an \"-out\" parameter to save this plan, so when\r\n    \"apply\" is called, Terraform can't guarantee this is what will execute.\r\n\r\n      + packet_device.jenkins-node[1]\r\n          access_private_ipv4:     \"<computed>\"\r\n          access_public_ipv4:      \"<computed>\"\r\n          access_public_ipv6:      \"<computed>\"\r\n          always_pxe:              \"false\"\r\n          billing_cycle:           \"hourly\"\r\n          created:                 \"<computed>\"\r\n          facility:                \"sjc1\"\r\n          hardware_reservation_id: \"<computed>\"\r\n          hostname:                \"jenkins-eloy\"\r\n          locked:                  \"<computed>\"\r\n          network.#:               \"<computed>\"\r\n          operating_system:        \"ubuntu_17_10\"\r\n          plan:                    \"baremetal_0\"\r\n          project_id:              \"ea13e749-0b1b-4c0d-9701-d0a3df7391f2\"\r\n          public_ipv4_subnet_size: \"<computed>\"\r\n          root_password:           \"<sensitive>\"\r\n          state:                   \"<computed>\"\r\n          updated:                 \"<computed>\"\r\n\r\n      - packet_device.jenkins-node[2]\r\n\r\n\r\n    Plan: 1 to add, 0 to change, 1 to destroy.\r\n\r\nIf I set terraform plan with three nodes I got the following:\r\n\r\n    $ export TF_VAR_nodes=3\r\n    $ terraform plan\r\n    Refreshing Terraform state in-memory prior to plan...\r\n    The refreshed state will be used to calculate this plan, but will not be\r\n    persisted to local or remote state storage.\r\n\r\n    packet_device.jenkins-node.0: Refreshing state... (ID: 02287fed-c281-4027-8603-bcad6db8b8e6)\r\n    packet_device.jenkins-node.2: Refreshing state... (ID: f35fa202-423d-4e02-9d18-1f1bd7f7a3ef)\r\n    The Terraform execution plan has been generated and is shown below.\r\n    Resources are shown in alphabetical order for quick scanning. Green resources\r\n    will be created (or destroyed and then created if an existing resource\r\n    exists), yellow resources are being changed in-place, and red resources\r\n    will be destroyed. Cyan entries are data sources to be read.\r\n\r\n    Note: You didn't specify an \"-out\" parameter to save this plan, so when\r\n    \"apply\" is called, Terraform can't guarantee this is what will execute.\r\n\r\n      + packet_device.jenkins-node[1]\r\n          access_private_ipv4:     \"<computed>\"\r\n          access_public_ipv4:      \"<computed>\"\r\n          access_public_ipv6:      \"<computed>\"\r\n          always_pxe:              \"false\"\r\n          billing_cycle:           \"hourly\"\r\n          created:                 \"<computed>\"\r\n          facility:                \"sjc1\"\r\n          hardware_reservation_id: \"<computed>\"\r\n          hostname:                \"jenkins-eloy\"\r\n          locked:                  \"<computed>\"\r\n          network.#:               \"<computed>\"\r\n          operating_system:        \"ubuntu_17_10\"\r\n          plan:                    \"baremetal_0\"\r\n          project_id:              \"ea13e749-0b1b-4c0d-9701-d0a3df7391f2\"\r\n          public_ipv4_subnet_size: \"<computed>\"\r\n          root_password:           \"<sensitive>\"\r\n          state:                   \"<computed>\"\r\n          updated:                 \"<computed>\"\r\n\r\n\r\n    Plan: 1 to add, 0 to change, 0 to destroy.\r\n\r\nAny idea?\r\n", "ContentLicense": "CC BY-SA 3.0", "filtered-sentences": [{"source": "Text", "text": "The refreshed state will be used to calculate this plan, but will not be persisted to local or remote state storage. ", "keywords": ["storage"]}, {"source": "Text", "text": "Green resources will be created (or destroyed and then created if an existing resource exists), yellow resources are being changed in-place, and red resources will be destroyed. ", "keywords": ["change"]}, {"source": "Text", "text": "+ packet_device.jenkins-node[1] access_private_ipv4: \"\" access_public_ipv4: \"\" access_public_ipv6: \"\" always_pxe: \"false\" billing_cycle: \"hourly\" created: \"\" facility: \"sjc1\" hardware_reservation_id: \"\" hostname: \"jenkins-eloy\" locked: \"\" network.#: \"\" operating_system: \"ubuntu_17_10\" plan: \"baremetal_0\" project_id: \"ea13e749-0b1b-4c0d-9701-d0a3df7391f2\" public_ipv4_subnet_size: \"\" root_password: \"\" state: \"\" updated: \"\" - packet_device.jenkins-node[2] Plan: 1 to add, 0 to change, 1 to destroy. ", "keywords": ["bill", "change"]}, {"source": "Text", "text": "The refreshed state will be used to calculate this plan, but will not be persisted to local or remote state storage. ", "keywords": ["storage"]}, {"source": "Text", "text": "Green resources will be created (or destroyed and then created if an existing resource exists), yellow resources are being changed in-place, and red resources will be destroyed. ", "keywords": ["change"]}, {"source": "Text", "text": "+ packet_device.jenkins-node[1] access_private_ipv4: \"\" access_public_ipv4: \"\" access_public_ipv6: \"\" always_pxe: \"false\" billing_cycle: \"hourly\" created: \"\" facility: \"sjc1\" hardware_reservation_id: \"\" hostname: \"jenkins-eloy\" locked: \"\" network.#: \"\" operating_system: \"ubuntu_17_10\" plan: \"baremetal_0\" project_id: \"ea13e749-0b1b-4c0d-9701-d0a3df7391f2\" public_ipv4_subnet_size: \"\" root_password: \"\" state: \"\" updated: \"\" Plan: 1 to add, 0 to change, 0 to destroy. ", "keywords": ["bill", "change"]}]}, {"Id": "171745328", "PostHistoryTypeId": "1", "PostId": "49946382", "RevisionGUID": "f4c1f096-5de8-4945-aef7-d41ce3f78463", "CreationDate": "2018-04-20T16:51:18.990", "UserId": "992995", "Text": "Terraform destroy --target behaviour", "ContentLicense": "CC BY-SA 3.0", "filtered-sentences": []}, {"Id": "171745329", "PostHistoryTypeId": "3", "PostId": "49946382", "RevisionGUID": "f4c1f096-5de8-4945-aef7-d41ce3f78463", "CreationDate": "2018-04-20T16:51:18.990", "UserId": "992995", "Text": "<terraform>", "ContentLicense": "CC BY-SA 3.0", "filtered-sentences": []}], "answers": [{"Id": "49959084", "PostTypeId": "2", "ParentId": "49946382", "CreationDate": "2018-04-21T18:42:34.623", "Score": "5", "Body": "<p>There is not. However if you want to destroy <code>packet_device.jenkins-node[1]</code> you should then run </p>\n\n<pre><code>terraform state mv packet_device.jenkins-node.2 packet_device.jenkins-node.1\n</code></pre>\n\n<p>So node 2 becomes node 1</p>\n", "OwnerUserId": "2115135", "LastActivityDate": "2018-04-21T18:42:34.623", "CommentCount": "6", "ContentLicense": "CC BY-SA 3.0", "comments": [{"Id": "93955539", "PostId": "49959084", "Score": "1", "Text": "@Tiemen Sometimes the op never comes back to the question, other times they don't know how the site works, it happens that no answer is marked as accepted. Besides, there are plenty of questions where the accepted answer is not the most upvoted or the best so it's not really a big deal.", "CreationDate": "2018-11-29T17:24:57.580", "UserId": "2115135", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "112978395", "PostId": "49959084", "Score": "0", "Text": "this will not destroy the instances. It will only update the local state file.\nOn the next  apply, the state will be refreshed and resources will be recreated. causing duplicates.", "CreationDate": "2020-09-14T18:41:23.807", "UserId": "2084025", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "113027263", "PostId": "49959084", "Score": "0", "Text": "@GeorgeJ He was asking how he can delete second node and then downsize just to 2 nodes keeping first and third.", "CreationDate": "2020-09-16T10:45:47.870", "UserId": "2115135", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "113033518", "PostId": "49959084", "Score": "0", "Text": "Yes, but the thing is that his resources are identified by indexes. Deleting it from the state does not destroy the running instance. If he removes it from the state he needs to delete it manually outside terraform.", "CreationDate": "2020-09-16T13:56:12.093", "UserId": "2084025", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "Deleting it from the state does not destroy the running instance. ", "keywords": ["instance"]}]}, {"Id": "113033885", "PostId": "49959084", "Score": "0", "Text": "@GeorgeJ I'm not sure what you're talking about. The first snippet has the code `terraform destroy --target packet_device.jenkins-node[1]` which does a targeted destroy, then we move things in state.", "CreationDate": "2020-09-16T14:05:58.090", "UserId": "2115135", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "113038425", "PostId": "49959084", "Score": "0", "Text": "Sorry, I misunderstood the context of your answer. `how to switch the two nodes`...\nAnyway, I explained in my answer why this happens and how to avoid it.", "CreationDate": "2020-09-16T16:28:22.590", "UserId": "2084025", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "history": [{"Id": "171809067", "PostHistoryTypeId": "2", "PostId": "49959084", "RevisionGUID": "ef8da4b8-57e3-4b65-8abe-5e88a6a32386", "CreationDate": "2018-04-21T18:42:34.623", "UserId": "2115135", "Text": "There is not. However if you want to destroy `packet_device.jenkins-node[1]` you should then run \r\n\r\n    terraform state mv packet_device.jenkins-node.2 packet_device.jenkins-node.1\r\n\r\nSo node 2 becomes node 1", "ContentLicense": "CC BY-SA 3.0", "filtered-sentences": []}], "filtered-sentences": []}, {"Id": "63890071", "PostTypeId": "2", "ParentId": "49946382", "CreationDate": "2020-09-14T18:37:49.980", "Score": "1", "Body": "<p>the only safe way to update your infrastructure is to edit your files, plan, and apply. All other methods listed up there are only meant to be used in non-normal circumstances. And in time will cause your state to be shifted from the actual infrastructure you are running and paying for.</p>\n<hr />\n<p>It looks like your terraform infrastructure contains a <code>count</code> somewhere.</p>\n<p>Like this</p>\n<pre><code>module &quot;packet_device&quot; &quot;jenkins_node&quot; {\n    count = 3\n    ...other configs using ${count.index}\n}\n</code></pre>\n<p>If it does, there is a limitation when using count that is you cant just increase and decrease the count to scale up and down.</p>\n<p>Since you are using count, terraform stores the state of each module in an index format. [0: {module1},1: {module2},2: {module3}] and when you reduce the count to 2 or remove a single instance, it will cause a shift in the index and terraform will mark it as a change. Because it sees the index as a resource\u2019s identity.</p>\n<p>So let's say you removed index 0 you will end up with <code>[0: {module2},1: {module3}]</code></p>\n<p>module2 will have a new index which is 0, and module3 will have a new index which is 1. So terraform will have to destroy and recreate these modules because it does not know what happened.</p>\n<p>Unfortunately, you cannot prevent this behavior using the count configuration.</p>\n<hr />\n<p>What you need to do is use a map or <code>for_each</code>, that way the resources will be matched by a key, not by an index. So removing or adding other resources (in the same block) will not affect each other.</p>\n<p>This is just an example...</p>\n<pre><code>module &quot;packet_device&quot; &quot;jenkins_node&quot; {\n    for_each = toset([&quot;key1&quot;, &quot;key2&quot;, &quot;key3&quot;])\n    ...other configs and access the value by ${each.value}\n}\n</code></pre>\n<p>More information on for_each is available in the <a href=\"https://www.terraform.io/docs/configuration/resources.html\" rel=\"nofollow noreferrer\">documentation</a>.</p>\n", "OwnerUserId": "2084025", "LastEditorUserId": "2084025", "LastEditDate": "2020-09-14T18:51:02.623", "LastActivityDate": "2020-09-14T18:51:02.623", "CommentCount": "1", "ContentLicense": "CC BY-SA 4.0", "comments": [{"Id": "129797111", "PostId": "63890071", "Score": "0", "Text": "agree totally with George J here...\n\nfor_each is the way, otherwise reordering an array will destroy and recreate many things.", "CreationDate": "2022-08-26T12:32:29.097", "UserId": "1614809", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "history": [{"Id": "230814330", "PostHistoryTypeId": "2", "PostId": "63890071", "RevisionGUID": "979fb899-6498-4501-aa6f-81af77f11a0f", "CreationDate": "2020-09-14T18:37:49.980", "UserId": "2084025", "Text": "It looks like your terraform infrastructure contains a `count` somewhere.\r\n\r\nLike this\r\n\r\n    module \"packet_device\" \"jenkins_node\" {\r\n        count = 3\r\n        ...other configs using ${count.index}\r\n    }\r\n\r\nIf it does, there is a limitation when using count that is you cant just increase and decrease the count to scale up and down.\r\n\r\nSince you are using count, terraform stores the state of each module in an index format. [0: {module1},1: {module2},2: {module3}] and when you reduce the count to 2 or remove a single instance, it will cause a shift in the index and terraform will mark it as a change. Because it sees the index as a resource\u2019s identity.\r\n\r\nSo let's say you removed index 0 you will end up with [0: {module2},1: {module3}]\r\n\r\nmodule2 will have a new index which is 0, and module3 will have a new index which is 1. So terraform will have to destroy and recreate these modules because it does not know what happened.\r\n\r\n\r\nUnfortunately, you cannot prevent this behavior using the count configuration.\r\n\r\nWhat you need to do is use a map or `for_each`, that way the modules will be matched by a key, not by an index. So removing and adding instances will not affect other instances.\r\n\r\nThis is just an example...\r\n\r\n    module \"packet_device\" \"jenkins_node\" {\r\n        for_each = toset([0,1,2])\r\n        ...other configs and access the value by ${each.value}\r\n    }\r\n\r\nMore information on for_each is available in the [documentation][1].\r\n\r\n\r\n  [1]: https://www.terraform.io/docs/configuration/resources.html", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "Since you are using count, terraform stores the state of each module in an index format. [0: {module1},1: {module2},2: {module3}] and when you reduce the count to 2 or remove a single instance, it will cause a shift in the index and terraform will mark it as a change. ", "keywords": ["instance", "change"]}]}, {"Id": "230814736", "PostHistoryTypeId": "5", "PostId": "63890071", "RevisionGUID": "9ba7ce70-0c53-4808-ae82-91f5e6147a07", "CreationDate": "2020-09-14T18:44:16.873", "UserId": "2084025", "Comment": "added 191 characters in body", "Text": "the only safe way to update your infrastructure is to edit your files, plan, and apply. All other methods listed up there are only meant to be used in non-normal circumstances. And in time will cause your state to be shifted from the actual infrastructure you are running and paying for.\r\n\r\n-----\r\n\r\n\r\nIt looks like your terraform infrastructure contains a `count` somewhere.\r\n\r\nLike this\r\n\r\n    module \"packet_device\" \"jenkins_node\" {\r\n        count = 3\r\n        ...other configs using ${count.index}\r\n    }\r\n\r\nIf it does, there is a limitation when using count that is you cant just increase and decrease the count to scale up and down.\r\n\r\nSince you are using count, terraform stores the state of each module in an index format. [0: {module1},1: {module2},2: {module3}] and when you reduce the count to 2 or remove a single instance, it will cause a shift in the index and terraform will mark it as a change. Because it sees the index as a resource\u2019s identity.\r\n\r\nSo let's say you removed index 0 you will end up with [0: {module2},1: {module3}]\r\n\r\nmodule2 will have a new index which is 0, and module3 will have a new index which is 1. So terraform will have to destroy and recreate these modules because it does not know what happened.\r\n\r\n\r\nUnfortunately, you cannot prevent this behavior using the count configuration.\r\n\r\nWhat you need to do is use a map or `for_each`, that way the modules will be matched by a key, not by an index. So removing and adding instances will not affect other instances.\r\n\r\nThis is just an example...\r\n\r\n    module \"packet_device\" \"jenkins_node\" {\r\n        for_each = toset([0,1,2])\r\n        ...other configs and access the value by ${each.value}\r\n    }\r\n\r\nMore information on for_each is available in the [documentation][1].\r\n\r\n\r\n  [1]: https://www.terraform.io/docs/configuration/resources.html", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "Since you are using count, terraform stores the state of each module in an index format. [0: {module1},1: {module2},2: {module3}] and when you reduce the count to 2 or remove a single instance, it will cause a shift in the index and terraform will mark it as a change. ", "keywords": ["instance", "change"]}]}, {"Id": "230815131", "PostHistoryTypeId": "5", "PostId": "63890071", "RevisionGUID": "1e1ed02c-03c6-4e2d-beed-060f8b5dbb03", "CreationDate": "2020-09-14T18:51:02.623", "UserId": "2084025", "Comment": "added 191 characters in body", "Text": "the only safe way to update your infrastructure is to edit your files, plan, and apply. All other methods listed up there are only meant to be used in non-normal circumstances. And in time will cause your state to be shifted from the actual infrastructure you are running and paying for.\r\n\r\n-----\r\n\r\n\r\nIt looks like your terraform infrastructure contains a `count` somewhere.\r\n\r\nLike this\r\n\r\n    module \"packet_device\" \"jenkins_node\" {\r\n        count = 3\r\n        ...other configs using ${count.index}\r\n    }\r\n\r\nIf it does, there is a limitation when using count that is you cant just increase and decrease the count to scale up and down.\r\n\r\nSince you are using count, terraform stores the state of each module in an index format. [0: {module1},1: {module2},2: {module3}] and when you reduce the count to 2 or remove a single instance, it will cause a shift in the index and terraform will mark it as a change. Because it sees the index as a resource\u2019s identity.\r\n\r\nSo let's say you removed index 0 you will end up with `[0: {module2},1: {module3}]`\r\n\r\nmodule2 will have a new index which is 0, and module3 will have a new index which is 1. So terraform will have to destroy and recreate these modules because it does not know what happened.\r\n\r\nUnfortunately, you cannot prevent this behavior using the count configuration.\r\n\r\n------\r\n\r\nWhat you need to do is use a map or `for_each`, that way the resources will be matched by a key, not by an index. So removing or adding other resources (in the same block) will not affect each other.\r\n\r\nThis is just an example...\r\n\r\n    module \"packet_device\" \"jenkins_node\" {\r\n        for_each = toset([\"key1\", \"key2\", \"key3\"])\r\n        ...other configs and access the value by ${each.value}\r\n    }\r\n\r\nMore information on for_each is available in the [documentation][1].\r\n\r\n\r\n  [1]: https://www.terraform.io/docs/configuration/resources.html", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "[0: {module1},1: {module2},2: {module3}] and when you reduce the count to 2 or remove a single instance, it will cause a shift in the index and terraform will mark it as a change. ", "keywords": ["instance", "change"]}]}], "filtered-sentences": [{"source": "Body", "text": "[0: {module1},1: {module2},2: {module3}] and when you reduce the count to 2 or remove a single instance, it will cause a shift in the index and terraform will mark it as a change. ", "keywords": ["instance", "change"]}]}], "contains-topic": true, "filtered-sentences": []}